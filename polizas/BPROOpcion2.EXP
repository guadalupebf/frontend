

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Function Blocks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CycleStart
VAR
	fbTimerOne: TON; 			(* 	The timer will only expire if one or the other is pressed by itself *)
	bContinue: BOOL := FALSE; 	(* 	This will be set to TRUE at the event that cycle start has been cleared to
										continue without CS1 AND CS2 TRUE *)
END_VAR
VAR_INPUT
	bCS1: BOOL := FALSE; 		(* 	Cycle Start #1 *)
	bCS2: BOOL := FALSE; 		(* 	Cycle Start #2 *)
	bHold: BOOL := FALSE; 		(* 	This should go TRUE at the point that it has been deemed safe to continue operation *)
	bReset: BOOL := FALSE; 		(* 	Reset all variables to FALSE *)
END_VAR
VAR_OUTPUT
	bEnable: BOOL := FALSE; 	(* 	If conditions are met this will be TRUE upon release of both cycle starts *)
END_VAR

(* @END_DECLARATION := '0' *)
(* Internally reset this function back to the initial state *)
	IF bReset THEN
		bEnable:=FALSE;
		bContinue:=FALSE;
	END_IF;

(* Set fbTimerOne if and only if either CS1 is true OR CS2 is true but not both *)
	fbTimerOne(IN:= bCS1 XOR bCS2 , PT:= T#500ms , Q=> , ET=> );

(* Ensure Anti-Tie Down and safety is ensured *)
	IF bCS1 AND bCS2 AND NOT fbTimerOne.Q THEN
		bEnable:=TRUE;
	ELSIF bContinue THEN
		bEnable:=TRUE;
	ELSE
		bEnable:=FALSE;
	END_IF;

(* Once the block has been issued hold then CS1 AND CS2 can be released *)
	IF bCS1 AND bCS2 AND NOT fbTimerOne.Q AND bHold THEN
		bContinue:=TRUE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Function Blocks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_EtherCAT_Emerson
VAR_INPUT
	bRun : BOOL := FALSE;
	nRPM : UINT := 0;
	nOverride : UINT := 100;
	fRatio : LREAL := 1.0;
	bMotorDirection : BOOL := FALSE;
	bDataValid : BOOL := FALSE;
	bReset : BOOL := FALSE;
	sNetId : T_AmsNetId;
	nSlaveAddr : UINT;
END_VAR
VAR_OUTPUT
	bEnableDrive : BOOL:=FALSE;
	bUpToSpeed : BOOL := FALSE;
	bError : BOOL:=FALSE;
	nErrorID : UDINT:=0;
	stVFDInfo : Ke_VFDInfo;
END_VAR
VAR
	(*	TxPDO Variables	*)
	nMotorSpeed AT %I* : UINT := 0;
	nMotorVoltage AT %I* : UINT := 0;
	nMotorCurrent AT %I* : UDINT := 0;
	nMotorTorque AT %I* : UINT := 0;
	nMotorPower AT %I* : UINT := 0;
	nDriveStatus AT %I* : UINT := 0;
	nDCLinkVoltage AT %I* : UINT := 0;
	nOpDayCounter1 AT %I* : UINT := 0;
	nOpDayCounter2 AT %I* : UINT := 0;
	nEnergyCounter AT %I* : INT := 0;

	(*	RxPDO Variables	*)
	bRunStop	AT %Q* : BOOL := FALSE;
	bDirection AT %Q* : BOOL := FALSE;
	nSpeed AT %Q* : INT := 0;
	bDriveReset AT %Q* : BOOL := FALSE;

	(*	READ Data	*)
	arrReadData : ARRAY [0..5] OF UINT := 6(0);

	(*	Function Blocks	*)
	fbReadData0 : FB_EcCoESdoRead;
	bReadData0 : BOOL := FALSE;
	fbReadData1 : FB_EcCoESdoRead;
	bReadData1 : BOOL := FALSE;
	fbReadData2 : FB_EcCoESdoRead;
	bReadData2 : BOOL := FALSE;
	fbReadData3 : FB_EcCoESdoRead;
	bReadData3 : BOOL := FALSE;
	fbReadData4 : FB_EcCoESdoRead;
	bReadData4 : BOOL := FALSE;
	fbReadData5 : FB_EcCoESdoRead;
	bReadData5 : BOOL := FALSE;
	fbReadTimer : TON;
	bReadTimer: BOOL := FALSE;
	fbRunTrigger: R_TRIG;

	(*	Local Variables	*)
	nVFDState: Ke_VFDState := VFD_NotReady;
	nVFDRunState: Ke_VFDState := VFD_Run_Setup;
	nRPMStore: UDINT := 0;
	nNominalRPMStore: UDINT := 0;
	bDirectionStore: BOOL := FALSE;
	fRatioStore: LREAL := 1.0;
	nOverrideStore: UDINT := 100;

	fbUpToSpeedTimer: TON;
	bUpToSpeedTimer: BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
(*
	Read Variables Every 10 seconds when Data Valid - Bit false
	5.06, 5.07, 5.08, 5.09, 2.11, 2.21
*)
IF bDataValid THEN
	IF NOT(bReadTimer) THEN
		bReadTimer:=TRUE;
	ELSIF fbReadTimer.Q AND bReadTimer THEN
		IF
		(bReadData0 AND NOT(fbReadData0.bBusy))
		AND
		(bReadData1 AND NOT(fbReadData1.bBusy))
		AND
		(bReadData2 AND NOT(fbReadData2.bBusy))
		AND
		(bReadData3 AND NOT(fbReadData3.bBusy))
		AND
		(bReadData4 AND NOT(fbReadData4.bBusy))
		AND
		(bReadData5 AND NOT(fbReadData5.bBusy))
		THEN
			bReadData0:=FALSE;
			bReadData1:=FALSE;
			bReadData2:=FALSE;
			bReadData3:=FALSE;
			bReadData4:=FALSE;
			bReadData5:=FALSE;
			bReadTimer:=FALSE;
		ELSIF
		NOT(bReadData0 AND bReadData1 AND bReadData2 AND bReadData3 AND bReadData4 AND bReadData5)
		THEN
			bReadData0:=TRUE;
			bReadData1:=TRUE;
			bReadData2:=TRUE;
			bReadData3:=TRUE;
			bReadData4:=TRUE;
			bReadData5:=TRUE;
		END_IF
	END_IF (* Read Timer *)
END_IF (* Data Valid Check *)

(*	Convert Values	*)
IF NOT(fbReadTimer.Q) THEN
	stVFDInfo.fMotorNominalFrequency:=arrReadData[0]/10.0;
	stVFDInfo.fMotorNominalCurrent:=arrReadData[1]/100.0;
	stVFDInfo.nMotorNominalSpeed:=arrReadData[2];
	stVFDInfo.fMotorNominalVoltage:=arrReadData[3]*1.0;
	stVFDInfo.fAccelerationTime:=arrReadData[4]/10.0;
	stVFDInfo.fDecelerationTime:=arrReadData[5]/10.0;
END_IF
stVFDInfo.nMotorSpeed:=nMotorSpeed;
stVFDInfo.fMotorVoltage:=nMotorVoltage*1.0;
stVFDInfo.fMotorCurrent:=nMotorCurrent/100.0;
stVFDInfo.fMotorTorque:=nMotorTorque/10.0;
stVFDInfo.fMotorPower:=nMotorPower;
stVFDInfo.nStatusWord:=nDriveStatus;
stVFDInfo.nDCLinkVoltage:=nDCLinkVoltage;
stVFDInfo.stDayCounter.nYears:=LREAL_TO_UINT(FLOOR(nOpDayCounter1/1000.0));
stVFDInfo.stDayCounterResettable.nYears:=LREAL_TO_UINT(FLOOR(nOpDayCounter1/1000.0));
stVFDInfo.stDayCounter.nDays:=nOpDayCounter1 MOD 1000;
stVFDInfo.stDayCounterResettable.nDays:=nOpDayCounter1 MOD 1000;
stVFDInfo.stDayCounter.nHours:=LREAL_TO_UINT(FLOOR(nOpDayCounter2/100.0));
stVFDInfo.stDayCounterResettable.nHours:=LREAL_TO_UINT(FLOOR(nOpDayCounter2/100.0));
stVFDInfo.stDayCounter.nMinutes:=nOpDayCounter2 MOD 100;
stVFDInfo.stDayCounterResettable.nMinutes:=nOpDayCounter2 MOD 100;
stVFDInfo.stEnergyCounter.fEnergy:=nEnergyCounter;
stVFDInfo.stEnergyCounter.sUnits:='kWh';
stVFDInfo.stEnergyCounterResettable.fEnergy:=nEnergyCounter;
stVFDInfo.stEnergyCounterResettable.sUnits:='kWh';
stVFDInfo.bDataValid:=bDataValid;



(*	Run VFD State Machine	*)
CASE nVFDState OF
	VFD_NotReady:
		(*	We are not ready so we must have a fault *)
		IF NOT bDataValid THEN
			bError:=TRUE;
			nErrorID:=Er_DriveComm;
			bEnableDrive:=FALSE;
		ELSIF NOT(stVFDInfo.nStatusWord.0) THEN
			bError:=TRUE;
			nErrorID:=Er_DriveNotReady;
			bEnableDrive:=FALSE;
		(*	We are ready so we move on	*)
		ELSE
			bUpToSpeed:=FALSE;
			bEnableDrive:=TRUE;
			bError:=FALSE;
			nErrorID:=Er_NoError;
			nVFDState:=VFD_Ready;
		END_IF
		IF bReset AND NOT(bDriveReset) THEN
			bDriveReset:=TRUE;
		ELSIF NOT(bReset) AND bDriveReset THEN
			bDriveReset:=FALSE;
		END_IF

	VFD_Ready:
		IF bReset AND NOT(bDriveReset) THEN
			bDriveReset:=TRUE;
		ELSIF NOT(bReset) AND bDriveReset THEN
			bDriveReset:=FALSE;
		END_IF
		(*	We will go to the fault state for a Drive Fault *)
		IF NOT bDataValid  THEN
			bError:=TRUE;
			nErrorID:=Er_DriveComm;
			nVFDState:=VFD_Fault;
		ELSIF NOT(stVFDInfo.nStatusWord.0) THEN
			bError:=TRUE;
			nErrorID:=Er_DriveFaulted;
			nVFDState:=VFD_Fault;
		(*	We are ready and waiting for a run command	*)
		ELSE
			(*	Please Enable The Drive	*)
			bEnableDrive:=TRUE;
			(*	Ensure We Are Stopped	*)
			bRunStop:=FALSE;

			(*	We must first start by storing the values on the inputs. *)
			nRPMStore:=nRPM;
			nNominalRPMStore:=stVFDInfo.nMotorNominalSpeed;
			bDirectionStore:=bMotorDirection;
			fRatioStore:=fRatio;
			nOverrideStore:=nOverride;

			(*	Set Direction	*)
			bDirection:=bDirectionStore;
			(*	Set Speed	*)
			IF nNominalRPMStore>0 THEN
				nSpeed:=LREAL_TO_INT((nRPMStore*60.0*fRatioStore)/(nNominalRPMStore)*(nOverrideStore/100.0)*10);
			END_IF

			(*	We have a run request	*)
			IF fbRunTrigger.Q THEN
				bUpToSpeedTimer:=FALSE;
				nVFDRunState:=VFD_Run_AtSpeed;
				nVFDState:=VFD_Run;
			END_IF

		END_IF

	VFD_Run:
		(*	We will go to the fault state for a Drive Fault *)
		IF NOT bDataValid  THEN
			bError:=TRUE;
			nErrorID:=Er_DriveComm;
			nVFDState:=VFD_Fault;
		ELSIF NOT(stVFDInfo.nStatusWord.0) THEN
			bError:=TRUE;
			nErrorID:=Er_DriveFaulted;
			nVFDState:=VFD_Fault;
		ELSIF nRPMStore<=0 THEN
			bError:=TRUE;
			nErrorID:=Er_InvalidRPM;
			nVFDRunState:=VFD_Run_AtSpeed;
			nVFDState:=VFD_Fault;
		ELSIF fRatioStore<=0.0 THEN
			bError:=TRUE;
			nErrorID:=Er_InvalidRatio;
			nVFDRunState:=VFD_Run_AtSpeed;
			nVFDState:=VFD_Fault;
		ELSIF nOverrideStore<=0 THEN
			bError:=TRUE;
			nErrorID:=Er_InvalidOverride;
			nVFDRunState:=VFD_Run_AtSpeed;
			nVFDState:=VFD_Fault;
		ELSIF nSpeed<0 THEN
			bError:=TRUE;
			nErrorID:=Er_InvalidRPM;
			nVFDRunState:=VFD_Run_AtSpeed;
			nVFDState:=VFD_Fault;
		ELSE
			CASE nVFDRunState OF
				VFD_Run_AtSpeed:
					(*	Start the spindle	*)
					bRunStop:=TRUE;

					IF NOT(bRun) THEN
						nVFDRunState:=VFD_Run_Stop;
					ELSIF fbUpToSpeedTimer.Q AND NOT(stVFDInfo.nStatusWord.5) THEN
						bError:=TRUE;
						nErrorID:=Er_UpToSpeedTimeout;
						bUpToSpeed:=FALSE;
						nVFDState:=VFD_Fault;
					ELSIF NOT(stVFDInfo.nStatusWord.5) THEN
						bUpToSpeed:=FALSE;
					ELSIF stVFDInfo.nStatusWord.5 THEN
						(*	VFD is up to speed	*)
						bUpToSpeed:=TRUE;
						(*	Override has been requested *)
						IF NOT(nOverrideStore=nOverride)THEN
							nOverrideStore:=nOverride;
							nVFDRunState:=VFD_Run_Override;
							bUpToSpeedTimer:=FALSE;
							bUpToSpeed:=FALSE;
						END_IF
					END_IF

					(*	Monitor the up to speed signal	*)
					IF NOT(bUpToSpeedTimer) THEN
						bUpToSpeedTimer:=TRUE;
					END_IF

				VFD_Run_Override:
					nSpeed:=LREAL_TO_INT((nRPMStore*60.0*fRatioStore)/(nNominalRPMStore)*(nOverrideStore/100.0)*10);
					nVFDRunState:=VFD_Run_AtSpeed;
					bUpToSpeedTimer:=FALSE;
					bUpToSpeed:=FALSE;

				VFD_Run_Stop:
					bUpToSpeed:=FALSE;
					bUpToSpeedTimer:=FALSE;
					bRunStop:=FALSE;
					nVFDRunState:=VFD_Run_AtSpeed;
					nVFDState:=VFD_Ready;
	
			END_CASE
		END_IF

	VFD_Fault:
		bRunStop:=FALSE;
		bEnableDrive:=FALSE;
		IF bReset AND NOT(bDriveReset) THEN
			bDriveReset:=TRUE;
		ELSIF bReset AND bDriveReset THEN
			bDriveReset:=FALSE;
			bError:=FALSE;
			nErrorID:=Er_NoError;
			nVFDRunState:=VFD_Run_AtSpeed;
			nVFDState:=VFD_NotReady;
		END_IF

END_CASE




(*	5.06, 5.07, 5.08, 5.09	*)
fbReadData0(
	sNetId:=sNetId ,
	nSlaveAddr:=nSlaveAddr ,
	nSubIndex:=16#6 ,
	nIndex:=16#2005 ,
	pDstBuf:=ADR(arrReadData[0]) ,
	cbBufLen:=16#8 ,
	bExecute:=bReadData0 ,
	tTimeout:=DEFAULT_ADS_TIMEOUT ,
	bBusy=> ,
	bError=> ,
	nErrId=>
);
fbReadData1(
	sNetId:=sNetId ,
	nSlaveAddr:=nSlaveAddr ,
	nSubIndex:=16#7 ,
	nIndex:=16#2005 ,
	pDstBuf:=ADR(arrReadData[1]) ,
	cbBufLen:=16#8 ,
	bExecute:=bReadData1 ,
	tTimeout:=DEFAULT_ADS_TIMEOUT ,
	bBusy=> ,
	bError=> , 
	nErrId=>
);
fbReadData2(
	sNetId:=sNetId ,
	nSlaveAddr:=nSlaveAddr ,
	nSubIndex:=16#8 ,
	nIndex:=16#2005 ,
	pDstBuf:=ADR(arrReadData[2]) ,
	cbBufLen:=16#8 ,
	bExecute:=bReadData2 ,
	tTimeout:=DEFAULT_ADS_TIMEOUT ,
	bBusy=> ,
	bError=> , 
	nErrId=>
);
fbReadData3(
	sNetId:=sNetId ,
	nSlaveAddr:=nSlaveAddr ,
	nSubIndex:=16#9 ,
	nIndex:=16#2005 ,
	pDstBuf:=ADR(arrReadData[3]) ,
	cbBufLen:=16#8 ,
	bExecute:=bReadData3 ,
	tTimeout:=DEFAULT_ADS_TIMEOUT ,
	bBusy=> ,
	bError=> , 
	nErrId=>
);

(*	2.11	*)
fbReadData4(
	sNetId:=sNetId,
	nSlaveAddr:= nSlaveAddr ,
	nSubIndex:=16#0B ,
	nIndex:=16#2002 ,
	pDstBuf:=ADR(arrReadData[4]) ,
	cbBufLen:=16#2 ,
	bExecute:= bReadData4 ,
	tTimeout:=DEFAULT_ADS_TIMEOUT ,
	bBusy=> ,
	bError=> ,
	nErrId=>
);
(*	2.21	*)
fbReadData5(
	sNetId:=sNetId,
	nSlaveAddr:= nSlaveAddr ,
	nSubIndex:=16#15 ,
	nIndex:=16#2002 ,
	pDstBuf:=ADR(arrReadData[5]) ,
	cbBufLen:=16#2 ,
	bExecute:= bReadData5 ,
	tTimeout:=DEFAULT_ADS_TIMEOUT ,
	bBusy=> ,
	bError=> ,
	nErrId=>
);
(*	10 Second Timer	*)
fbReadTimer(
	IN:= bReadTimer ,
	PT:= t#10s ,
	Q=> ,
	ET=>
);
(*	Run Trigger	*)
fbRunTrigger(
	CLK:=bRun ,
	Q=>
);
(*	Up To Speed Timer	*)
fbUpToSpeedTimer(
	IN:=bUpToSpeedTimer ,
	PT:= LREAL_TO_TIME(stVFDInfo.fAccelerationTime*1000.0+2000.0) ,
	Q=> ,
	ET=>
);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Function Blocks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FixtureControl
VAR_INPUT
	bEnable: BOOL;
	(* Command Inputs *)
	(***AUTOMATIC***)
	bClampParts: BOOL;			(* PRIORITY 1 *)
	bUnclampParts: BOOL;			(* PRIORITY 2 *)
	(***MANUAL***)
	bManAdvanceTailstock: BOOL;		(* PRIORITY 4 *)
	bManRetractTailstock: BOOL;		(* PRIORITY 5 *)
	bManAdvanceCollet: BOOL;		(* PRIORITY 6 *)
	bManRetractCollet: BOOL;			(* PRIORITY 7 *)
	bManAdvanceEjectors: BOOL;		(* PRIORITY 8 *)
	bManRetractEjectors: BOOL;		(* PRIORITY 9 *)

	(* Feedback Inputs *)
	bColletClamped: BOOL;		(* PS *)
	bColletUnclamped: BOOL;		(* PS *)
	nEjectorAdvanced: USINT;
	nEjectorRetracted: USINT;
	(* COMM Inputs *)
	bTransferAtClampPosition : BOOL;
	(* OTHER INPUTS *)
	fTailstockBackPosition: LREAL;
	fTailstockFrontPosition: LREAL;
	fTailstockAxisBackOffAmount: LREAL;
	fTailstockAxisVelocity: LREAL;			(* Speed for all moves but swallowing part *)
	fTailstockAxisVelocityClamp: LREAL;		(* Speed for move to swallow part *)
	nClampingMaxTorqueLimit: UDINT;		(* Max set value for the torque limit while moving to
 Position - Swallowing Part *)
	nMaxFastTorqueLimit: UDINT;			(* Max set value for the torque limit while moving all other moves *)
	nTorqueFeedback : INT ;
	bTransferAxisHome : BOOL;			(* Transfer Axis is homed *)
END_VAR
VAR_OUTPUT
	nCurrentAction: USINT := 0;
	(* Command Outputs *)
	bColletClamp: BOOL;
	bColletUnclamp: BOOL;
	bEjectorAdvance: BOOL;
	bEjectorRetract: BOOL;
	(* COMM Outputs *)
	bClamped: BOOL;
	bUnclamped: BOOL;
	nTorqueLimit: INT := 1000;			(* %, 0 - 1000 *)
	bError: BOOL;
	nErrorID: UDINT;
	(* We do not clear this string so we can see what the last error was through TwinCAT *)
	sErrorText: STRING := '';			(* Text string to be displayed for current error - Fault # Put in by program *)
	nVeloMoveErrorID: UDINT := 0;
END_VAR
VAR_IN_OUT
	stTailstockAxis: AXIS_REF;
END_VAR
VAR
	fTailstockLoadPositionOne: LREAL;		(* Delete This Position *)
	fbTailstockAxisPower: MC_Power;
	fbTailstockAxisHome: MC_Home;
	fbTailstockAxisMoveTo: MC_MoveAbsolute;
	fbTailstockAxisMoveVelo: MC_MoveVelocity;
	fbTailstockAxisStop: MC_Stop;
	bTailstockAxisPower: BOOL := FALSE;
	bTailstockAxisHome: BOOL := FALSE;
	bTailstockAxisMove: BOOL := FALSE;
	bTailstockAxisMoveVelo: BOOL := FALSE;
	fTailstockMoveVelo: LREAL := 10.0;
	fTailstockAxisPosition: LREAL := 0.0;
	bTailstockAxisSetZero: BOOL := FALSE;
	bTailstockAxisStop: BOOL := FALSE;

	nTorqueLimitRequest: INT;				(* % , 0 - 1000 *)(* Will need to be an input if start using *)

	nClampingState: USINT := 0;
	nUnclampingState: USINT := 0;

	fbColletClampTimeout: TON;
	fbClampOffTON: TON;						(* Timer to make sure the solenoid is de-energized *)
	fbColletUnclampTimeout: TON;
	fbUnclampOffTON: TON;					(* Timer to make sure the solenoid is de-energized *)
	fbEjectorAdvanceTimeout: TON;
	fbEjectAdvOffTON: TON;					(* Timer to make sure the solenoid is de-energized *)
	fbEjectorRetractTimeout: TON;
	fbEjectRetOffTON: TON;					(* Timer to make sure the solenoid is de-energized *)

	fbClampPartsRTRIG: R_TRIG;
	fbUnclampPartsRTRIG: R_TRIG;
	fbHomeTailstockAxisRTRIG: R_TRIG;
	fbAdvanceTailstockRTRIG: R_TRIG;
	fbRetractTailstockRTRIG: R_TRIG;
	fbAdvanceColletRTRIG: R_TRIG;
	fbRetractColletRTRIG: R_TRIG;
	fbAdvanceEjectorsRTRIG: R_TRIG;
	fbRetractEjectorsRTRIG: R_TRIG;
	fbColletClampTON: TON;
	fbEjectorAdvanceTON: TON;
	fbEjectorAdvanceT5TON: TON; (*Gives a Delay after last ejector comes off retracted prox., No hard sensor for this*)
	fbEjectorRetractTON: TON;
	fbColletUnclampTON: TON;
	bEjectorAdvanceTON: BOOL := FALSE;
	fbTorqueLimitTON: TON;
	bTorqueLimitTimeout: BOOL := FALSE;
	bColletClampTON: BOOL := FALSE;
	bEjectorRetractTON: BOOL := FALSE;
	bColletUnclampTON: BOOL := FALSE;
	fTailstockAxisVelocityLocal: LREAL;

	fbTogglePositionLagMonitoring: MC_WriteBoolParameter;
	fbPositionLagMonitingStatus : MC_ReadBoolParameter;
	bTogglePositionLagMonitoring: BOOL := FALSE;
	bPositionLagMonitoiring : BOOL;
	nTestCount: INT := 0;		(*Test Counter*)
END_VAR
(* @END_DECLARATION := '0' *)
CASE nCurrentAction OF
0:	(* Initial State *)
		bTailstockAxisStop:=FALSE;
		(* We need to reset the Torque Limit to 100% if we E-Stop or Fault to be ready for the next move *)
		nTorqueLimit := 1000;
	IF bEnable THEN
		nCurrentAction:=nCurrentAction+1;
	END_IF

1:(* A STEP TO CHECK FEED BACK DEVICES TO FIRE SOLENOIDS *)
	IF bColletClamped AND NOT(bColletUnclamped) THEN
		bColletUnclamp:=FALSE;
		bColletClamp:=TRUE;
	END_IF
	IF bColletUnclamped AND NOT(bColletClamped) THEN
		bColletUnclamp:=TRUE;
		bColletClamp:=FALSE;
	END_IF
	IF nEjectorAdvanced=7 AND NOT(nEjectorRetracted>0) THEN
		bEjectorAdvance:=TRUE;
		bEjectorRetract:=FALSE;
	END_IF
	IF nEjectorRetracted=7 AND nEjectorAdvanced=7 THEN
		bEjectorRetract:=TRUE;
		bEjectorAdvance:=FALSE;
	END_IF
	nCurrentAction:=nCurrentAction+1;

2: (* Alwasys return to this step to Wait for the next command *)
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bTailstockAxisMoveVelo:=FALSE;
		bTailstockAxisStop:=TRUE;
		nCurrentAction:=0;
	ELSIF fbClampPartsRTRIG.Q THEN
		nCurrentAction:=3;
	ELSIF fbUnclampPartsRTRIG.Q THEN
		nCurrentAction:=4;
	ELSIF fbAdvanceTailstockRTRIG.Q THEN
		nCurrentAction:=6;
	ELSIF fbRetractTailstockRTRIG.Q THEN
		nCurrentAction:=7;
	ELSIF fbAdvanceColletRTRIG.Q THEN
		nCurrentAction:=8;
	ELSIF fbRetractColletRTRIG.Q THEN
		nCurrentAction:=9;
	ELSIF fbAdvanceEjectorsRTRIG.Q THEN
		nCurrentAction:=10;
	ELSIF fbRetractEjectorsRTRIG.Q THEN
		nCurrentAction:=11;
	END_IF

3:
	(* 	Clamp State Machine 														*)
	(*		Init: TS back, collets unclamped, ejectors Retracted, Unclamped				*)
	(*		T0: Clamp Requested													*)
	(*		S1: a) Advance Tailstock to Forward Position 				 				*)
	(*			b) When collett significantly swallows part Advance Ejectors. Start Timer	*)
	(*		T1: Tailstock @ Forward Position										*)
	(*		S2: Verify  Ejectors Status of Advanced Proxes and Time Delay completed		*)
	(*		T2: Ejectors Advanced Confirmation 										*)
	(*		S3: Clamp Collet 														*)
	(*		T3: All Report Clamped PS 												*)
	(*		S4: Turn Off Postion Lag Monitoring and Set Torque Limit Value				*)
	(*		T4: Confirm Donef														*)
	(*		S5: Issue Move Velocity (in proper direction)								*)
	(*		T5: Verify Torque Value												*)
	(*		S6: REPORT CLAMPED 												*)
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bTailstockAxisMoveVelo:=FALSE;
		bEjectorAdvanceTON:=FALSE;
		bColletClampTON:= FALSE;
		bEjectorRetractTON:= FALSE;
		bColletUnclampTON:= FALSE;
		bTailstockAxisStop:=TRUE;
		nCurrentAction:=0;
		nClampingState:=0;
	END_IF
	IF NOT(bClampParts) THEN
		(* WE ONLY GET HERE IF THERE IS AN EXTERNAL FAULT *)
		(* Stop ALL Possible Movement *)
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvanceTON:=FALSE;
		bColletClampTON:= FALSE;
		bEjectorRetractTON:= FALSE;
		bColletUnclampTON:= FALSE;
		(* Stop Axis *)
		IF NOT(bTailstockAxisStop) THEN
			bTailstockAxisMove:=FALSE;
			bTailstockAxisMoveVelo:=FALSE;
			bTailstockAxisSetZero:=FALSE;
			bTailstockAxisStop:=TRUE;
		ELSIF bTailstockAxisStop AND fbTailstockAxisStop.Error THEN
			bTailstockAxisStop:=FALSE;
			(* EXIT *)
			nCurrentAction:=2;
			nClampingState:=0;
		ELSIF bTailstockAxisStop AND fbTailstockAxisStop.Done THEN
			bTailstockAxisStop:=FALSE;
			(* EXIT *)
			nCurrentAction:=2;
			nClampingState:=0;
		END_IF
	ELSE
		CASE nClampingState OF
		0:	(* Init: TS back, Parts Ready to Clamp, collets unclamped, Ejectors Retracted, Unclamped *)
			IF bClamped THEN
				nCurrentAction:=2;
			ELSIF stTailstockAxis.NcToPlc.ActPos < fTailstockBackPosition - 0.1 THEN
				nErrorID:=12;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF NOT(bColletUnclamped) THEN
				nErrorID:=13;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF NOT(stTailstockAxis.Status.Homed) THEN
				nErrorID:=1;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF NOT bTransferAtClampPosition THEN
				nErrorID:=14;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF NOT(nEjectorRetracted=7) THEN
				nErrorID:=15;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			(* Begin Clamping *)
			ELSE
			(* T0: Clamp Requested *)
				(* When we are behind the transfer position we move fast to the transfer position *)
				IF (stTailstockAxis.NcToPlc.ActPos > fTailstockFrontPosition + 0.5) THEN
					nClampingState:=7;
				(* When we are at the transfer position we move at the slow speed to swallow the parts *)
				ELSE
					nClampingState:=nClampingState+1;
				END_IF
			END_IF

		1:	(* S1: a) Advance Tailstock to Forward Position
				b) When collett significantly swallows part Advance Ejectors. Start Timer *)
			IF bTailstockAxisMove AND fbTailstockAxisMoveTo.Error THEN
				bTailstockAxisMove:=FALSE;
				bTailstockAxisStop:=TRUE;
				(* Error *)
				nErrorID:=3;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			(* When the Torque exceeds Max set value exit and fault *)
			ELSIF nTorqueFeedback>nClampingMaxTorqueLimit*10 THEN
				bTailstockAxisMove:=FALSE;
				bTailstockAxisStop:=TRUE;
				bError:=TRUE;
				nErrorID:=2;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Done AND fbEjectorAdvanceTon.Q THEN
			(* T1: Tailstock @ Position *)
				bTailstockAxisMove:=FALSE;
				nClampingState:=nClampingState+1;
			ELSIF (stTailstockAxis.NcToPlc.ActPos < fTailstockFrontPosition + 8.0) THEN
			 (* S1:b) Advanced Ejectors when significantly swallowed part *)
				bEjectorAdvance:=TRUE;
			ELSE
				fTailstockAxisPosition:=fTailstockFrontPosition;
				fTailstockAxisVelocityLocal:=fTailstockAxisVelocityClamp;
				bTailstockAxisMove:=TRUE;
				(* Turn off the Retract output so the coil field can collapse before we fire other solenoid valve *)
				bEjectorRetract := FALSE;
			END_IF

		2:	(* S2: Verify  Ejectors Status of Advanced Proxes *)
			(* Fault if one of the ejectors overtraveled *)
			IF nEjectorAdvanced<7 AND nEjectorRetracted=0 AND bEjectorAdvance THEN
				(* Error *)
				nErrorID:=5;
				bError:=TRUE;
				nCurrentAction:=255;
				nClampingState:=0;
				bEjectorAdvance:=FALSE;
				bEjectorAdvanceTON:=FALSE;
			(* Basically this step gives the Ejectors a 1/2 second time delay to operate *)
			ELSIF nEjectorAdvanced=7 AND nEjectorRetracted=0 AND bEjectorAdvance  THEN
			(* T2: Ejectors Advanced *)
				nClampingState:=nClampingState+1;
			END_IF

		3:	(* S3: Clamp Collet *)
			IF bColletClamp AND fbColletClampTON.Q THEN
				(* Error *)
				nErrorID:=6;
				bError:=TRUE;
				nCurrentAction:=255;
				nClampingState:=0;
				bColletClamp:=FALSE;
				bColletClampTON:=FALSE;
			(* We look for Ejector Advanced Error in this step in case one of the Ejectors was slow *)
			ELSIF nEjectorAdvanced<7 AND nEjectorRetracted=0 AND bEjectorAdvance THEN
				(* Error *)
				nErrorID:=5;
				bError:=TRUE;
				nCurrentAction:=255;
				nClampingState:=0;
				bEjectorAdvance:=FALSE;
			ELSIF bColletClamped AND bColletClamp THEN
			(* T3: All Report Clamped *)
				bColletClampTON:=FALSE;
				nClampingState:=6;
			ELSE
				bColletUnclamp:=FALSE;
				bColletClampTON:=TRUE;
				(* Allow Solenoid to De-energize before firing Oposing Solenoid *)
				IF fbUnclampOffTON.Q THEN
					bColletClamp:=TRUE;
				END_IF
			END_IF

		(* We were unable to accomplish Torque limited move because the Ejectors overcame the Collet clamping force *)
		4:	(*S4: Turn Off Postion Lag Monitoring AND Set Torque LIMIT Value *)
			nTorqueLimit := nTorqueLimitRequest;
			IF bTogglePositionLagMonitoring AND fbTogglePositionLagMonitoring.Error THEN
				(* Error *)
				nErrorID:=20;
				bError:=TRUE;
				nCurrentAction:=255;
				nClampingState:=0;
				bTogglePositionLagMonitoring:=FALSE;
			ELSIF bTogglePositionLagMonitoring AND fbTogglePositionLagMonitoring.Done  THEN
			(* T4: Done *)
				bTogglePositionLagMonitoring:=FALSE;
				nClampingState:=nClampingState+1;
			ELSE
				bTogglePositionLagMonitoring := TRUE;
				bPositionLagMonitoiring := FALSE;
			END_IF

		5:	(* S5: Issue Move Velocity (in proper direction) *)
			IF bTailstockAxisMoveVelo AND fbTailstockAxisMoveVelo.Error
			THEN
				nVeloMoveErrorID:=fbTailstockAxisMoveVelo.ErrorID;
				bTailstockAxisMoveVelo :=FALSE;
				bTorqueLimitTimeout:=FALSE;
				bTailstockAxisStop := TRUE;
				(* Error *)
				nErrorID:=19;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF bTailstockAxisMoveVelo AND fbTorqueLimitTON.Q
			THEN
				bTailstockAxisMoveVelo :=FALSE;
				bTorqueLimitTimeout:=FALSE;
				bTailstockAxisStop := TRUE;
				(* Error *)
				nErrorID:=18;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF bTailstockAxisMoveVelo AND
				(stTailstockAxis.NcToPlc.ActPos < (fTailstockFrontPosition -0.10))
			THEN
				bTailstockAxisMoveVelo :=FALSE;
				bTorqueLimitTimeout:=FALSE;
				bTailstockAxisStop := TRUE;
				(* Error *)
				nErrorID:=17;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF bTailstockAxisMoveVelo AND (nTorqueFeedback > ( nTorqueLimitRequest - 2 )) THEN
			(* T7: In Velocity Command *)
				bTorqueLimitTimeout:=FALSE;
				bTailstockAxisMoveVelo := FALSE;
				nClampingState:=nClampingState+1;
			ELSE
				fTailstockAxisPosition:=fTailstockFrontPosition+fTailstockAxisBackOffAmount;
				fTailstockMoveVelo:=fTailstockAxisVelocity;
				bTailstockAxisMoveVelo:=TRUE;
				bTorqueLimitTimeout := TRUE;
			END_IF

		6:	(* S6: REPORT CLAMPED *)
			nClampingState:=0;
			nCurrentAction:=2;

		7:	(* Advance to Transfer position *)
			IF bTailstockAxisMove AND fbTailstockAxisMoveTo.Error THEN
				bTailstockAxisMove:=FALSE;
				bTailstockAxisStop:=TRUE;
				(* Error *)
				nErrorID:=3;
				bError:=TRUE;
				nClampingState:=0;
				nCurrentAction:=255;
			(* When the Torque exceeds Max set value exit and fault *)
			ELSIF nTorqueFeedback>nMaxFastTorqueLimit*10 THEN
				bTailstockAxisMove:=FALSE;
				bTailstockAxisStop:=TRUE;
				bError:=TRUE;
				nErrorID:=2;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Done THEN
			(* T1: Tailstock @ Transfer Position *)
				bTailstockAxisMove:=FALSE;
				nClampingState:=1;
			ELSE
				fTailstockAxisPosition:=fTailstockBackPosition;
				fTailstockAxisVelocityLocal:=fTailstockAxisVelocity;
				bTailstockAxisMove:=TRUE;
			END_IF

		END_CASE
	END_IF

4:
	(*	Unclamp State Machine													*)
	(*		Init: All report clamped and reporting clamped								*)
	(*		T0: Unclamp Requested												*)
	(*		S1: Stop Axis															*)
	(*		T1: Done bit															*)
	(*		S2: Set Torque Back to 100%											*)
	(*		S3: Retract Tailstock Offset Amount and Retract Ejectors 						*)
	(*		T3: Tailstock @ Offset 													*)
	(*		S4: Unclamp Collets													*)
	(*		T4: Collets Unclamp PS												*)
	(*		S5: Move Tailstock to back position										*)
	(*		T5: Tailstock @ back 													*)
	(*		S6: REPORT UNCLAMPED												*)

	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bEjectorAdvanceTON:=FALSE;
		bColletClampTON:= FALSE;
		bEjectorRetractTON:= FALSE;
		bColletUnclampTON:= FALSE;
		bTailstockAxisStop:=TRUE;
		nCurrentAction:=0;
		nUnclampingState:=0;
	END_IF
	IF NOT(bUnclampParts) THEN
		(* WE ONLY GET HERE IF THERE IS AN EXTERNAL FAULT *)
		(* Stop ALL Possible Movement *)
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvanceTON:=FALSE;
		bColletClampTON:= FALSE;
		bEjectorRetractTON:= FALSE;
		bColletUnclampTON:= FALSE;
		(* Stop Axis *)
		IF NOT(bTailstockAxisStop) THEN
			bTailstockAxisHome:=FALSE;
			bTailstockAxisMove:=FALSE;
			bTailstockAxisSetZero:=FALSE;
			bTailstockAxisStop:=TRUE;
		ELSIF bTailstockAxisStop AND fbTailstockAxisStop.Error THEN
			bTailstockAxisStop:=FALSE;
			(* EXIT *)
			nCurrentAction:=2;
			nUnclampingState:=0;
		ELSIF bTailstockAxisStop AND fbTailstockAxisStop.Done THEN
			bTailstockAxisStop:=FALSE;
			(* EXIT *)
			nCurrentAction:=2;
			nUnclampingState:=0;
		END_IF
	ELSE
		CASE nUnclampingState OF
		0:	(* Init: All report clamped and reporting clamped *)
			nTorqueLimit := 1000;
			IF NOT(stTailstockAxis.Status.Homed) THEN
				(* Error *)
				nErrorID:=1;
				bError:=TRUE;
				nUnclampingState:=0;
				nCurrentAction:=255;
			(* Nothing To Do Here *)
			ELSIF bUnclamped THEN
				nCurrentAction:=2;
			(* Begin Unclamping *)
			ELSE
			(* T0: Unclamp Requested *)
				nUnclampingState:=nUnclampingState+1;
			END_IF

		1: (* S1: Stop Axis *)
			IF bTailstockAxisStop AND fbTailstockAxisStop.Error THEN
				(* Error *)
				nErrorID:=7;
				bError:=TRUE;
				nUnclampingState:=0;
				nCurrentAction:=255;
				bTailstockAxisStop:=FALSE;
			ELSIF bTailstockAxisStop AND fbTailstockAxisStop.Done THEN
				bTailstockAxisStop:=FALSE;
				nUnclampingState:=nUnclampingState+1;
			ELSE
				bTailstockAxisStop:=TRUE;
			END_IF

		2: 	(* S2: Set Torque Back to 100% *)
			nTorqueLimit := 1000;
			nUnclampingState:=nUnclampingState+1;

		3:	(* S3: Retract Tailstock Offset Amount and Retract Ejectors *)
			IF bTailstockAxisMove AND fbTailstockAxisMoveTo.Error THEN
				bTailstockAxisMove:=FALSE;
				(* Error *)
				nErrorID:=9;
				bError:=TRUE;
				nUnclampingState:=0;
				nCurrentAction:=255;
			(* When the Torque exceeds Max set value exit and fault *)
			ELSIF nTorqueFeedback>nMaxFastTorqueLimit*10 THEN
				bTailstockAxisMove:=FALSE;
				bTailstockAxisStop:=TRUE;
				bError:=TRUE;
				nErrorID:=2;
				nUnclampingState:=0;
				nCurrentAction:=255;
			ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Done THEN
			(* T3: Tailstock Position Two *)
				bTailstockAxisMove:=FALSE;
				nUnclampingState:=nUnclampingState+1;
			ELSE
				fTailstockAxisPosition := fTailstockFrontPosition +fTailstockAxisBackOffAmount ;
				fTailstockAxisVelocityLocal:=fTailstockAxisVelocity;
				bTailstockAxisMove:=TRUE;
				bEjectorAdvance:=FALSE;
				IF fbEjectAdvOffTON.Q THEN
					bEjectorRetract:=TRUE;
				END_IF
			END_IF

		4:	(* S4: Unclamp Collets *)
			IF bColletUnclamp AND fbColletUnclampTON.Q THEN
				(* Error *)
				nErrorID:=8;
				bError:=TRUE;
				nUnclampingState:=0;
				nCurrentAction:=255;
				bColletUnclamp:=FALSE;
				bColletUnclampTON:=FALSE;
			ELSIF bColletUnclamped AND bColletUnclamp THEN
			(* T4: Collets report unclamped by PS *)
				bColletUnclampTON:=FALSE;
				nUnclampingState:=nUnclampingState+1;
			ELSE
				bColletClamp:=FALSE;
				bColletUnclampTON:=TRUE;
				IF fbClampOffTON.Q THEN
					bColletUnclamp:=TRUE;
				END_IF
			END_IF

		5: 	(* S5: Move Tailstock to back position *)
			IF bTailstockAxisMove AND fbTailstockAxisMoveTo.Error THEN
				bTailstockAxisMove:=FALSE;
				(* Error *)
				nErrorID:=9;
				bError:=TRUE;
				nUnclampingState:=0;
				nCurrentAction:=255;
			(* When the Torque exceeds Max set value exit and fault *)
			ELSIF nTorqueFeedback>nMaxFastTorqueLimit*10 THEN
				bTailstockAxisMove:=FALSE;
				bTailstockAxisStop:=TRUE;
				bError:=TRUE;
				nErrorID:=2;
				nClampingState:=0;
				nCurrentAction:=255;
			ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Done THEN
			(* T5: Tailstock @ Back Position *)
				bTailstockAxisMove:=FALSE;
				nUnclampingState:=0;
				nCurrentAction:=2;
		(*		nUnclampingState:=nUnclampingState+1;			*)
			ELSE
				fTailstockAxisPosition:=fTailstockBackPosition;
				fTailstockAxisVelocityLocal:=fTailstockAxisVelocity;
				bTailstockAxisMove:=TRUE;
			END_IF

		6:	(* S7: Report Unclamped *)
			nUnclampingState:=0;
			nCurrentAction:=2;

		END_CASE
	END_IF

6: (* Manual Advance Tailstock Axis *)
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bError:=TRUE;
		nErrorID:=0;
		nCurrentAction:=255;
	(* Transfer Axis must be home *)
	ELSIF NOT bTransferAxisHome THEN
		bError:=TRUE;
		nErrorID:=22;
		nCurrentAction:=255;
	(* Transfer Axis must be at load or unload positiion *)
	ELSIF NOT bTransferAtClampPosition THEN
		bError:=TRUE;
		nErrorID:=14;
		nCurrentAction:=255;
	(* Missing parameters for move *)
	ELSIF fTailstockBackPosition=0.0 OR fTailstockFrontPosition=0.0 THEN
		bError:=TRUE;
		nErrorID:=21;
		nCurrentAction:=255;
	(* When the Torque exceeds Max set value exit and fault *)
	(* Moving to Transfer Postion - Fast Move *)
	ELSIF ( stTailstockAxis.NcToPlc.ActPos > fTailstockBackPosition AND
		nTorqueFeedback>nMaxFastTorqueLimit*10)
	THEN
		bTailstockAxisMove:=FALSE;
		bTailstockAxisStop:=TRUE;
		bError:=TRUE;
		nErrorID:=2;
		nCurrentAction:=255;
	(* Moving to Drill Postion - Slow Move *)
	ELSIF ( stTailstockAxis.NcToPlc.ActPos > fTailstockFrontPosition) AND
	 	(stTailstockAxis.NcToPlc.ActPos < fTailstockBackPosition) AND
		(nTorqueFeedback>nClampingMaxTorqueLimit*10)
	THEN
		bTailstockAxisMove:=FALSE;
		bTailstockAxisStop:=TRUE;
		bError:=TRUE;
		nErrorID:=2;
		nCurrentAction:=255;
	(* Fault if the Cullets are not Unclamped *)
	ELSIF NOT bColletUnclamped THEN
		bError:=TRUE;
		nErrorID:=13;
		nCurrentAction:=255;
	(* We should be Good to Make the Move *)
	ELSE
		(* If we are behind the Back position we advance to the Back position *)
		IF NOT(bTailstockAxisMove) AND stTailstockAxis.NcToPlc.ActPos > fTailstockBackPosition+0.5 THEN
			bTailstockAxisMove:=TRUE;
			fTailstockAxisVelocityLocal:=fTailstockAxisVelocity;
			fTailstockAxisPosition:=fTailstockBackPosition;
		(* Else If we are behind the forward position we advance to the forward position *)
		ELSIF NOT(bTailstockAxisMove) AND stTailstockAxis.NcToPlc.ActPos > fTailstockFrontPosition+0.1 THEN
			bTailstockAxisMove:=TRUE;
			fTailstockAxisVelocityLocal:=fTailstockAxisVelocityClamp;
			fTailstockAxisPosition:=fTailstockFrontPosition;
		(* If We are already at the forward position, then Exit out of this step *)
		ELSIF stTailstockAxis.NcToPlc.ActPos <= fTailstockFrontPosition+0.1 THEN
			bTailstockAxisMove:=FALSE;
			nCurrentAction:=2;
		(* Did we have a problem? *)
		ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Error THEN
			bTailstockAxisMove:=FALSE;
			bError:=TRUE;
			nErrorID:=11;
			nCurrentAction:=255;
		(* Are we there yet? *)
		ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Done THEN
			bTailstockAxisMove:=FALSE;
			nCurrentAction:=2;
		END_IF (* Move *)
	END_IF (* Fault Checks *)

7: (* Retract Tailstock Axis *)
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bError:=TRUE;
		nErrorID:=0;
		nCurrentAction:=255;
	(* Transfer Axis must be home *)
	ELSIF NOT bTransferAxisHome THEN
		bError:=TRUE;
		nErrorID:=22;
		nCurrentAction:=255;
	(* Transfer Axis must be at load or unload positiion *)
	ELSIF NOT bTransferAtClampPosition THEN
		bError:=TRUE;
		nErrorID:=14;
		nCurrentAction:=255;
	(* Missing parameters for move *)
	ELSIF fTailstockBackPosition=0.0 THEN
		bError:=TRUE;
		nErrorID:=21;
		nCurrentAction:=255;
	(* When the Torque exceeds Max set value exit and fault *)
	ELSIF nTorqueFeedback>nMaxFastTorqueLimit*10 THEN
		bTailstockAxisMove:=FALSE;
		bTailstockAxisStop:=TRUE;
		bError:=TRUE;
		nErrorID:=2;
		nCurrentAction:=255;
	(* Fault if the Cullets are not Unclamped *)
	ELSIF NOT bColletUnclamped THEN
		bError:=TRUE;
		nErrorID:=13;
		nCurrentAction:=255;
	(* We should be Good to Make the Move *)
	ELSE
		(* If we are in front of  the back position we retract to the back position *)
		IF NOT(bTailstockAxisMove) AND NOT(bColletClamped)
		AND  stTailstockAxis.NcToPlc.ActPos < fTailstockBackPosition-0.1 THEN
			bTailstockAxisMove:=TRUE;
			fTailstockAxisVelocityLocal:=fTailstockAxisVelocity;
			fTailstockAxisPosition:=fTailstockBackPosition;
		(* If We are already at the back position, then Exit out of this step *)
		ELSIF stTailstockAxis.NcToPlc.ActPos >= fTailstockBackPosition-0.1 THEN
			bTailstockAxisMove:=FALSE;
			nCurrentAction:=2;
		(* Did we have a problem? *)
		ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Error THEN
			bTailstockAxisMove:=FALSE;
			bError:=TRUE;
			nErrorID:=11;
			nCurrentAction:=255;
		(* Can not be Clamped and Move Back *)
		ELSIF bColletClamped THEN
			bTailstockAxisMove:=FALSE;
			bError:=TRUE;
			nErrorID:=16;
			nCurrentAction:=255;
		(* Are we there yet? *)
		ELSIF bTailstockAxisMove AND fbTailstockAxisMoveTo.Done THEN
			bTailstockAxisMove:=FALSE;
			nCurrentAction:=2;
		END_IF (* Move *)
	END_IF (* Fault Checking *)

8: (* Clamp Collet *)
	bColletUnclamp:=FALSE;
	IF fbUnclampOffTON.Q THEN
		bColletClamp:=TRUE;
	END_IF
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bError:=TRUE;
		nErrorID:=0;
		nCurrentAction:=255;
	ELSIF bColletClamped AND NOT(bColletUnclamped) THEN
		nCurrentAction:=2;
	ELSIF fbColletClampTimeout.Q THEN
	(* TIMEOUT *)
		bError:=TRUE;
		nErrorID:=6;
		nCurrentAction:=255;
		bColletClamp:=FALSE;
	END_IF

9: (* Open Collet *)
	bColletClamp:=FALSE;
	IF fbClampOffTON.Q THEN
		bColletUnclamp:=TRUE;
	END_IF
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bError:=TRUE;
		nErrorID:=0;
		nCurrentAction:=255;
	ELSIF bColletUnclamped AND NOT(bColletClamped) THEN
		nCurrentAction:=2;
	ELSIF fbColletUnclampTimeout.Q THEN
	(* TIMEOUT *)
		bError:=TRUE;
		nErrorID:=8;
		nCurrentAction:=255;
		bColletUnclamp:=FALSE;
	END_IF

10: (* Advance Ejectors *)
	bEjectorRetract:=FALSE;
	IF fbEjectRetOffTON.Q THEN
		bEjectorAdvance:=TRUE;
	END_IF
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bError:=TRUE;
		nErrorID:=0;
		nCurrentAction:=255;
	ELSIF nEjectorRetracted=0 THEN
		nCurrentAction:=2;
	ELSIF fbEjectorAdvanceTimeout.Q THEN
	(* TIMEOUT *)
		bError:=TRUE;
		nErrorID:=4;
		nCurrentAction:=255;
		bEjectorAdvance:=FALSE;
	END_IF

11: (* Retract Ejectors *)
	bEjectorAdvance:=FALSE;
	IF fbEjectAdvOffTON.Q THEN
		bEjectorRetract:=TRUE;
	END_IF
	IF NOT(bEnable) THEN
		bColletClamp:=FALSE;
		bColletUnclamp:=FALSE;
		bEjectorAdvance:=FALSE;
		bEjectorRetract:=FALSE;
		bTailstockAxisMove:=FALSE;
		bError:=TRUE;
		nErrorID:=0;
		nCurrentAction:=255;
	ELSIF nEjectorRetracted=7 AND nEjectorAdvanced=7 THEN
		nCurrentAction:=2;
	ELSIF fbEjectorRetractTimeout.Q THEN
	(* TIMEOUT *)
		bError:=TRUE;
		nErrorID:=7;
		nCurrentAction:=255;
		bEjectorRetract:=FALSE;
	END_IF

255:	(* Faulted *)
	(* To Reset A Block Fault All Block Inputs Must Go To FALSE *)
	IF NOT(bClampParts OR bUnclampParts
		OR bManAdvanceTailstock OR bManRetractTailstock
		OR bManAdvanceCollet OR bManRetractCollet
		OR bManAdvanceEjectors OR bManRetractEjectors)
	THEN
		bError:=FALSE;
	(*	nErrorID:=0; *)
		bTailstockAxisStop:=FALSE;
		nCurrentAction:=0;
	END_IF

ELSE
	(* Unknown State Entered *)
	bError:=TRUE;
	nErrorID:=9999;
	(* GO TO FAULTED STATE *)
	nCurrentAction:=255;
END_CASE

(* What Defines Clamped *)
bClamped:= 		bColletClamp AND bEjectorAdvance AND bColletClamped AND nEjectorAdvanced=7 AND nEjectorRetracted=0
				AND (stTailstockAXIS.NcToPlc.ActPos >= fTailstockFrontPosition  - 0.1)
				AND (stTailstockAXIS.NcToPlc.ActPos <= fTailstockFrontPosition  + 0.1) ;

(* What Defines Unclamped *)
bUnclamped:=	bColletUnclamp AND bEjectorRetract AND bColletUnclamped AND nEjectorAdvanced=7
				AND (stTailstockAXIS.NcToPlc.ActPos >= fTailstockBackPosition  - 0.1)
				(* The Unclamp State Machine is expecting the Unclamp input signal to stay on for the whole cycle *)
				AND nUnclampingState=0;

(* When the Lag Monitoring is turned off and we issue a MC_Stop to the axis
	then we want to turn the Lag monitoring back on *)
IF bTogglePositionLagMonitoring AND fbTogglePositionLagMonitoring.Done AND
	NOT(nClampingState = 4)
THEN
	bTogglePositionLagMonitoring:= FALSE;
ELSIF NOT fbPositionLagMonitingStatus.Value AND bTailstockAxisStop THEN
	bTogglePositionLagMonitoring:=TRUE;
	bPositionLagMonitoiring := TRUE;
END_IF


fbTailstockAxisMoveTo(
	Execute:=bTailstockAxisMove ,
	Position:=fTailstockAxisPosition ,
	Velocity:=fTailstockAxisVelocityLocal ,
	Acceleration:=0 ,
	Deceleration:=0 ,
	Jerk:=0 ,
	BufferMode:= MC_Aborting,
	Axis:=stTailstockAxis );

fbTailstockAxisMoveVelo(
	Execute:= bTailstockAxisMoveVelo,
	Velocity:= fTailstockMoveVelo ,
	Acceleration:= 0,
	Deceleration:= 0,
	Jerk:= 0,
	Direction:= MC_Negative_Direction,
	BufferMode:= MC_Aborting,
	Options:= ,
	Axis:= stTailstockAxis,
	InVelocity=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );

fbTailstockAxisStop(
	Execute:=bTailstockAxisStop ,
	Deceleration:=0 ,
	Jerk:=0 ,
	Axis:=stTailstockAxis );

fbTogglePositionLagMonitoring(
	Execute:= bTogglePositionLagMonitoring ,
	ParameterNumber:= AxisEnPositionLagMonitoring,
	Value:= bPositionLagMonitoiring ,
	Axis:=stTailstockAxis );

fbPositionLagMonitingStatus(
	Enable:= TRUE,
	ParameterNumber:= AxisEnPositionLagMonitoring ,
	ReadMode:= READMODE_CYCLIC,
	Axis:= stTailstockAxis ,
	Valid=> ,
	Busy=> ,
	Error=> , 
	ErrorID=> , 
	Value=> );

fbColletClampTimeout(IN:=nCurrentAction=8 , PT:=t#5s);
fbColletUnclampTimeout(IN:=nCurrentAction=9 ,PT:=t#5s);
fbEjectorAdvanceTimeout(IN:=nCurrentAction=10 ,PT:=t#5s);
fbEjectorRetractTimeout(IN:=nCurrentAction=11 ,PT:=t#5s);
fbClampOffTON(IN:=NOT bColletClamp , PT:= t#100ms);
fbUnclampOffTON(IN:= NOT bColletUnclamp , PT:= t#100ms);

fbEjectorAdvanceTON(IN:=(nEjectorRetracted=0) , PT:=t#250ms);
fbEjectorRetractTON(IN:=bEjectorRetractTON, PT:=t#10s);
fbColletClampTON(IN:=bColletClampTON, PT:=t#10s);
fbColletUnclampTON(IN:=bColletUnclampTON, PT:=t#10s);
fbEjectRetOffTON(IN:=NOT bEjectorRetract, PT:=t#100ms);
fbEjectAdvOffTON(IN:=NOT bEjectorAdvance , PT:=t#100ms);

fbClampPartsRTRIG(CLK:=bClampParts);
fbUnclampPartsRTRIG(CLK:=bUnclampParts);
fbAdvanceTailstockRTRIG(CLK:=bManAdvanceTailstock);
fbRetractTailstockRTRIG(CLK:=bManRetractTailstock);
fbAdvanceColletRTRIG(CLK:=bManAdvanceCollet);
fbRetractColletRTRIG(CLK:=bManRetractCollet);
fbAdvanceEjectorsRTRIG(CLK:=bManAdvanceEjectors);
fbRetractEjectorsRTRIG(CLK:=bManRetractEjectors);
fbTorqueLimitTON(IN:= bTorqueLimitTimeout , PT:= t#30s , Q=> , ET=> );


(* ERROR CODES: *)

(* The bError bit will be on for one cycle when triggered and then will be reset the next scan in step 255 of the FB
So we want to translate into a text string from the error code *)
IF bError THEN
	CASE nErrorID OF
	01: sErrorText := '01 - Tailstock Axis lost Homed signal';
	02: sErrorText := '02 - Tailstock Thrust Exceeded Max';
	03: sErrorText := '03 - Tailstock Axis Move to Drill Failed';
	04: sErrorText := '04 - Ejector Advance Timeout';
	05: sErrorText := '05 - Missing Parts (Ejector Overtravel)';
	06: sErrorText := '06 - Collet Clamp PS Timeout';
	07: sErrorText := '07 - Ejector Retract Timeout';
	08: sErrorText := '08 - Collet Unclamp PS Timeout';
	09: sErrorText := '09 - Tailstock Axis Move Back Failed';
	10: sErrorText := '10 - Tailstock Axis Home Failed';
	11: sErrorText := '11 - Tailstock Axis Move Failed';
	12: sErrorText := '12 - Tailstock Axis not at XFR pos.';
	13: sErrorText := '13 - Unclamped P.S. is not made';
	14: sErrorText := '14 - Transfer not at Unload Position';
	15: sErrorText := '15 - Not all Ejectors report retracted';
	16: sErrorText := '16 - Must Unclamp to Retract Tailstock';
	17: sErrorText := '17 - Tailstock Axis Moved While Drilling';
	18: sErrorText := '18 - Tailstock Torque Limit Error';
	19: sErrorText := '19 - Tailstock Torque Move Error';
	20: sErrorText := '20 - Tailstock Toggle of Lag Monitoring Failed';
	21: sErrorText := '21 - Missing W Position Parameters';
	22: sErrorText := '22 - Transfer Axis Must be Homed';
	END_CASE
END_IF


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Function Blocks' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_MotorStarter
(*
	Author:		Brandon Snell 	Date:		01.23.2008
	Modified:		Ron Poehlmann	10-23-2014  Removed Error ID
*)
VAR_INPUT
	bStart: BOOL := FALSE;						(* 	Level Trigger to Turn On Motor Starter, Edge Triggers Timer *)
	bAuxContact: BOOL :=TRUE;					(* 	Check To Ensure Motor Starter Is On, If No Auxilary Contact
														Present This Shall Remain TRUE *)
END_VAR
VAR_OUTPUT
	bMSOn: BOOL :=FALSE;						(* 	Simply Turns On When bStart is Level HIGH, Errors Will Turn Output Off,
														bStart must be cycled because positive edge bStart Resets bError *)
	bError: BOOL :=FALSE;						(* 	Bit telling on the motor starter failure *)
END_VAR
VAR
	fbStartRTrig: R_TRIG;
	bStartTime: BOOL := FALSE;
	fbDelayTimer: TON;
	fbStartFTrig: F_TRIG;
END_VAR
(* @END_DECLARATION := '0' *)
(*
	fbStartRTrig finds the rising edge of bStart in order
	to initialize the delay timer 
*)
fbStartRTrig(CLK:=bStart , Q=> );

(*
	fbStartFTrig finds the falling edge of bStart used to
	reset the current error state of the function block 
*)
fbStartFTrig(CLK:=bStart , Q=> );

(*
	fbDelayTimer is used to allow for possible bounce
	in auxilary contact closure
*)
fbDelayTimer(IN:=bStartTime , PT:=t#1s500ms , Q=> , ET=> );

(*
	Reset Error State Returning To Initial State
*)
IF fbStartFTrig.Q THEN
	bError:=FALSE;
END_IF

(*
	Initialize Delay Timer Jumping To Run State #1
*)
IF fbStartRTrig.Q THEN
	bStartTime:=TRUE;
END_IF

(*
	Set Error For Motor Starter Jumping to Error State
	If bAuxContact does not fail to close then Jumping to Run State #2
*)
IF bStart AND NOT(bAuxContact) AND fbDelayTimer.Q THEN
	bError:=TRUE;
END_IF



(*
	Turn On Motor Starter Level HIGH bStart
*)
IF bStart AND NOT(bError) THEN
	bMSOn:=TRUE;
ELSE
	bMSOn:=FALSE;
END_IF

(*
	Prepare Timer For Edge Triggered Start
*)
IF NOT(bStart) THEN
	bStartTime:=FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION F_GetVersionDehoff : UINT
VAR_INPUT
	nVersionElement: INT := 0;
END_VAR
(*	Version history: This is for the program in the CX2020.  The HMI program version resisdes in the CP2612
Date	|	Rev	|	created under	|	Author				|	Remark		
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
09/27/14	|	1.0	|	Build 2241	|	Ron Poehlmann		|	(Shipped on Machine #1 & 2)
12/04/14	|	1.1	|	Build 2241	|	Ron Poehlmann		|	Fixed problem caused by Fault History not being completed
															Added Fault Screen with Servo Axis Diagnostics #'s
															Moved into Persistent Data: U/X Axis Position and Speed variables & Tailstock Max Thrust
															Fixed Rung 117 to say 3B instead of 3A
															(* Remotely Installed on Machine #1 & #2*)
2/09/15	|	1.2	|	Build 2241	|	Ron Poehlmann		|	Changed Drill Cycle so that the Filter Fault does not stop the cycle.
															Worked on other Problems.
															(* Remotely Installed on Machine #2 & #1 *)
2/16/15	|	1.3	|	Build 2241	|	Ron Poehlmann		|	Rewrote Transfer Cycle.
															(* Remotely Installed on Machine #1 & #2 *)
2/18/15	|	1.3b	|											Fixed Reset of Servo Drives.
															(* Remotely Installed on Machine #1 & 2 *)
3/3/15	|	1.4	|	Build 2241	|	Ron Poehlmann		|	Added Recovery of Overtravel.
															Added checks and warnings before entering Auto.
															Added Single Homeing Button for WA, WB, and X Axis
															Modified Network Variables to assure alignment.
															Added Faults to Tailstock and Transfer.
															Shortened User name Passwords and added handshake bit.
															Added Recording of the W Axis Max Thrust Values.
															Added VFD Data Valid bit and Revised FB_EtherCAT_Emerson. 
7/8/15		Field mods										Added monitoring screen to CX to be able to view machie status.
															( Remotely Installed on Machine #1 - 4 )
11/05/15	|	1.5	|	Build 2241	|	Ron Poehlmann		|	Fixed typo that caused the X Axis Velocity not to be received from Panel B
															Added Fault condition to AC_CellRunoutFinish so it would Exit Auto on a Fault condition.
															Added Fault condition to AC_Init so it would Exit Auto on a Fault condition.
															Added Feed Over-ride as a setup feature.
															Fault at end of cycle if Lube Level Low Warning on for more than 2 cycles.
															Disable MPG if clamped.
															Fixed typo in FB_FixtureControl line 444 from nClampState to nUnclampState
															Changed Max Thrust Inputs for FB_Fixture Control
1/14/16	|	1.6	|	Build 2254	|	Ron Poehlmann		|	System Manager was Changed from V1 to V1.1 because of newer Card definitions.
															When Load Side switched - Swapp Load and unload Positions.
															Fixed a problem with the Waring 110 on Transfer_Cycle so that it will retriger in Cell Runout
																made step 10 check for bCellRunoutRequest.
*)
(* @END_DECLARATION := '0' *)
CASE nVersionElement OF
	1: F_GetVersionDehoff:=1;		(* Major Number *)
	2: F_GetVersionDehoff:=6;		(* ArboMex Program Revision Number *)
ELSE
	F_GetVersionDehoff:=16#FFFF;
END_CASE
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM Build_Receive_Network_Data
VAR
	fbSideAUserNameInput: R_TRIG;			(* An User Name Input has just been received from Panel A *)
	fbSideBUserNameInput: R_TRIG;			(* An User Name Input has just been received from Panel B *)
	fbSideAPasswordInput: R_TRIG;				(* A Password Input has just been received from Panel A *)
	fbSideBPasswordInput: R_TRIG;				(* A Password Input has just been received from Panel B *)
	fbSideASavePasswordInputTrig: R_TRIG;		(* A Save Password Input has just been received from Panel A *)
	fbSideBSavePasswordInput: R_TRIG;		(* A Save Password Input has just been received from Panel B *)
	fbSideAEnableRTrig: R_TRIG;
	fbSideBEnableRTrig: R_TRIG;
	fbTestSpeedActiveRTrig: R_TRIG;			(* Push Button pressed to Activate/Deactivate the Test Speed *)
	nTest: INT := 0;		(* Test Counter*)
	fUAxisLoadPositionTempVariable: LREAL := 0.0;		(*A Temp variable used to swap the Load and unload position*)
END_VAR
(* @END_DECLARATION := '0' *)
(* Login Varialbes *)
(* If the Login PB or Logout PB is pressed on either screen, then turn on the bit*)
bLoginPB := stReceivePanelA.arrBOOL[8] OR stReceivePanelB.arrBOOL[8];
bLogoutPB := stReceivePanelA.arrBOOL[9] OR stReceivePanelB.arrBOOL[9];

(* Receive the User ID Input *)
(* Only place what is received into the Username when the received value first changes
	Also if they enter a wrong value, then we want to trigger when it changes. 
	When we see a change from '' set the handshake bit.  
		The Panel will then set the variable to '' again, so turn off the handshake bit.*)
fbSideAUserNameInput(CLK:=stReceivePanelA.arrTEXTSTRING[2] <> '');
fbSideBUserNameInput(CLK:=stReceivePanelB.arrTEXTSTRING[2] <> '');
IF fbSideAUserNameInput.Q THEN
	bUserNameHandshake:=TRUE;
	sUsername := stReceivePanelA.arrTEXTSTRING[2];
ELSIF fbSideBUserNameInput.Q THEN
	bUserNameHandshake:=TRUE;
	sUsername := stReceivePanelB.arrTEXTSTRING[2];
ELSIF (stReceivePanelA.arrTEXTSTRING[2] = '') AND (stReceivePanelB.arrTEXTSTRING[2] = '') THEN
	bUserNameHandshake:=FALSE;
END_IF

(* Receive the Password Input *)
fbSideAPasswordInput(CLK:=stReceivePanelA.arrTEXTSTRING[3] <> '');
fbSideBPasswordInput(CLK:=stReceivePanelB.arrTEXTSTRING[3] <> '');
IF fbSideAPasswordInput.Q THEN
	bPasswordHandshake:=TRUE;
	sPassword := stReceivePanelA.arrTEXTSTRING[3];
ELSIF fbSideBPasswordInput.Q THEN
	bPasswordHandshake:=TRUE;
	sPassword := stReceivePanelB.arrTEXTSTRING[3];
ELSIF (stReceivePanelA.arrTEXTSTRING[3] = '') AND (stReceivePanelB.arrTEXTSTRING[3] = '') THEN
	bPasswordHandshake:=FALSE;
END_IF

(* Receive the Save Password Input *)
fbSideASavePasswordInputTrig(CLK:=stReceivePanelA.arrTEXTSTRING[4] <> '');
fbSideBSavePasswordInput(CLK:=stReceivePanelB.arrTEXTSTRING[4] <> '');
IF (stReceivePanelA.arrTEXTSTRING[4] <> '') THEN
	IF stReceivePanelA.arrTEXTSTRING[4]=sPasswordSupervisorUC OR
		stReceivePanelA.arrTEXTSTRING[4]=sPasswordSupervisor OR
		stReceivePanelA.arrTEXTSTRING[4]=sPasswordSuperUC OR
		stReceivePanelA.arrTEXTSTRING[4]=sPasswordSuper
	THEN
		bWrongSavePassword:=FALSE;
		bSavePasswordHandshake:=TRUE;
		sSavePassword := stReceivePanelA.arrTEXTSTRING[4];
	(* Password is not correct *)
	ELSE
		bWrongSavePassword:=TRUE;
	END_IF
END_IF
IF (stReceivePanelB.arrTEXTSTRING[4] <> '') THEN
	IF stReceivePanelB.arrTEXTSTRING[4]=sPasswordSupervisorUC OR
		stReceivePanelB.arrTEXTSTRING[4]=sPasswordSupervisor OR
		stReceivePanelA.arrTEXTSTRING[4]=sPasswordSuperUC OR
		stReceivePanelA.arrTEXTSTRING[4]=sPasswordSuper
	THEN
		bWrongSavePassword:=FALSE;
		bSavePasswordHandshake:=TRUE;
		sSavePassword := stReceivePanelB.arrTEXTSTRING[4];
		(* Password is not correct *)
	ELSE
		bWrongSavePassword:=TRUE;
	END_IF
END_IF
IF (stReceivePanelA.arrTEXTSTRING[4] = '') AND (stReceivePanelB.arrTEXTSTRING[4] = '') THEN
	bSavePasswordHandshake:=FALSE;
	bWrongSavePassword:=FALSE;
END_IF


(* Call Actions *)
Auto_Screen_Receive;
Part_Program_Screen;
Transfer_Screen;
Fixture_Screen;
Secret_Screen;
Test_Speed_Screen;
Manual_Screen_Receive;


END_PROGRAM
ACTION	Auto_Screen_Receive:
(* Push Buttons *)
bEnterManualModePB := 	stReceivePanelA.arrBOOL[1] OR stReceivePanelB.arrBOOL[1];
bEnterAutoModePB := 		stReceivePanelA.arrBOOL[2] OR stReceivePanelB.arrBOOL[2];
bResetCycleCounterPB := 	stReceivePanelA.arrBOOL[3] OR stReceivePanelB.arrBOOL[3];;
bFaultResetPB := 			stReceivePanelA.arrBOOL[4] OR stReceivePanelB.arrBOOL[4];
bResetTotalCountPB := 	stReceivePanelA.arrBOOL[5] OR stReceivePanelB.arrBOOL[5];
bCellRunOutPB := 			stReceivePanelA.arrBOOL[67] OR stReceivePanelB.arrBOOL[67];
bResetA1CountPB:= 		stReceivePanelA.arrBOOL[42] OR stReceivePanelB.arrBOOL[42];
bResetA2CountPB:= 		stReceivePanelA.arrBOOL[43] OR stReceivePanelB.arrBOOL[43];
bResetA3CountPB:= 		stReceivePanelA.arrBOOL[44] OR stReceivePanelB.arrBOOL[44];
bResetB1CountPB:= 		stReceivePanelA.arrBOOL[45] OR stReceivePanelB.arrBOOL[45];
bResetB2CountPB:= 		stReceivePanelA.arrBOOL[46] OR stReceivePanelB.arrBOOL[46];
bResetB3CountPB:= 		stReceivePanelA.arrBOOL[47] OR stReceivePanelB.arrBOOL[47];
END_ACTION

ACTION	Fixture_Screen:
(* Fixture common Inputs *)
(* When a Transfer position Input is received from Panel A or B then modify *)
IF stReceivePanelA.arrLREAL[20] <> 0.0 THEN
	fWAxisTransferPosition :=stReceivePanelA.arrLREAL[20];
ELSIF stReceivePanelB.arrLREAL[20] <> 0.0 THEN
	fWAxisTransferPosition :=stReceivePanelB.arrLREAL[20];
END_IF

(* When a Drill Position Input is received from Panel A or B then modify *)
IF stReceivePanelA.arrLREAL[21] <> 0.0 THEN
	fWAxisDrillPosition :=stReceivePanelA.arrLREAL[21];
ELSIF stReceivePanelB.arrLREAL[21] <> 0.0 THEN
	fWAxisDrillPosition :=stReceivePanelB.arrLREAL[21];
END_IF

(* A Side *)
(*Push Buttons Side A *)
bWAAxisHomePB := stReceivePanelA.arrBOOL[30];
bWAAxisAdvancePB := stReceivePanelA.arrBOOL[31];
bWAAxisRetractPB := stReceivePanelA.arrBOOL[32];
bAColletClosePB := stReceivePanelA.arrBOOL[33];
bAColletOpenPB := stReceivePanelA.arrBOOL[34];
bAEjectorsAdvancePB := stReceivePanelA.arrBOOL[35];
bAEjectorsRetractPB := stReceivePanelA.arrBOOL[36];

	(* B Side *)
(*Push Buttons Side B *)
bWBAxisHomePB := stReceivePanelB.arrBOOL[30];
bWBAxisAdvancePB := stReceivePanelB.arrBOOL[31];
bWBAxisRetractPB := stReceivePanelB.arrBOOL[32];
bBColletClosePB := stReceivePanelB.arrBOOL[33];
bBColletOpenPB := stReceivePanelB.arrBOOL[34];
bBEjectorsAdvancePB := stReceivePanelB.arrBOOL[35];
bBEjectorsRetractPB := stReceivePanelB.arrBOOL[36];

(* If We have a FAULT we do not want to permit manual operations.
	So turn off any PB bits that may have been pushed. *)
IF bMachineFault
	OR nAutoCycleStep=AC_Drill
	OR nAutoCycleStep=AC_DrillReturn
	OR nAutoCycleStep=AC_Retract
THEN
	bWAAxisHomePB := FALSE;
	bWAAxisAdvancePB := FALSE;
	bWAAxisRetractPB := FALSE;
	bAColletClosePB := FALSE;
	bAColletOpenPB := FALSE;
	bAEjectorsAdvancePB := FALSE;
	bAEjectorsRetractPB := FALSE;
	bWBAxisHomePB := FALSE;
	bWBAxisAdvancePB := FALSE;
	bWBAxisRetractPB := FALSE;
	bBColletClosePB := FALSE;
	bBColletOpenPB := FALSE;
	bBEjectorsAdvancePB := FALSE;
	bBEjectorsRetractPB := FALSE;
END_IF
END_ACTION

ACTION	Manual_Screen_Receive:
(* MANUAL SCREEN *)

(* Push Buttons *)
(* When the Start Hydraulic PB is pressed on either panel *)
bStartHydraulicPB := stReceivePanelA.arrBOOL[60] OR stReceivePanelB.arrBOOL[60];
(* When the Stop Hydraulic PB is pressed on either panel *)
bStopHydraulicPB := stReceivePanelA.arrBOOL[61] OR stReceivePanelB.arrBOOL[61];
(* When the Start Coolant PB is pressed on either panel *)
bCoolantStartPB := stReceivePanelA.arrBOOL[62] OR stReceivePanelB.arrBOOL[62];
(* When the Stop Coolant PB is pressed on either panel *)
bCoolantStopPB := stReceivePanelA.arrBOOL[63] OR stReceivePanelB.arrBOOL[63];
(* Setup is dependant on the side it is Pressed *)
bEnterSetupPB_A := stReceivePanelA.arrBOOL[64];
bEnterSetupPB_B := stReceivePanelB.arrBOOL[64];
(* Set Zero is dependant on the side it is Pressed *)
bSetZeroPositionPB_A := stReceivePanelA.arrBOOL[65];
bSetZeroPositionPB_B := stReceivePanelB.arrBOOL[65];
(* Move To Zero is dependant on the side it is Pressed *)
bMoveToZeroPositionPB_A := stReceivePanelA.arrBOOL[66];
bMoveToZeroPositionPB_B := stReceivePanelB.arrBOOL[66];

(* When the Home All Automation PB is pressed on either panel *)
bHomeAutomationPB := stReceivePanelA.arrBOOL[68] OR stReceivePanelB.arrBOOL[68];

END_ACTION

ACTION	Part_Program_Screen:
(* PART PROGRAM Inputs *)

(*  Change the Part Program Name when Inserted by operator *)
IF stReceivePanelA.arrTEXTSTRING[1] <> ''  THEN
	sPartProgramName := stReceivePanelA.arrTEXTSTRING[1];
ELSIF stReceivePanelB.arrTEXTSTRING[1] <> '' THEN
	sPartProgramName := stReceivePanelB.arrTEXTSTRING[1];
END_IF

(* Save Part Progarm Push Button *)
bPartProgramSavePB:= stReceivePanelA.arrBOOL[11] OR stReceivePanelB.arrBOOL[11];

(* Leave the PP_SAVE screen *)
IF stReceivePanelA.arrBOOL[69] OR stReceivePanelB.arrBOOL[69] THEN
	sSavePassword:='';
END_IF


(* Load Part Program Push Button - Not available in Auto  *)
bPartProgramLoadPB := stReceivePanelA.arrBOOL[12] OR stReceivePanelB.arrBOOL[12];

(**** IMPORTANT! ***  If the system is in AUTO or In Cycle we need to send a Warning  *)

(* Toggle the state of Spindle Retract mode when PB received from panels *)
IF stReceivePanelA.arrBOOL[10] OR stReceivePanelB.arrBOOL[10] THEN
	IF bSpindleRetractMode THEN
		bSpindleRetractMode:=FALSE;
	ELSE bSpindleRetractMode:=TRUE;
	END_IF
END_IF

(* When a Start Feed Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[1] > 0.0 THEN
	fStartFeed:=stReceivePanelA.arrLREAL[1];
ELSIF stReceivePanelB.arrLREAL[1] > 0.0 THEN
	fStartFeed:=stReceivePanelB.arrLREAL[1];
END_IF

(* When a Start Feed Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[2] > 0.0 THEN
	fFinishFeed:=stReceivePanelA.arrLREAL[2];
ELSIF stReceivePanelB.arrLREAL[2] > 0.0 THEN
	fFinishFeed:=stReceivePanelB.arrLREAL[2];
END_IF

(* When a Start Depth Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[3] < 0.0 THEN
	fStartDepth:=stReceivePanelA.arrLREAL[3];
ELSIF stReceivePanelB.arrLREAL[3] < 0.0 THEN
	fStartDepth:=stReceivePanelB.arrLREAL[3];
END_IF

(* When a Finish Depth Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[4] < 0.0 THEN
	fFinishDepth:=stReceivePanelA.arrLREAL[4];
ELSIF stReceivePanelB.arrLREAL[4] < 0.0 THEN
	fFinishDepth:=stReceivePanelB.arrLREAL[4];
END_IF

(* When a Dwell Time Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[5] > 0.0 THEN
	fDwellTime:=stReceivePanelA.arrLREAL[5];
ELSIF stReceivePanelB.arrLREAL[5] > 0.0 THEN
	fDwellTime:=stReceivePanelB.arrLREAL[5];
END_IF

(* When a Retract Rate Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[6] > 0.0 THEN
	fRetractRate:=stReceivePanelA.arrLREAL[6];
ELSIF stReceivePanelB.arrLREAL[6] > 0.0 THEN
	fRetractRate:=stReceivePanelB.arrLREAL[6];
END_IF

(* When a fDrill Tip Offset Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[7] > 0.0 THEN
	fDrillTipOffset:=stReceivePanelA.arrLREAL[7];
ELSIF stReceivePanelB.arrLREAL[7] > 0.0 THEN
	fDrillTipOffset:=stReceivePanelB.arrLREAL[7];
END_IF

(* When a RPM Request Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[8] > 0.0 THEN
	fRPMRequest:=stReceivePanelA.arrLREAL[8];
ELSIF stReceivePanelB.arrLREAL[8] > 0.0 THEN
	fRPMRequest:=stReceivePanelB.arrLREAL[8];
END_IF

(* When a Tool Diameter Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[9] > 0.0 THEN
	fToolDiameter:=stReceivePanelA.arrLREAL[9];
ELSIF stReceivePanelB.arrLREAL[9] > 0.0 THEN
	fToolDiameter:=stReceivePanelB.arrLREAL[9];
END_IF

(* When a Coolant Pressure Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[10] > 0.0 THEN
	fCoolantPressure:=stReceivePanelA.arrLREAL[10];
ELSIF stReceivePanelB.arrLREAL[10] > 0.0 THEN
	fCoolantPressure:=stReceivePanelB.arrLREAL[10];
END_IF

(* When a Coolant Flow Max Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[11] > 0.0 THEN
	fCoolantFlowMax:=stReceivePanelA.arrLREAL[11];
ELSIF stReceivePanelB.arrLREAL[11] > 0.0 THEN
	fCoolantFlowMax:=stReceivePanelB.arrLREAL[11];
END_IF

(* When a Coolant Flow Min Input is received from either panel then modify *)
IF stReceivePanelA.arrLREAL[12] > 0.0 THEN
	fCoolantFlowMin:=stReceivePanelA.arrLREAL[12];
ELSIF stReceivePanelB.arrLREAL[12] > 0.0 THEN
	fCoolantFlowMin:=stReceivePanelB.arrLREAL[12];
END_IF

(* When Max cycles Set is received from either panel then modify *)
IF stReceivePanelA.arrUDINTIGER[1] > 0 THEN
	nMaxCycles := stReceivePanelA.arrUDINTIGER[1];
ELSIF  stReceivePanelB.arrUDINTIGER[1] > 0 THEN
	nMaxCycles := stReceivePanelB.arrUDINTIGER[1];
END_IF

(* When Spindle Load Max Set is received from either panel then modify *)
IF stReceivePanelA.arrUDINTIGER[2] > 0 THEN
	nSpindleLoadMax := stReceivePanelA.arrUDINTIGER[2];
ELSIF  stReceivePanelB.arrUDINTIGER[2] > 0 THEN
	nSpindleLoadMax := stReceivePanelB.arrUDINTIGER[2];
END_IF

(* When Servo Thrust Max Set is received from either panel then modify *)
IF stReceivePanelA.arrUDINTIGER[3] > 0 THEN
	nServoThrustMax := stReceivePanelA.arrUDINTIGER[3];
ELSIF  stReceivePanelB.arrUDINTIGER[3] > 0 THEN
	nServoThrustMax := stReceivePanelB.arrUDINTIGER[3];
END_IF

END_ACTION

ACTION	Secret_Screen:
(* Receive the PB's from the Panels *)
(* The Panels Make sure you must not be in Auto Mode *)
IF stReceivePanelA.arrBOOL[6] OR stReceivePanelB.arrBOOL[6] THEN
	bASideIsLoadPB := TRUE;
ELSIF  stReceivePanelA.arrBOOL[7] OR stReceivePanelB.arrBOOL[7] THEN
	bBSideIsLoadPB := TRUE;
END_IF

fbSideAEnableRTrig(CLK:=stReceivePanelA.arrBOOL[40] OR stReceivePanelB.arrBOOL[40]);
IF fbSideAEnableRTrig.Q THEN
	IF bSideAEnabled THEN
		bSideAEnabled := FALSE;
	ELSE
		bSideAEnabled :=TRUE;
	END_IF
END_IF

fbSideBEnableRTrig(CLK:=stReceivePanelA.arrBOOL[41] OR stReceivePanelB.arrBOOL[41]);
IF fbSideBEnableRTrig.Q THEN
	IF bSideBEnabled THEN
		bSideBEnabled := FALSE;
	ELSE
		bSideBEnabled :=TRUE;
	END_IF
END_IF

IF bASideIsLoadPB THEN
	sLoadSideSet := 'A';
	(* Swap the Load and Unload Positions *)
	fUAxisLoadPositionTempVariable:=fUAxisLoadSidePosition;
	fUAxisLoadSidePosition:= fUAxisUnloadSidePosition;
	fUAxisUnloadSidePosition:=fUAxisLoadPositionTempVariable;
	bASideIsLoadPB := FALSE;
ELSIF bBSideIsLoadPB THEN
	sLoadSideSet :='B';
	(* Swap the Load and Unload Positions *)
	fUAxisLoadPositionTempVariable:=fUAxisLoadSidePosition;
	fUAxisLoadSidePosition:= fUAxisUnloadSidePosition;
	fUAxisUnloadSidePosition:=fUAxisLoadPositionTempVariable;
	bBSideIsLoadPB := FALSE;
END_IF

IF (stReceivePanelA.arrUDINTIGER[10] >0) THEN
	nUAxisThrustMax := stReceivePanelA.arrUDINTIGER[10];
ELSIF (stReceivePanelB.arrUDINTIGER[10] >0) THEN
	nUAxisThrustMax := stReceivePanelB.arrUDINTIGER[10];
END_IF

(* Tailstock Torque Limit During Clamping *)
IF (stReceivePanelA.arrUDINTIGER[11] >0) THEN
	nTailstockClampingTorqueLimit := UDINT_TO_INT(stReceivePanelA.arrUDINTIGER[11]);
ELSIF (stReceivePanelB.arrUDINTIGER[11] >0) THEN
	nTailstockClampingTorqueLimit := UDINT_TO_INT(stReceivePanelB.arrUDINTIGER[11]);
END_IF

(* Receive the WA Axis Home Offset *)
(* Must compare with current value because 0.0 is an option *)
IF stReceivePanelA.arrLREAL[17] <> 0.0  THEN
	fWAAxisHomeOffset := stReceivePanelA.arrLREAL[17];
ELSIF stReceivePanelB.arrLREAL[17] <> 0.0 THEN
	fWAAxisHomeOffset := stReceivePanelB.arrLREAL[17];
END_IF

(* Receive the WB Axis Home Offset *)
IF stReceivePanelA.arrLREAL[18] <> 0.0  THEN
	fWBAxisHomeOffset := stReceivePanelA.arrLREAL[18];
ELSIF stReceivePanelB.arrLREAL[18] <> 0.0 THEN
	fWBAxisHomeOffset := stReceivePanelB.arrLREAL[18];
END_IF

(* Receive the W Axis Amount to Move Off of Bushing *)
IF stReceivePanelA.arrLREAL[19] <> 0.0 THEN
	fWAxisMoveOffBushing :=stReceivePanelA.arrLREAL[19];
ELSIF stReceivePanelB.arrLREAL[19] <> 0.0 THEN
	fWAxisMoveOffBushing :=stReceivePanelB.arrLREAL[19];
END_IF

(* Receive the W Axis Move Velocity *)
IF stReceivePanelA.arrLREAL[24] > 0.0 THEN
	fTailstockVelocity :=stReceivePanelA.arrLREAL[24];
ELSIF stReceivePanelB.arrLREAL[24] > 0.0 THEN
	fTailstockVelocity :=stReceivePanelB.arrLREAL[24];
END_IF

(* When a WA Axis Max Thrust Input is received from Panel A then modify *)
IF stReceivePanelA.arrUDINTIGER[5] > 0.0 THEN
	nWAAxisThrustMax :=stReceivePanelA.arrUDINTIGER[5];
ELSIF stReceivePanelB.arrUDINTIGER[5] > 0.0 THEN
	nWAAxisThrustMax :=stReceivePanelB.arrUDINTIGER[5];
END_IF

(* When a WB Axis Max Thrust Input is received from Panel B then modify *)
IF stReceivePanelA.arrUDINTIGER[6] > 0.0 THEN
	nWBAxisThrustMax :=stReceivePanelA.arrUDINTIGER[6];
ELSIF stReceivePanelB.arrUDINTIGER[6] > 0.0 THEN
	nWBAxisThrustMax :=stReceivePanelB.arrUDINTIGER[6];
END_IF

END_ACTION

ACTION	Test_Speed_Screen:
(* Test Speed  Screen *)
(* The Test Speed would be like a feed over-ride and changes the speeds of the WA, WB and X Axis movements *)

(* When either panel sets the  "Test Speed Input" then make it Current Test Speed *)
IF (stReceivePanelA.arrUDINTIGER[15] <> 0.0) THEN
	nTestSpeedOverRide := stReceivePanelA.arrUDINTIGER[15];
ELSIF (stReceivePanelB.arrUDINTIGER[15] <> 0.0) THEN
	nTestSpeedOverRide := stReceivePanelB.arrUDINTIGER[15];
END_IF

(* When the Test Speed Overide PB is pressed on either screen, we toggle the state On/Off *)
fbTestSpeedActiveRTrig(CLK:=stReceivePanelA.arrBOOL[15] OR stReceivePanelB.arrBOOL[15]);
IF fbTestSpeedActiveRTrig.Q THEN
	IF bTestSpeedOn THEN
		bTestSpeedOn := FALSE;
	ELSE
		bTestSpeedOn := TRUE;
	END_IF
END_IF

(* When the Test Speed is Activated we want to Change the velocities that we feed to the Axis Move FB's *)
IF bTestSpeedOn THEN
	fWAxisFastVelocity := fTailstockVelocity * (nTestSpeedOverRide/100.0);
	fWAxisClampVelocity :=  fTailstockClampVelocity * (nTestSpeedOverRide/100.0);
	fTransferMoveVelo := fUAxisVelocity  * (nTestSpeedOverRide/100.0);
ELSE
	fWAxisFastVelocity := fTailstockVelocity;
	fWAxisClampVelocity :=  fTailstockClampVelocity;
	fTransferMoveVelo:=  fUAxisVelocity;
END_IF
END_ACTION

ACTION	Transfer_Screen:
(* TRANSFER Screen Inputs *)

(* Raise and Lower Push Buttons *)
bTransferUpPB := (stReceivePanelA.arrBOOL[20] OR stReceivePanelB.arrBOOL[20]);
bTransferDownPB := (stReceivePanelA.arrBOOL[21] OR stReceivePanelB.arrBOOL[21]);

(* Home U Axis PB *)
bHomeUAxisPB := (stReceivePanelA.arrBOOL[22] OR stReceivePanelB.arrBOOL[22]);

(* Move U Axis PB's *)
bMoveUtoLoadPB := (stReceivePanelA.arrBOOL[23] OR stReceivePanelB.arrBOOL[23]);
bMoveUtoUnloadPB := (stReceivePanelA.arrBOOL[24] OR stReceivePanelB.arrBOOL[24]);

(* When we have a FAULT we want to disable manual functions.
	So turn off any PB's that could have been pushed *) 
IF bMachineFault
	OR nAutoCycleStep=AC_Drill
	OR nAutoCycleStep=AC_DrillReturn
	OR nAutoCycleStep=AC_Retract
THEN
	bTransferUpPB := FALSE;
	bTransferDownPB := FALSE;
	bHomeUAxisPB:= FALSE;
	bMoveUtoLoadPB:= FALSE;
	bMoveUtoUnloadPB:= FALSE;
END_IF

(* When either side sets the U Axis A Side position then put it in appropriate Load or Unload variable *)
IF (stReceivePanelA.arrLREAL[15] <>0) THEN	(* fUAxisASidePositionInput *)
	IF (sLoadSideSet = 'A') THEN
		fUAxisLoadSidePosition := stReceivePanelA.arrLREAL[15];
	ELSIF (sLoadSideSet = 'B') THEN
		fUAxisUnloadSidePosition := stReceivePanelA.arrLREAL[15];
	ELSE
		bLoadSideNotSelected := TRUE;
	END_IF
ELSIF (stReceivePanelB.arrLREAL[15] <>0) THEN	(* fUAxisASidePositionInput *)
	IF (sLoadSideSet = 'A') THEN
		fUAxisLoadSidePosition := stReceivePanelB.arrLREAL[15];
	ELSIF (sLoadSideSet = 'B') THEN
		fUAxisUnloadSidePosition := stReceivePanelB.arrLREAL[15];
	ELSE
		bLoadSideNotSelected := TRUE;
	END_IF
END_IF

(* When either side sets the U Axis B Side position then put it in appropriate Load or Unload variable *)
IF (stReceivePanelA.arrLREAL[16] <> 0.0) THEN	(* fUAxisBSidePositionInput *)
	IF (sLoadSideSet = 'A') THEN
		fUAxisUnloadSidePosition := stReceivePanelA.arrLREAL[16];
	ELSIF (sLoadSideSet = 'B') THEN
		fUAxisLoadSidePosition := stReceivePanelA.arrLREAL[16];
	ELSE
		bLoadSideNotSelected := TRUE;
	END_IF
ELSIF (stReceivePanelB.arrLREAL[16] <> 0.0) THEN	(* fUAxisBSidePositionInput *)
	IF (sLoadSideSet = 'A') THEN
		fUAxisUnloadSidePosition := stReceivePanelB.arrLREAL[16];
	ELSIF (sLoadSideSet = 'B') THEN
		fUAxisLoadSidePosition := stReceivePanelB.arrLREAL[16];
	ELSE
		bLoadSideNotSelected := TRUE;
	END_IF
END_IF

(* When either side sets the U Axis "Transfer Speed" then make it Current Speed *)
IF (stReceivePanelA.arrLREAL[25] <> 0.0) THEN
	fUAxisVelocity := stReceivePanelA.arrLREAL[25];
ELSIF (stReceivePanelB.arrLREAL[25] <> 0.0) THEN
	fUAxisVelocity := stReceivePanelB.arrLREAL[25];
END_IF
END_ACTION










(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM Build_Send_Network_Data
(* The program translates the values recieved in the Structure ST_Panel_Receive arrays and places it into the values to be displayed on the screens *)
VAR
	fbHistoryElementTimer: TON;		(* timer to trigger a different Element of the Fault History to pass to the Panels *)
	nHistoryElement : INT := 1;			(* Fault History Element # to pass to the Panels *)
END_VAR
(* @END_DECLARATION := '0' *)
(* Miscellaneous Variables to Send *)

	(* Boolian variaables to Send *)
	stCXPublish1.arrBOOL[1] := bMachineFault ;
	stCXPublish1.arrBOOL[2] := bMachineWarning;
	stCXPublish1.arrBOOL[3] := bCoolantTempWarning;
	stCXPublish1.arrBOOL[4] := bCoolantTempFault;
	stCXPublish1.arrBOOL[5] := bMachineMode;
	stCXPublish1.arrBOOL[6] := bInCycle;

	(* Send the Fault Message Array *)
	stCXPublish1.arrSTRING50[1] := arrFaultMessage[1];
	stCXPublish1.arrSTRING50[2] := arrFaultMessage[2];
	stCXPublish1.arrSTRING50[3] := arrFaultMessage[3];
	stCXPublish1.arrSTRING50[4] := arrFaultMessage[4];
	stCXPublish1.arrSTRING50[5] := arrFaultMessage[5];
	stCXPublish1.arrSTRING50[6] := arrFaultMessage[6];
	stCXPublish1.arrSTRING50[7] := arrFaultMessage[7];
	stCXPublish1.arrSTRING50[8] := arrFaultMessage[8];
	stCXPublish1.arrSTRING50[9] := arrFaultMessage[9];
	stCXPublish1.arrSTRING50[10] := arrFaultMessage[10];

	(* Send the Fault History Array to the panels.  One Variable at a time *)
	fbHistoryElementTimer(IN:=TRUE, PT:=t#300ms);
	(* Every 1/2 second we incriment the Element to be sent *)
	IF fbHistoryElementTimer.Q THEN
		fbHistoryElementTimer(IN:=FALSE);
		nHistoryElement:=nHistoryElement+1;
		(* If we are greater than 80 then reset to 1 *)
		IF nHistoryElement > 80 THEN
			nHistoryElement:=1;
		END_IF
	END_IF
	stCXPublish1.arrUDINTIGER[43] := nHistoryElement;
	stCXPublish1.arrSTRING50[11] := arrFaultHistory[nHistoryElement];

	stCXPublish1.arrUDINTIGER[27] := nAutoCycleStep;
	stCXPublish1.arrUDINTIGER[28] := nEtherCATMasterState;
	stCXPublish1.arrUDINTIGER[42] := nAutoModeState;

	(* Security *)
	arrMachineInfo[10] := sUsername;
	arrMachineInfo[11] := sPassword;
	arrMachineInfo[12] := sSavePassword;
	stCXPublish1.arrUDINTIGER[40] := CurrentUserLevel;
	stCXPublish1.arrBOOL[7] := bWrongPassword;
	stCXPublish1.arrBOOL[69] := bWrongSavePassword;

(***** SECRET Screen Variables to Send *)
	(* LREAL  Variables to Send *)
	stCXPublish1.arrUDINTIGER[29] := nUAxisThrustMax;
	stCXPublish1.arrUDINTIGER[36] := nTailstockClampingTorqueLimit;
	stCXPublish1.arrLREAL[35] := fWAAxisHomeOffset;
	stCXPublish1.arrLREAL[36] := fWBAxisHomeOffset;
	stCXPublish1.arrLREAL[37] := fWAxisMoveOffBushing;
	stCXPublish1.arrLREAL[38] := fTailstockVelocity;
	arrMachineInfo[7] := sLoadSideSet;
	stCXPublish1.arrBOOL[8] := bSideAEnabled;
	stCXPublish1.arrBOOL[9] := bSideBEnabled;

(***** MAIN SCREEN Variables to Send *)
	(* Main Screen *)
	arrMachineInfo[1] := sSerialNumber;
	arrMachineInfo[2] := sKaysJobNumber;
	arrMachineInfo[3] := sModelNumber;
	arrMachineInfo[4] := sCustomerName;
	arrMachineInfo[5] := sProductionDate;
	(* Get Current CX Program Program *)
	arrMachineInfo[6] := CONCAT(UDINT_TO_STRING(F_GetVersionDehoff(1)), '.   ');
	arrMachineInfo[6] := CONCAT(arrMachineInfo[6], UDINT_TO_STRING(F_GetVersionDehoff(2)) );

	(* UDINT Variables to Send *)
	stCXPublish1.arrUDINTIGER[20] := nMotorNominalRPM;
	stCXPublish1.arrUDINTIGER[21] := nMachineNumber;

	stCXPublish1.arrUDINTIGER[22] := nFaultArrayIndex;
	stCXPublish1.arrUDINTIGER[23] := nWarningArrayIndex;

	stCXPublish1.arrBOOL[66] := bUserNameHandshake;
	stCXPublish1.arrBOOL[67] := bPasswordHandshake;
	stCXPublish1.arrBOOL[68] := bSavePasswordHandshake;

(*********		PART PROGRAM Variables	  ***********)
(* These variaables are only published when a panel is on the Part Program Screen *)
	stPartProgramSend.arrLREAL[1] := fStartFeed ;
	stPartProgramSend.arrLREAL[2] := fFinishFeed;
	stPartProgramSend.arrLREAL[3] := fStartDepth;
	stPartProgramSend.arrLREAL[4] := fFinishDepth;
	stPartProgramSend.arrLREAL[5] := fDwellTime;
	stPartProgramSend.arrLREAL[6] := fRetractRate;
	stPartProgramSend.arrLREAL[7] := fDrillTipOffset;
	stPartProgramSend.arrLREAL[8] := fRPMRequest;
	stPartProgramSend.arrLREAL[9] := fToolDiameter;
	stPartProgramSend.arrLREAL[10] := fCoolantPressure;
	stPartProgramSend.arrLREAL[11] := fCoolantFlowMax;
	stPartProgramSend.arrLREAL[12] := fCoolantFlowMin;

	stPartProgramSend.arrBOOL[1] := bSpindleRetractMode;
	stPartProgramSend.arrBOOL[2] := bStartFeedChanged;
	stPartProgramSend.arrBOOL[3] := bFinishFeedChanged;
	stPartProgramSend.arrBOOL[4] := bStartDepthChanged;
	stPartProgramSend.arrBOOL[5] := bFinishDepthChanged;
	stPartProgramSend.arrBOOL[6] := bDwellTimeChanged;
	stPartProgramSend.arrBOOL[7] := bRetractRateChanged;
	stPartProgramSend.arrBOOL[8] := bDrillTipOffsetChanged;
	stPartProgramSend.arrBOOL[9] := bRPMRequestChanged;
	stPartProgramSend.arrBOOL[10] := bSpindleRetractChanged;
	stPartProgramSend.arrBOOL[11] := bToolDiameterChanged;
	stPartProgramSend.arrBOOL[12] := bSpindleLoadMaxChanged;
	stPartProgramSend.arrBOOL[13] := bServoThrustMaxChanged;
	stPartProgramSend.arrBOOL[14] := bCoolantFlowMaxChanged;
	stPartProgramSend.arrBOOL[15] := bCoolantFlowMinChanged;
	stPartProgramSend.arrBOOL[16] := bMaxCyclesChanged;

	stPartProgramSend.arrSTRING[1] := sLastLoadedPartProgramName;
	stPartProgramSend.arrSTRING[2] := sFileOpError;
	stPartProgramSend.arrSTRING[3] := sPartProgramName;
	stPartProgramSend.arrSTRING[4] := sCurrentPartProgram;

	stCXPublish1.arrUDINTIGER[24] := nMaxCycles;				(* On Auto Also *)
	stCXPublish1.arrUDINTIGER[25] := nSpindleLoadMax;			(* On Auto Also *)
	stCXPublish1.arrUDINTIGER[26] := nServoThrustMax;			(* On Auto Also *)

(*********		AUTO SCREEN DISPLAY VARIABLES **********)
	(* UDINT Variables to Send *)
	stCXPublish1.arrUDINTIGER[1] := nCycleTimeMinutes;
	stCXPublish1.arrUDINTIGER[2] := nCycleTimeSeconds;
	stCXPublish1.arrUDINTIGER[3] := nCyclesComplete;
	stCXPublish1.arrUDINTIGER[4] := nPartsCompleteTotal;
	stCXPublish1.arrUDINTIGER[37] := nPartsCompleteA1;
	stCXPublish1.arrUDINTIGER[38] := nPartsCompleteA2;
	stCXPublish1.arrUDINTIGER[39] := nPartsCompleteA3;
	stCXPublish1.arrUDINTIGER[32] := nPartsCompleteB1;
	stCXPublish1.arrUDINTIGER[35] := nPartsCompleteB2;
	stCXPublish1.arrUDINTIGER[41] := nPartsCompleteB3;

	stCXPublish1.arrUDINTIGER[5] := nSpindleRPM1A;
	stCXPublish1.arrUDINTIGER[6] := nSpindleRPM2A;
	stCXPublish1.arrUDINTIGER[7] := nSpindleRPM3A;
	stCXPublish1.arrUDINTIGER[8] := nSpindleRPM1B;
	stCXPublish1.arrUDINTIGER[9] := nSpindleRPM2B;
	stCXPublish1.arrUDINTIGER[10] := nSpindleRPM3B;
	nSpindleLoad1ADisplay:=LREAL_TO_UDINT(
		stVFD_A1DriveInfo.fMotorCurrent / stVFD_A1DriveInfo.fMotorNominalCurrent * 100);
	stCXPublish1.arrUDINTIGER[11] := nSpindleLoad1ADisplay;
	nSpindleLoad2ADisplay:=LREAL_TO_UDINT(
		stVFD_A2DriveInfo.fMotorCurrent / stVFD_A2DriveInfo.fMotorNominalCurrent * 100);
	stCXPublish1.arrUDINTIGER[12] := nSpindleLoad2ADisplay;
	nSpindleLoad3ADisplay:=LREAL_TO_UDINT(
		stVFD_A3DriveInfo.fMotorCurrent / stVFD_A3DriveInfo.fMotorNominalCurrent * 100);
	stCXPublish1.arrUDINTIGER[13] := nSpindleLoad3ADisplay;
	nSpindleLoad1BDisplay:=LREAL_TO_UDINT(
		stVFD_B1DriveInfo.fMotorCurrent / stVFD_B1DriveInfo.fMotorNominalCurrent * 100);
	stCXPublish1.arrUDINTIGER[14] := nSpindleLoad1BDisplay;
	nSpindleLoad2BDisplay:=LREAL_TO_UDINT(
		stVFD_B2DriveInfo.fMotorCurrent / stVFD_B2DriveInfo.fMotorNominalCurrent * 100);
	stCXPublish1.arrUDINTIGER[15] := nSpindleLoad2BDisplay;
	nSpindleLoad3BDisplay:=LREAL_TO_UDINT(
		stVFD_B3DriveInfo.fMotorCurrent / stVFD_B3DriveInfo.fMotorNominalCurrent * 100);
	stCXPublish1.arrUDINTIGER[16] := nSpindleLoad3BDisplay;

	(*	Servo Thrust Display Conversion *)
	IF bAServoEnable THEN
		nServoAThrustDisplay:=ABS(LREAL_TO_DINT(nServoZAThrust/10.0));
	ELSE
		nServoAThrustDisplay:=0;
	END_IF
	stCXPublish1.arrUDINTIGER[17] := nServoAThrustDisplay;

	IF bBServoEnable THEN
		nServoBThrustDisplay:=ABS(LREAL_TO_DINT(nServoZBThrust/10.0));
	ELSE
		nServoBThrustDisplay:=0;
	END_IF
	stCXPublish1.arrUDINTIGER[18] := nServoBThrustDisplay;

	(* LREAL  Variables to Send *)
	stCXPublish1.arrLREAL[1] := fCoolantTempDisplay;

	fCoolantFlow1ADisplay:=(nCoolantFlowA1/32767.0*(fFlowMonitorMax));
	stCXPublish1.arrLREAL[2] := fCoolantFlow1ADisplay;
	fCoolantFlow1AGraph:=nCoolantFlowA1/32767.0*100;
	stCXPublish1.arrLREAL[3] := fCoolantFlow1AGraph;
	fCoolantFlow2ADisplay:=(nCoolantFlowA2/32767.0*(fFlowMonitorMax));
	stCXPublish1.arrLREAL[4] := fCoolantFlow2ADisplay;
	fCoolantFlow2AGraph:=nCoolantFlowA2/32767.0*100;
	stCXPublish1.arrLREAL[5] := fCoolantFlow2AGraph;
	fCoolantFlow3ADisplay:=(nCoolantFlowA3/32767.0*(fFlowMonitorMax));
	stCXPublish1.arrLREAL[6] := fCoolantFlow3ADisplay;
	fCoolantFlow3AGraph:=nCoolantFlowA3/32767.0*100;
	stCXPublish1.arrLREAL[7] := fCoolantFlow3AGraph;

	fCoolantFlow1BDisplay:=(nCoolantFlowB1/32767.0*(fFlowMonitorMax));
	stCXPublish1.arrLREAL[8] 	:= fCoolantFlow1BDisplay;
	fCoolantFlow1BGraph:=nCoolantFlowB1/32767.0*100;
	stCXPublish1.arrLREAL[9] 	:= fCoolantFlow1BGraph;
	fCoolantFlow2BDisplay:=(nCoolantFlowB2/32767.0*(fFlowMonitorMax));
	stCXPublish1.arrLREAL[10] 	:= fCoolantFlow2BDisplay;
	fCoolantFlow2BGraph:=nCoolantFlowB2/32767.0*100;
	stCXPublish1.arrLREAL[11] 	:= fCoolantFlow2BGraph;
	fCoolantFlow3BDisplay:=(nCoolantFlowB3/32767.0*(fFlowMonitorMax));
	stCXPublish1.arrLREAL[12] 	:= fCoolantFlow3BDisplay;
	fCoolantFlow3BGraph:=nCoolantFlowB3/32767.0*100;
	stCXPublish1.arrLREAL[13] 	:= fCoolantFlow3BGraph;

	fZAAxisVelosity 			:= stZAAxis.NcToPlc.SetVelo*60;
	stCXPublish1.arrLREAL[14] 	:= fZAAxisVelosity;
	fZBAxisVelosity 			:= stZBAxis.NcToPlc.SetVelo*60;
	stCXPublish1.arrLREAL[15] 	:= fZBAxisVelosity;

	stCXPublish1.arrLREAL[16] := stZAAxis.NcToPlc.ActPos;
	stCXPublish1.arrLREAL[17] := stZBAxis.NcToPlc.ActPos;
	stCXPublish1.arrLREAL[18] := stWAAxis.NcToPlc.ActPos;
	stCXPublish1.arrLREAL[19] := stWBAxis.NcToPlc.ActPos;

	fFlowMonitorMax := 60;
	stCXPublish1.arrLREAL[20] 	:= fFlowMonitorMax;
	fCoolantFlowMinGraph 		:= fCoolantFlowMin/fFlowMonitorMax*100.0;
	stCXPublish1.arrLREAL[21] 	:= fCoolantFlowMinGraph;
	fCoolantFlowMaxGraph 	:= 100-(fCoolantFlowMax/fFlowMonitorMax*100.0);
	stCXPublish1.arrLREAL[22] 	:= fCoolantFlowMaxGraph;

	stCXPublish1.arrBOOL[63] 	:= bCellRunOutRequest;
	stCXPublish1.arrBOOL[64]	:= bDisplayUnloadConf;
	stCXPublish1.arrBOOL[65]	:= bDispPressCycleStart;


(*********		TRANSFER SCREEN DISPLAY VARIABLES **********)
	stCXPublish1.arrLREAL[25] := stUAxis.NcToPlc.ActPos;
	IF (sLoadSideSet = 'A') THEN
		stCXPublish1.arrLREAL[26] := fUAxisLoadSidePosition;
		stCXPublish1.arrLREAL[27]:= fUAxisUnloadSidePosition;
	ELSIF  (sLoadSideSet = 'B') THEN
		stCXPublish1.arrLREAL[27] := fUAxisLoadSidePosition;
		stCXPublish1.arrLREAL[26]:= fUAxisUnloadSidePosition;
	END_IF
	stCXPublish1.arrLREAL[28]:= fUAxisVelocity;

	stCXPublish1.arrBOOL[10] := stUAxis.NcToPlc.StateDWord.1;
	stCXPublish1.arrBOOL[11] := bProx516;
	stCXPublish1.arrBOOL[12] := bProx517;
	stCXPublish1.arrBOOL[13] := bTransferUp;
	stCXPublish1.arrBOOL[14] := bTransferDown;
	stCXPublish1.arrBOOL[15] := bProx410;
	stCXPublish1.arrBOOL[16] := bProx411;
	stCXPublish1.arrBOOL[17] := bProx412;
	stCXPublish1.arrBOOL[18] := bProx413;
	stCXPublish1.arrBOOL[19] := bProx414;
	stCXPublish1.arrBOOL[20] := bProx415;
	stCXPublish1.arrBOOL[21] := bProx510;
	stCXPublish1.arrBOOL[22] := bProx511;
	stCXPublish1.arrBOOL[23] := bProx512;
	stCXPublish1.arrBOOL[24] := bProx513;
	stCXPublish1.arrBOOL[25] := bProx514;
	stCXPublish1.arrBOOL[26] := bProx515;
	stCXPublish1.arrBOOL[27] := bTransferAtLoadIndicator;

(*********		FIXTURE SCREEN DISPLAY VARIABLES **********)
	stCXPublish1.arrLREAL[30] := fWAxisTransferPosition;
	stCXPublish1.arrLREAL[31] := fWAxisDrillPosition;

	(* A Side *)
	stCXPublish1.arrUDINTIGER[30] := nWAAxisThrust;
	stCXPublish1.arrUDINTIGER[31] := nWAAxisThrustMax;

	stCXPublish1.arrBOOL[30] := stWAAxis.NcToPlc.StateDWord.1;
	stCXPublish1.arrBOOL[31] := bPS616;
	stCXPublish1.arrBOOL[32] := bPS617;
	stCXPublish1.arrBOOL[33] := bProx610;
	stCXPublish1.arrBOOL[34] := bProx611;
	stCXPublish1.arrBOOL[35] := bProx612;
	stCXPublish1.arrBOOL[36] := bProx613;
	stCXPublish1.arrBOOL[37] := bProx614;
	stCXPublish1.arrBOOL[38] := bProx615;
	stCXPublish1.arrBOOL[39] := bAEjectorOvertravelError;

	(* B Side *)
	stCXPublish1.arrUDINTIGER[33] := nWBAxisThrust;
	stCXPublish1.arrUDINTIGER[34] := nWBAxisThrustMax;

	stCXPublish1.arrBOOL[40] := stWBAxis.NcToPlc.StateDWord.1;
	stCXPublish1.arrBOOL[41] := bPS726;
	stCXPublish1.arrBOOL[42] := bPS727;
	stCXPublish1.arrBOOL[43] := bProx720;
	stCXPublish1.arrBOOL[44] := bProx721;
	stCXPublish1.arrBOOL[45] := bProx722;
	stCXPublish1.arrBOOL[46] := bProx723;
	stCXPublish1.arrBOOL[47] := bProx724;
	stCXPublish1.arrBOOL[48] := bProx725;
	stCXPublish1.arrBOOL[49] := bBEjectorOvertravelError;

(**********		MANUAL SCREEN Display Variables	*******)
	stCXPublish1.arrBOOL[50] :=stZAAxis.NcToPlc.StateDWord.1;
	stCXPublish1.arrBOOL[51] :=stZBAxis.NcToPlc.StateDWord.1;
	stCXPublish1.arrBOOL[52] := bHydraulicSystemPressure;
	stCXPublish1.arrBOOL[53] := bHighPressureMotorRunning;
	stCXPublish1.arrBOOL[54] := bTransferPumpMotorRunning;
	stCXPublish1.arrBOOL[55] := bConveyorFWDReq;
	stCXPublish1.arrBOOL[56] := bACoolantSolenoid;
	stCXPublish1.arrBOOL[57] := bBCoolantSolenoid;
	stCXPublish1.arrBOOL[58] := bMCR;
	stCXPublish1.arrBOOL[59] := bMCC_SConfirm;
	stCXPublish1.arrBOOL[60] := bPneumaticSystemPressure;
	stCXPublish1.arrBOOL[61] := bLubePressure;
	stCXPublish1.arrBOOL[62] := bLubeLevel;

(****** 	FAULT Screen 		******)
	stCXPublish1.arrUDINTIGER[46] := nZAAxisDiagNumber ;
	stCXPublish1.arrUDINTIGER[47] := nWAAxisDiagNumber;
	stCXPublish1.arrUDINTIGER[48] := nZBAxisDiagNumber;
	stCXPublish1.arrUDINTIGER[49] := nWBAxisDiagNumber;
	stCXPublish1.arrUDINTIGER[50] := nUAxisDiagNumber;

(******	Test Speed Screen 	*****)
	stCXPublish1.arrUDINTIGER[19] := nTestSpeedOverRide;

	stCXPublish1.arrBOOL[29] := bTestSpeedOn;

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM DEMO
VAR
	ComOnTON: TON;
	ComOffTON: TON;
END_VAR
(* @END_DECLARATION := '0' *)
_LD_BODY
_NETWORKS : 6
_NETWORK

_COMMENT
''
_END_COMMENT
_LD_ASSIGN
_LD_AND
_LD_OPERATOR : 2
_LD_OR
_LD_OPERATOR : 2
_LD_CONTACT
stPB.bPB1
_EXPRESSION
_POSITIV
_LD_CONTACT
stLT.LT1A
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV
_LD_CONTACT
stPB.bPB3
_EXPRESSION
_NEGATIV
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV


ENABLELIST : 0
ENABLELIST_END
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
stLT.LT1A
_NETWORK

_COMMENT
''
_END_COMMENT
_LD_ASSIGN
_LD_AND
_LD_OPERATOR : 2
_LD_OR
_LD_OPERATOR : 2
_LD_CONTACT
stPBB.bPB1
_EXPRESSION
_POSITIV
_LD_CONTACT
stLT.LT1B
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV
_LD_CONTACT
stPBB.bPB3
_EXPRESSION
_NEGATIV
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV


ENABLELIST : 0
ENABLELIST_END
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
stLT.LT1B
_NETWORK

_COMMENT
''
_END_COMMENT
_LD_ASSIGN
_LD_AND
_LD_OPERATOR : 2
_LD_OR
_LD_OPERATOR : 2
_LD_CONTACT
stPB.bPB2
_EXPRESSION
_POSITIV
_LD_CONTACT
stLT.LT2A
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV
_LD_CONTACT
stPB.bPB3
_EXPRESSION
_NEGATIV
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV


ENABLELIST : 0
ENABLELIST_END
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
stLT.LT2A
_NETWORK

_COMMENT
''
_END_COMMENT
_LD_ASSIGN
_LD_AND
_LD_OPERATOR : 2
_LD_OR
_LD_OPERATOR : 2
_LD_CONTACT
stPBB.bPB2
_EXPRESSION
_POSITIV
_LD_CONTACT
stLT.LT2B
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV
_LD_CONTACT
stPBB.bPB3
_EXPRESSION
_NEGATIV
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV


ENABLELIST : 0
ENABLELIST_END
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
stLT.LT2B
_NETWORK

_COMMENT
''
_END_COMMENT
_LD_ASSIGN
_LD_AND
_LD_OPERATOR : 2
_LD_CONTACT
ComOffTON.Q
_EXPRESSION
_NEGATIV
_FUNCTIONBLOCK
ComOnTON
_BOX_EXPR : 2
_EMPTY
_OPERAND
_EXPRESSION
_POSITIV
t#250ms
_EXPRESSION
_POSITIV
TON
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV


ENABLELIST : 0
ENABLELIST_END
_OUTPUTS : 1
_OUTPUT
_POSITIV
_SET
stCXPublish1.arrBOOL[96]
_NETWORK

_COMMENT
''
_END_COMMENT
_LD_ASSIGN
_LD_AND
_LD_OPERATOR : 2
_LD_CONTACT
ComOnTON.Q
_EXPRESSION
_POSITIV
_FUNCTIONBLOCK
ComOffTON
_BOX_EXPR : 2
_EMPTY
_OPERAND
_EXPRESSION
_POSITIV
t#250ms
_EXPRESSION
_POSITIV
TON
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_EXPRESSION
_POSITIV
_EXPRESSION
_POSITIV


ENABLELIST : 0
ENABLELIST_END
_OUTPUTS : 1
_OUTPUT
_NEGATIV
_SET
stCXPublish1.arrBOOL[96]

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MAIN
VAR
	fbMCC_STon : TON;				(* Delay Timer for Servo Power *)

	(*	Manual Mode Helper Variables *)
	nManualModeState: ManualModeStates := MM_Nothing;
	fbSetupModeATimer: TON;
	fbSetupModeBTimer: TON;
	fbSoftStartTimer: TON;
	fbSoftStartTimer2: TON;
	fbCleanTankLevelDelay: TON;						(* Clean Tank Float Switch must be on for 2 seconds *)
	fbMachineModeChangeRTrig : R_TRIG;
	bAutoModeRequest : BOOL := FALSE;
	bManModeRequest : BOOL := FALSE;
	bCoolantSolenoidControl : BOOL := FALSE;			(* Used to Turn On the High Pressure Coolant Solenoids *)
	bStoppingSetup: BOOL := FALSE;
	fbStoppingSetupTON: TON;
	nHomeAutomationStep: INT;						(* Counter for MM_HomeAutomation Steps *)
	fbHomeTimer:TON;								(* Timer used in Homing Automation *)

	(*	Hydraulic Power Unit Control Variables *)
	fbHydraulicPowerUnitMotorControl: FB_MotorStarter;
	bHydraulicPowerUnitMotorControl: BOOL := FALSE;
	bHydraulicPowerUnitMotorControlError: BOOL := FALSE;

	(*	Transfer Pump Control Variables *)
	fbTransferPumpMotorControl: FB_MotorStarter;
	bTransferPumpMotorControl: BOOL := FALSE;
	bTransferPumpMotorControlError: BOOL := FALSE;

	(*	High Pressure Motor Control Variables *)
	fbHighPressureMotorControl: FB_MotorStarter;
	bHighPressureMotorControl: BOOL := FALSE;
	bHighPressureMotorControlError: BOOL := FALSE;

	(*	Chip Conveyor Control Variables *)
	fbChipConveyorMotorControl: FB_MotorStarter;
	bChipConveyorMotorControl: BOOL := FALSE;
	bChipConveyorMotorControlError: BOOL := FALSE;

	(* Auto Cycle Variables *)
	tLastCycleTime: TIME := t#0s;
	fbCycleTimer: TON;
	bCycleTimer: BOOL;
	fbFaultLightBlink: TON;
	bFaultLightBlink: BOOL := FALSE;

	(*	Cycle Start Control Variables *)
	fbCycleStartControl: FB_CycleStart;
	bCycleStartControlHold: BOOL := FALSE;
	bCycleStartControlReset: BOOL := FALSE;
	bCycleStartControlEnable: BOOL := FALSE;

	bCoolantTimer: BOOL := FALSE;
	tCoolantTime: TIME := t#0s;
	fbCoolantTimer: TON;
	tCycleDelayTime: TIME := t#0s;
	fbPS1DelayTON: TON;							(* Delay of PS1- Side A coolant ON *)
	fbPS2DelayTON: TON;							(* Delay of PS1- Side B coolant ON *)
	fbUpToSpeedATON: TON;						(* Delay of Side A VFD's Up to Speed Bits *)
	fbUpToSpeedBTON: TON;						(* Delay of Side B VFD's Up to Speed Bits *)
	fbDwellTimeTON: TON;						(* Drill cycle Dwell Timer *)
	tDwellTime: TIME := t#0s;						(* Drill Cycle Dwell Time *)
	bDwellTime: BOOL := FALSE;					(* Drill Cycle Dwell Timer Trigger *)
	nDrillStep : INT :=0;							(* State counter for AC_Drill Step *)

	bCycleWatchdogTimer: BOOL := FALSE;			(* In Cycle Watchdog Timer Trigger *)
	tCycleWatchdogTime: TIME := t#0ms;				(* In Cycle Watchgod Timer - Time *)
	fbCycleWatchdogTimer : TON;					(*In Cycle Watchdog Timer *)
	bUnclampDelayTimer : BOOL := FALSE;			(* Trigger the dealy timer in the Unclamp Cycle *)
	fbUnclampDelayTON : TON;					(* Unclamp Cycle Delay Timer *)

	nVFDControlRPM: UINT := 0;					(* Spindle RPM Request Converted into Intiger*)
	fbVFD_AStarting: R_TRIG;						(* VFD's for Side A Start Trigger *)
	fbVFD_AHealthyTON: TON;						(* Delay theSide A VFD Healthy signal *)
	fbVFD_BStarting: R_TRIG;						(* VFD's for Side A Start Trigger *)
	fbVFD_BHealthyTON: TON;						(* Delay theSide B VFD Healthy signal *)
	fbVFD_A_EnableTON: TON;					(* Delay of the Side A VFD Enable Signal for Interanal Reset *)
	fbVFD_B_EnableTON: TON;					(* Delay of the Side B VFD Enable Signal for Interanal Reset *)
	fbAResetInternalTrig: R_TRIG;					(* Trigger and internal Reset based on Side A VFD's Status *)
	fbBResetInternalTrig: R_TRIG;					(* Trigger and internal Reset based on Side B VFD's Status *)

	nRPMScaleMax: UDINT := 2500;			(* Max scale set in the Red Lion IFMA modules *)
	bFaultLight: BOOL := FALSE;			(* Panel Fault Lights *)
	bTowerFaultLight: BOOL := FALSE;		(* Tower Red Fault Light*)
	bTowerNotInCycle: BOOL := FALSE;		(* Tower Amber Light *)
	bTowerInCycle: BOOL := FALSE;			(* Tower Green Light *)
	bSetupModeA: BOOL := FALSE;			(*Setup Mode Incudes Side A*)
	nSetupModeAStep: INT := 0;			(* Step Counter for Side A Setup *)
	bSetupModeB: BOOL := FALSE;			(*Setup Mode Includes Side B *)
	nSetupModeBStep: INT := 0;			(* Step Counter for Side B Setup *)
	nDrillReturnCount: INT := 0;				(* Drill Return Counter*)
	fbPB1AConfirmRTrig: R_TRIG;			(* Rising Trigger of Side A Confirm Button *)
	fbPB1BConfirmRTrig: R_TRIG;			(* Rising Trigger of Side B Confirm Button *)
	nCountA: INT := 0;		(*Counter for Test purposes *)
	nCountB: INT := 0;		(*Counter for test purposes *)
	fbVFD_ADataValid: TON;		(* Valid Data from Side A Drives *)
	fbVFD_BDataValid: TON;		(* Valid Data from Side A Drives *)

END_VAR
(* @END_DECLARATION := '0' *)
IF stUAxis.NcToPlc.StateDWord.1 AND
	(stWAAxis.NcToPlc.StateDWord.1 OR NOT bSideAEnabled) AND
	(stWBAxis.NcToPlc.StateDWord.1 OR NOT bSideBEnabled)
THEN
	bWandUAxisHomed := TRUE;
ELSE
	bWandUAxisHomed := FALSE;
END_IF

(* Run the Way Lube when the MCR is On *)
bWayLubePump:= bMCR;

(* Delay the Servo Power after the MCR comes on *)
fbMCC_STon(IN:=bMCR, PT:= t#2s);
bMCC_S := fbMCC_STon.Q;
bMCC_SConfirm;		(* Display Feedback *)

(* When the MCC_S comes in then turn on the Hard Enables *)
bUServoEnable := bMCC_SConfirm;
IF bSideAEnabled THEN
	bAServoEnable := bMCC_SConfirm;
ELSE
	bAServoEnable := FALSE;
END_IF
IF bSideBEnabled THEN
	bBServoEnable := bMCC_SConfirm;
ELSE
	bBServoEnable := FALSE;
END_IF


(*			POWER ON			*)
IF bMCR THEN

	(* VFD Contactor on *)
	IF bMCC_V THEN
		(* Side A Spindle VFD's Enable *)
		IF bSideAEnabled THEN
			IF fbVFD_AHealthyTON.Q AND fbVFD_ADataValid.Q THEN
				bVFD_A_Enable:=TRUE;
			ELSE
				bVFD_A_Enable:=FALSE;
			END_IF
		ELSE
			bVFD_A_Enable:=FALSE;
		END_IF

		(* Side B Spindle VFD's Enable *)
		IF bSideBEnabled THEN
			IF fbVFD_BHealthyTON.Q AND fbVFD_BDataValid.Q THEN
				bVFD_B_Enable:=TRUE;
			ELSE
				bVFD_B_Enable:=FALSE;
			END_IF
		ELSE
			bVFD_B_Enable:=FALSE;
		END_IF

	END_IF

	(*****  CHANGE MANUAL AND AUTO MODES ******)
	(* Check Conditions before going into Auto *)
	(* Check Warnings and Faults *)
	IF NOT bMachineMode AND fbMachineModeChangeRTrig.Q AND NOT bMachineWarning AND NOT bMachineFault THEN
		(* Check MPG A Off *)
		IF bMPGAOn THEN
			nModeError:=Er_MPG_A_Active;
		(* Check MPG B Off *)
		ELSIF bMPGBOn THEN
			nModeError:=Er_MPG_B_Active;
		(* Check Hydraulic Pressure Switch *)
		ELSIF NOT bHydraulicSystemPressure  THEN
			nModeError:=Er_HydraulicPSOff;
		(* Check Coolant High Pressure Pump On *)
		ELSIF NOT bHighPressureMotorRunning THEN
			nModeError:=Er_HPPumpOff;
		(* Check Homing of Transfer *)
		ELSIF NOT stUAxis.NcToPlc.StateDWord.1 THEN
			nModeError:=Er_XAxisNotHomed;
		(*Check Transfer Position *)
		ELSIF NOT bTransferAtLoadIndicator THEN
			nModeError:=Er_TransferNotAtLoad;
		(*Check Homing of ZA Axis *)
		ELSIF bSideAEnabled AND NOT stZAAxis.NcToPlc.StateDWord.1 THEN
			nModeError:=Er_ZAAxisNotHomed;
		(*Check Homing of WA Axis *)
		ELSIF bSideAEnabled AND NOT stWAAxis.NcToPlc.StateDWord.1 THEN
			nModeError:=Er_WAAxisNotHomed;
		(*Check Position of WA Tailstock *)
		ELSIF bSideAEnabled AND stWAAxis.NcToPlc.ActPos < (fWAxisTransferPosition-0.2)   THEN
			nModeError:=Er_WANotRetracted;
		(* Check Side A Cullets Unclamped *)
		ELSIF bSideAEnabled AND NOT bPS616 THEN
			nModeError:=Er_ACulletNotUnclamped;
		(* Check Side A Ejectors Retracted *)
		ELSIF bSideAEnabled AND NOT (nAEjectorRetractedState=7 AND nAEjectorAdvancedState=7) THEN
			nModeError:=Er_AEjectorsNotRetracted;
		(*Check Homing of ZB Axis *)
		ELSIF bSideBEnabled AND NOT stZBAxis.NcToPlc.StateDWord.1 THEN
			nModeError:=Er_ZBAxisNotHomed;
		(*Check Homing of WB Axis *)
		ELSIF bSideBEnabled AND NOT stWBAxis.NcToPlc.StateDWord.1 THEN
			nModeError:=Er_WBAxisNotHomed;
		(*Check Position of WB Tailstock *)
		ELSIF bSideBEnabled AND stWBAxis.NcToPlc.ActPos < (fWAxisTransferPosition-0.2)   THEN
			nModeError:=Er_WBNotRetracted;
		(* Check Side B Cullets Unclamped *)
		ELSIF bSideBEnabled AND NOT bPS726 THEN
			nModeError:=Er_BCulletNotUnclamped;
		(* Check Side A Ejectors Retracted *)
		ELSIF bSideBEnabled AND NOT (nBEjectorRetractedState=7 AND nBEjectorAdvancedState=7) THEN
			nModeError:=Er_BEjectorsNotRetracted;
		(* Passed Checks - Enter Auto Mode *)
		ELSE
			bMachineMode := TRUE;
		END_IF
	(* Check Conditions before going into Manual *)
	ELSIF bMachineMode AND fbMachineModeChangeRTrig.Q THEN
		IF NOT bInCycle THEN
			bMachineMode := FALSE;
		ELSE
			nModeError:=Er_TryingToLeaveAutoInCycle;
		END_IF
	END_IF


	(*		MANUAL MODE FUNCTIONS 		*)
	IF NOT bMachineMode THEN
		(*Turn Off all Auoto Mode bits *)
		bAutoTransferPartsToDrill:=FALSE;
		bAutoTransferDownAndLoad := FALSE;
		bLoadPartsConfirmed:= FALSE;
		bUnloadPartsConfirmed:=FALSE;
		bInCycle:=FALSE;
		bCycleTimer:=FALSE;
		nAutoModeState:=AM_NotInCycle;
		nAutoCycleStep:=AC_Init;
		bCellRunoutRequest:=FALSE;
		bCycleWatchdogTimer := FALSE;
		bAutoClampAStart:=FALSE;
		bAutoClampBStart:=FALSE;
		bAutoUnclampAStart:=FALSE;
		bAutoUnclampBStart:=FALSE;
		bCoolantTimer:= FALSE;
		nAC_UnclampStep := 0;

		(* Reset the Counters when the PB's are pressed *)
		IF bResetCycleCounterPB THEN
			nCyclesComplete:=0;
		ELSIF bResetTotalCountPB THEN
			nPartsCompleteTotal:=0;
		ELSIF bResetA1CountPB THEN
			nPartsCompleteA1:=0;
		ELSIF bResetA2CountPB THEN
			nPartsCompleteA2:=0;
		ELSIF bResetA3CountPB THEN
			nPartsCompleteA3:=0;
		ELSIF bResetB1CountPB THEN
			nPartsCompleteB1:=0;
		ELSIF bResetB2CountPB THEN
			nPartsCompleteB2:=0;
		ELSIF bResetB3CountPB THEN
			nPartsCompleteB3:=0;

		END_IF

		CASE nManualModeState OF
		MM_Nothing:

			IF bStopHydraulicPB THEN
				bHydraulicPowerUnitMotorControl:=FALSE;
			ELSIF bCoolantStopPB THEN
				nManualModeState:=MM_CoolantOff;
			ELSIF bMachineFault THEN
				(* Coolant Related Faults *)
				IF nActiveFaults[1].2=1			(* High Pressure Pump MS Failure *)
					OR nActiveFaults[1].3=1	(* Transfer Pump MS Failure *)
					OR nActiveFaults[1].5=1	(* Low Float Switch *)
					OR nActiveFaults[1].6=1	(* High Coolant Temp Fault *)
					OR bCoolantStopPB		(* Allow Operator to shut off Coolant sytem *)
				 THEN
					nManualModeState:=MM_CoolantOff;
				END_IF
			ELSIF bStartHydraulicPB AND NOT bHydraulicPowerUnitMotorControlError THEN
				bHydraulicPowerUnitMotorControl:=TRUE;
			ELSIF bCoolantStartPB THEN
				nManualModeState:=MM_CoolantOn;
			ELSIF bEnterSetupPB_A THEN
				nManualModeState:=MM_Setup;
			ELSIF bEnterSetupPB_B THEN
				nManualModeState:=MM_Setup;
			ELSIF bSetZeroPositionPB_A THEN
				nManualModeState:=MM_SetZAZero;
			ELSIF bSetZeroPositionPB_B THEN
				nManualModeState:=MM_SetZBZero;
			ELSIF bMoveToZeroPositionPB_A THEN
				nManualModeState:=MM_MoveZAToZero;
			ELSIF bMoveToZeroPositionPB_B THEN
				nManualModeState:=MM_MoveZBToZero;
			ELSIF bHomeAutomationPB THEN
				IF bMPGAOn THEN
					nModeError:=Er_MPG_A_Active;
				ELSIF bMPGBOn THEN
					nModeError:=Er_MPG_B_Active;
				ELSE
					nHomeAutomationStep:=0;
					nManualModeState:=MM_HomeAutomation;
				END_IF
			END_IF

		MM_Setup:
			IF bEnterSetupPB_A THEN
				bSetupModeA:=TRUE;
			END_IF
			IF bEnterSetupPB_B THEN
				bSetupModeB:=TRUE;
			END_IF

		IF bSetupModeA THEN
			CASE nSetupModeAStep OF
			0:	(*MM_SetupModeA *)
				IF bMachineFault THEN
					(* Doors closed handled in Faults *)
					bSetupA:=FALSE;
					bACoolantSolenoid := FALSE;
					bSetupModeA:=FALSE;
					nManualModeState:=MM_Nothing;
				(* High Pressure Pump must be running *)
				ELSIF NOT bHighPressureMotorRunning THEN
					bSetupA:=FALSE;
					bACoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeA:=FALSE;
					nModeError := Er_CoolantOff;
				(* Parts Must be Present *)
				ELSIF NOT(nAEjectorRetractedState=0) OR NOT(nAEjectorAdvancedState=7)
				THEN
					bSetupA:=FALSE;
					bACoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeA:=FALSE;
					nModeError := Er_SetupError;
					nSetupErrorID:=1;
				(* Parts Must be Clamped *)
				ELSIF NOT(bPS617) THEN
					bSetupA:=FALSE;
					bACoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeA:=FALSE;
					nModeError := Er_SetupError;
					nSetupErrorID:=2;
				(* UnClamp PS Must be Off *)
				ELSIF bPS616 THEN
					bSetupA:=FALSE;
					bACoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeA:=FALSE;
					nModeError := Er_SetupError;
					nSetupErrorID:=3;
				(* Exit When Drill Return is Pressed *)
				ELSIF NOT(bPB4ADrillReturn) OR NOT(bPB4BDrillReturn) THEN
					bACoolantSolenoid := FALSE;
					bSetupA:=FALSE;
					bSetupModeA:=FALSE;
					nManualModeState:=MM_Nothing;
				(* If PB is pressed again then move to MMSetup with Spindle *)
				ELSIF fbSetupModeATimer.Q AND bEnterSetupPB_A THEN
					nSetupModeAStep:=1;
					bVFD_ARun:=TRUE;
				(* Turn on the In Setup bit and the solenoid *)
				ELSE
					bACoolantSolenoid := TRUE;
					bSetupA:=TRUE;
				END_IF

			1:	(*	MM_SetupModeAWSpindle		*)
				nVFDControlRPM:=LREAL_TO_UINT(fRPMRequest);
				(* The Setup can be canceled by Drill Retrun of Fault Reset *)
				IF bMachineFault OR NOT(bPB4ADrillReturn) OR NOT(bPB4BDrillReturn) OR bFaultResetPB THEN
					bACoolantSolenoid :=FALSE;
					bVFD_ARun:=FALSE;
					bSetupA:=FALSE;
					bSetupModeA:=FALSE;
					nSetupModeAStep:=0;
					nManualModeState:=MM_Nothing;
				END_IF
			END_CASE	(* nSetupModeAStep *)
		END_IF (*bSetupmodeA *)

		(* MM_SetupModeB*)
		IF bSetupModeB THEN
			CASE nSetupModeBStep OF
			0:	(*MM_SetupModeB *)
				IF bMachineFault THEN
					(* Doors closed handled in Faults *)
					bSetupB:=FALSE;
					bBCoolantSolenoid := FALSE;
					bSetupModeB:=FALSE;
					nManualModeState:=MM_Nothing;
				(* High Pressure Pump must be running *)
				ELSIF NOT bHighPressureMotorRunning THEN
					bSetupB:=FALSE;
					bBCoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeB:=FALSE;
					nModeError := Er_CoolantOff;
				(* Parts Must be Present *)
				ELSIF NOT(nBEjectorRetractedState=0) OR NOT(nBEjectorAdvancedState=7)
				THEN
					bSetupB:=FALSE;
					bBCoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeB:=FALSE;
					nModeError := Er_SetupError;
					nSetupErrorID:=1;
				(* Parts Must be Clamped *)
				ELSIF NOT(bPS727) THEN
					bSetupB:=FALSE;
					bBCoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeB:=FALSE;
					nModeError := Er_SetupError;
					nSetupErrorID:=2;
				(* Unclamped PS Off*)
				ELSIF bPS726 THEN
					bSetupB:=FALSE;
					bBCoolantSolenoid := FALSE;
					nManualModeState:=MM_Nothing;
					bSetupModeB:=FALSE;
					nModeError := Er_SetupError;
					nSetupErrorID:=3;
				(* Exit When Drill Return is Pressed *)
				ELSIF NOT(bPB4ADrillReturn) OR NOT(bPB4BDrillReturn) THEN
					bBCoolantSolenoid := FALSE;
					bSetupB:=FALSE;
					bSetupModeB:=FALSE;
					nManualModeState:=MM_Nothing;
				(* If PB is pressed again then move to MMSetup with Spindle *)
				ELSIF fbSetupModeBTimer.Q AND bEnterSetupPB_B THEN
					nSetupModeBStep:=1;
					bVFD_BRun:=TRUE;
				(* Turn on the In Setup bit and the solenoid *)
				ELSE
					bBCoolantSolenoid := TRUE;
					bSetupB:=TRUE;
				END_IF

			1:	(*MM_SetupModeBWSpindle*)
				nVFDControlRPM:=LREAL_TO_UINT(fRPMRequest);
				(* The Setup can be canceled by Drill Retrun of Fault Reset *)
				IF bMachineFault OR NOT(bPB4ADrillReturn) OR NOT(bPB4BDrillReturn) OR bFaultResetPB THEN
					bBCoolantSolenoid :=FALSE;
					bVFD_BRun:=FALSE;
					bSetupB:=FALSE;
					bSetupModeB:=FALSE;
					nSetupModeBStep:=0;
					nManualModeState:=MM_Nothing;
				END_IF
			END_CASE	(* nSetupModeAStep *)
		END_IF (*bSetupmodeB *)

		MM_SetZAZero:
			IF bMachineFault THEN
				bZAAxisSetZero := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZAAxisSetZero.Error THEN
				nModeError := Er_ZAHomeError;
				bZAAxisSetZero := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZAAxisSetZero.Done THEN
				bZAAxisSetZero := FALSE;
				nManualModeState:=MM_Nothing;
			ELSE
				bZAAxisSetZero := TRUE;
			END_IF

		MM_SetZBZero:
			IF bMachineFault THEN
				bZBAxisSetZero := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZBAxisSetZero.Error THEN
				nModeError := Er_ZBHomeError;
				bZBAxisSetZero := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZBAxisSetZero.Done THEN
				bZBAxisSetZero := FALSE;
				nManualModeState:=MM_Nothing;
			ELSE
				bZBAxisSetZero := TRUE;
			END_IF

		MM_MoveZAToZero:
			IF bMachineFault THEN
				bZAAxisMove := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZAAxisMove.Error THEN
				nModeError := Er_ZAMoveError;
				bZAAxisMove := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZAAxisMove.Done THEN
				bZAAxisMove := FALSE;
				nManualModeState:=MM_Nothing;
			ELSE
				bZAAxisMove := TRUE;
				fZAMovePosition := 0.0;
				fZAMoveVelocity := 25.0;
			END_IF

		MM_MoveZBToZero:
			IF bMachineFault THEN
				bZBAxisMove := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZBAxisMove.Error THEN
				nModeError := Er_ZBMoveError;
				bZBAxisMove := FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF fbZBAxisMove.Done THEN
				bZBAxisMove := FALSE;
				nManualModeState:=MM_Nothing;
			ELSE
				bZBAxisMove := TRUE;
				fZBMovePosition := 0.0;
				fZBMoveVelocity := 25.0;
			END_IF

		MM_CoolantOn:
			(* Make sure the Clean tank level has been on for 2 seconds so that we
				don't draw the level down to quickly when we start the High Pressure Pump *)
			fbCleanTankLevelDelay(IN:=bCleanTankLevel, PT:=t#2s);
			(* If the Coolant Stop PB is pressed while in startup *)
			IF bCoolantStopPB THEN
				nManualModeState:=MM_CoolantOff;
			END_IF

			IF bMachineFault THEN
				bHPCoolantStart_A :=FALSE;
				bHPCoolantStart_B :=FALSE;
				bTransferPumpMotorControl:=FALSE;
				bHighPressureMotorControl:=FALSE;
				nManualModeState:=MM_Nothing;
			(* S1: Start the transfer pump and Turn on the Soft Start Solenoid Valves *)
			ELSIF NOT(fbSoftStartTimer.Q) AND NOT(fbSoftStartTimer2.Q) THEN
				bHPCoolantStart_A :=TRUE;
				bHPCoolantStart_B :=TRUE;
				bTransferPumpMotorControl:=TRUE;
			(* S2: After 5 seconds turn on high pressure Motor *)
			(* Note: We can stay here until we get a fault such as Low Tank Level *)
			ELSIF fbSoftStartTimer.Q AND NOT(fbSoftStartTimer2.Q) AND fbCleanTankLevelDelay.Q
				AND NOT(bCoolantTempWarning) AND bCoolantTankOverflow
			THEN
				bHighPressureMotorControl:=TRUE;
			(* S3: After 5 more seconds Turn off the Soft Start Solenoids *)
			ELSIF fbSoftStartTimer2.Q THEN
				bHPCoolantStart_A :=FALSE;
				bHPCoolantStart_B :=FALSE;
				bChipConveyorMotorControl:=TRUE;
				nManualModeState:=MM_Nothing;
			END_IF

		MM_CoolantOff:
			(*	Turn off High Pressure Motor *)
			bHighPressureMotorControl:=FALSE;
			(* Do not shut off the transfer pump until the coolant temp is below the warning *)
			IF bCoolantTempWarning OR bCoolantTempFault THEN
				bChipConveyorMotorControl:=FALSE;
				nManualModeState:=MM_Nothing;
			ELSIF NOT(bHighPressureMotorOn) THEN
				(*	Turn off Transfer Pump *)
				bTransferPumpMotorControl:=FALSE;
				(*	Done *)
				IF NOT(bTransferPumpOn) THEN
					bChipConveyorMotorControl:=FALSE;
					nManualModeState:=MM_Nothing;
				END_IF
			END_IF

		MM_HomeAutomation:
			IF bMachineFault THEN
				nHomeAutomationStep:=0;
				bWAAxisHome:=FALSE;
				bWBAxisHome:=FALSE;
				bUAxisHome:=FALSE;
				(* Trigger MCStop of Axis.  The bits are turned false when done in respective control *)
				bWAStop:=TRUE;
				bWAStop:=TRUE;
				bUStop:=TRUE;
			ELSE
				CASE nHomeAutomationStep OF
				0: (* Trigger Home of WA and WB Axis *)
					IF bSideAEnabled THEN
						bWAAxisHome:=TRUE;	(* Turned off in P_Tailstock Control PRG *)
					END_IF
					IF bSideBEnabled THEN
						bWBAxisHome:=TRUE;	(* Turned off in P_Tailstock Control PRG *)
					END_IF
					nHomeAutomationStep:=nHomeAutomationStep+1;
	
				1: (* After 1 second then start Homing the U Axis, This assures enough clearance *)
					fbHomeTimer(IN:=TRUE, PT:=t#2s);
					IF fbHomeTimer.Q THEN
						fbHomeTimer(IN:=FALSE);
						(* If an error occurs in either of the Axis we want leave the homing operation *)
						IF fbWAAxisHome.Error OR fbHomeWB.Error THEN
							nHomeAutomationStep:=0;
							nManualModeState:=MM_Nothing;
						(* No Errors Move On *)
						ELSE
							bUAxisHome:=TRUE;
							nHomeAutomationStep:=nHomeAutomationStep+1;
						END_IF
					END_IF
	
				2: (* Check for Done bits of the three Axis *)
					fbHomeTimer(IN:=TRUE, PT:=t#90s);
					(* When All Axis are Homed we return *)
					IF (stWAAxis.NcToPlc.StateDWord.1 AND stWBAxis.NcToPlc.StateDWord.1 AND stUAxis.NcToPlc.StateDWord.1) OR
						(* or if an Error occurs *)
						 fbWAAxisHome.Error OR fbHomeWB.Error OR fbTransferAxisHome.Error OR
						(* or if Homing takes too long *)
						fbHomeTimer.Q
					THEN
						fbHomeTimer(IN:=FALSE);
						nHomeAutomationStep:=0;
						nManualModeState:=MM_Nothing;
						IF fbHomeTimer.Q THEN
							nModeError:=Er_HomeTimeout;
						END_IF
					END_IF

				END_CASE	(* nHomeAutomationStep *)
			END_IF	(* Fault check of MM_HomeAutomation *)

		END_CASE	(* Manual Mode State *)

	(*********		AUTOMATIC MODE 		***********)
	ELSE
		CASE nAutoModeState OF
		AM_NotInCycle:
			(* If we have a fault we Exit Auto Mode *)
			IF bMachineFault THEN
				bMachineMode:=FALSE;
			(* We disable cycle start when we have warings *)
			ELSIF bCycleStartControlEnable AND NOT(bMachineWarning)  THEN
				(* Doors will fault if not closed in cycle *)
				nAutoModeState:=AM_RetractZAxis;
			END_IF

		AM_RetractZAxis:
			IF bMachineFault THEN
				bZAAxisMove:= FALSE;
				bZBAxisMove:= FALSE;
				bZAStop := TRUE;
				bZBStop := TRUE;
				nAutoModeState:=AM_NotInCycle;
			ELSE
				(* Move Z axis to Drill Tip Offset Position *)
				IF bSideAEnabled THEN
					bZAAxisMove:= TRUE;
					fZAMovePosition := fDrillTipOffset;
					fZAMoveVelocity := 25;
				END_IF
				IF bSideBEnabled THEN
					bZBAxisMove:= TRUE;
					fZBMovePosition := fDrillTipOffset;
					fZBMoveVelocity := 25;
				END_IF
				(* Stop Axis and Fault if Move Error *)
				IF (bSideAEnabled AND fbZAAxisMove.Error) THEN
					bZAAxisMove:= FALSE;
					nModeError := Er_ZAHomeError;
					bZAStop:=TRUE;	(* Issue a Stop Axis *)
					bZBAxisMove:= FALSE;
					bMachineMode:=FALSE;	(* Go to Manual Mode *)
				ELSIF (bSideBEnabled AND fbZBAxisMove.Error) THEN
					bZBAxisMove:= FALSE;
					nModeError := Er_ZAHomeError;
					bZBStop:=TRUE;	(* Issue a Stop Axis *)
					bZAAxisMove:= FALSE;
					bMachineMode:=FALSE;	(* Go to Manual Mode *)
				(* If Move Done we Go Into Cycle *)
				ELSIF (NOT(bSideAEnabled) OR fbZAAxisMove.Done) AND
					(NOT(bSideBEnabled) OR fbZBAxisMove.Done) THEN
					bZAAxisMove:= FALSE;
					bZBAxisMove:= FALSE;
					nAutoModeState:=AM_InCycle;
				END_IF
			END_IF

		AM_InCycle:
			(* These Things Happen While In Cycle *)
			fbCoolantTimer(IN:=bCoolantTimer , PT:=tCoolantTime);
			fbCycleTimer(IN:=bCycleTimer , PT:=t#10h);
			(* If the Load confirm PB has been pressed and the parts are there,  then Set a bit for Load Confirm *)
			IF ( sLoadSideSet = 'A' AND bPB1AConfirm AND
				(NOT(bSideAEnabled) OR bProx410 AND bProx411 AND bProx412) AND
				(NOT(bSideBEnabled) OR bProx413 AND bProx414 AND bProx415) ) OR
				(sLoadSideSet ='B' AND bPB1BConfirm AND
				( NOT(bSideAEnabled) OR bProx510 AND bProx511 AND bProx512) AND
				(NOT(bSideBEnabled) OR bProx513 AND bProx514 AND bProx515) )
			THEN
				bLoadPartsConfirmed:= TRUE;	(* Turned Off in Transfer Control *)
			(* Else Set a Warning that Parts are Missing when the PB pressed
				We want to ignore the PB if we have already confirmed parts loaded *)
			ELSIF NOT bLoadPartsConfirmed AND
				( sLoadSideSet = 'A' AND fbPB1AConfirmRTrig.Q) OR
				(sLoadSideSet ='B' AND fbPB1BConfirmRTrig.Q)
			THEN
				nModeError:=Er_LoadPartMissing;
			END_IF
			(* If the Unloadoad confirm PB's have been pressed and there are no parts,  then Set a bit for Unload Confirm *)
			IF (sLoadSideSet = 'B' AND fbPB1AConfirmRTrig.Q AND
				NOT(bProx410 OR bProx411 OR bProx412 OR bProx413 OR bProx414 OR bProx415) ) OR
				(sLoadSideSet ='A' AND fbPB1BConfirmRTrig.Q AND
				NOT(bProx510 OR bProx511 OR bProx512 OR bProx513 OR bProx514 OR bProx515) )
			THEN
				bUnloadPartsConfirmed:= TRUE;
			(* Else set a Warning that Parts are present *)
			ELSIF (sLoadSideSet = 'B' AND fbPB1AConfirmRTrig.Q) OR (sLoadSideSet ='A' AND fbPB1BConfirmRTrig.Q) THEN
				nModeError:=Er_UnloadPartPresent;
			END_IF

			(*	Implement Auto Cycle Stuff Here *)
			CASE nAutoCycleStep OF
			AC_Init:
				bCycleStartControlHold:=FALSE;
				bCycleStartControlReset:=FALSE;
				bCycleTimer:=FALSE;
				(* Check Faults *)
				IF bMachineFault THEN (* Added V1.5 *)
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					nAutoModeState:=AM_NotInCycle;
				ELSIF bLoadPartsConfirmed THEN
					nDrillStep := 0;
					bInCycle:=TRUE;
					nAutoCycleStep:=AC_TransferParts;
				END_IF

			AC_TransferParts:
				(* When Cycle Counter Reached and not Cell Runout we Fault *)
				IF (nCyclesComplete >= nMaxCycles) AND NOT bCellRunoutRequest THEN
					nModeError:= Er_MaxCyclesReached;
					nAutoCycleStep:=AC_Init;
					nAutoModeState:=AM_NotInCycle;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bInCycle:=FALSE;
					bCycleTimer:=FALSE;
					bDisplayUnloadConf := FALSE;
				ELSE
					bCycleTimer:=TRUE;
					IF bMachineFault OR fbCycleWatchdogTimer.Q THEN
						nAutoCycleStep:=AC_Init;
						bInCycle:=FALSE;
						bMachineMode:=FALSE;
						bCycleStartControlReset:=TRUE;
						bCycleStartControlHold:=FALSE;
						bCycleWatchdogTimer := FALSE;
						bCycleTimer:=FALSE;
						bDisplayUnloadConf := FALSE;
						bAutoTransferPartsToDrill:=FALSE;
						nAutoModeState:=AM_NotInCycle;
					(* At Unload Position and UP, So Go to Clamp *)
					ELSIF bTransferAtUnloadIndicator AND
						bProx516 AND NOT(bProx517)
					THEN
						bCycleWatchdogTimer := FALSE;
						IF nCellRunoutCounter=1 AND bCellRunoutRequest THEN
							nAutoCycleStep:=AC_CellRunoutFinish;
						ELSE
							nAutoCycleStep:=AC_Clamp;
						END_IF
					(* Trigger Transfer Move *)
					ELSIF NOT bAutoTransferPartsToDrill  AND bUnloadPartsConfirmed THEN
						bDisplayUnloadConf := FALSE;
						bAutoTransferPartsToDrill:=TRUE;
						bCycleWatchdogTimer := TRUE;
						tCycleWatchdogTime := t#120s;
					(* Display Waiting on Unload Confirm Button *)
					ELSIF NOT bUnloadPartsConfirmed THEN
						bDisplayUnloadConf := TRUE;
					END_IF
				END_IF (* Max Cycles Check *)

			AC_Clamp:
				IF bMachineFault (* OR fbCycleWatchdogTimer.Q *) THEN
					nAutoCycleStep:=AC_Init;
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoClampAStart:=FALSE;
					bAutoClampBStart:=FALSE;
					nAutoModeState:=AM_NotInCycle;
				(* Done Clamping so Go To Coolant On *)
				ELSIF(bAutoClampADone OR NOT(bSideAEnabled)) AND
						(bAutoClampBDone OR NOT(bSideBEnabled)) THEN
					bAutoTransferDownAndLoad := TRUE;
					bCycleWatchdogTimer := FALSE;
					nAutoCycleStep:=AC_CoolantOn;
				(* Trigger Clamping *)
				ELSE
					bCycleWatchdogTimer := TRUE;
					tCycleWatchdogTime := t#30s;
					IF bSideAEnabled THEN
						bAutoClampAStart:=TRUE;
					END_IF
					IF bSideBEnabled THEN
						bAutoClampBStart:=TRUE;
					END_IF
				END_IF

			AC_CoolantOn:
				IF bMachineFault OR fbCycleWatchdogTimer.Q THEN
					nAutoCycleStep:=AC_Init;
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoClampAStart:=FALSE;
					bAutoClampBStart:=FALSE;
					bACoolantSolenoid:=FALSE;
					bBCoolantSolenoid:=FALSE;
					bAutoTransferDownAndLoad := FALSE;
					IF fbCycleWatchdogTimer.Q THEN
						nModeError:=Er_AMCoolantTimeout;
					END_IF
					nAutoModeState:=AM_NotInCycle;
				(* S2: When Pressure Switch On Delay then Turn Spindles On *)
				ELSIF (fbPS1DelayTON.Q OR NOT(bSideAEnabled)) AND
						(fbPS2DelayTON.Q OR NOT(bSideBEnabled)) THEN
					bCycleWatchdogTimer := FALSE;
					nAutoCycleStep:=AC_SpindleOn;
				(* S1: Turn on the Coolant and start the watchdog Timer
					Set the PS delay timer *)
				ELSE
					IF bSideAEnabled THEN
						bACoolantSolenoid:=TRUE;
					END_IF
					IF bSideBEnabled THEN
						bBCoolantSolenoid:=TRUE;
					END_IF
					tCoolantTime:= t#1.5s;
					bCycleWatchdogTimer := TRUE;
					tCycleWatchdogTime := t#15s;
				END_IF

			AC_SpindleOn:
				nVFDControlRPM:=LREAL_TO_UINT(fRPMRequest);
				IF bMachineFault OR fbCycleWatchdogTimer.Q THEN
					nAutoCycleStep:=AC_Init;
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoClampAStart:=FALSE;
					bAutoClampBStart:=FALSE;
					bACoolantSolenoid:=FALSE;
					bBCoolantSolenoid:=FALSE;
					bVFD_ARun:=FALSE;
					bVFD_BRun:=FALSE;
					bAutoTransferDownAndLoad := FALSE;
					IF fbCycleWatchdogTimer.Q THEN
						nModeError:=Er_VFDUpToSpeedTimeout;
					END_IF
					nAutoModeState:=AM_NotInCycle;
				(* S2: Once up to Speed then Drill *)
				ELSIF (fbUpToSpeedATON.Q OR NOT(bSideAEnabled)) AND
						(fbUpToSpeedBTON.Q OR NOT(bSideBEnabled)) THEN
					bCycleWatchdogTimer := FALSE;
					nAutoCycleStep:=AC_Drill;
				(* S1: Turn on Spindles *)
				ELSE
					IF bSideAEnabled THEN
						bVFD_ARun := TRUE;
					END_IF
					IF bSideBEnabled THEN
						bVFD_BRun := TRUE;
					END_IF
					tCycleDelayTime := t#250ms;
				END_IF

			AC_Drill:
				(* Safety interlock: while drilling, keep transfer commands disabled so the part cannot move with drills engaged. *)
				bAutoTransferPartsToDrill:=FALSE;
				bAutoTransferDownAndLoad:=FALSE;
				IF bMachineFault  AND
					(*Faults Array 4 are ones that should not stop the drill cycle *)
					NOT( nActiveFaults[4]>0
						AND nActiveFaults[1]=0
						AND nActiveFaults[2]=0
						AND nActiveFaults[3]=0)
				THEN
					nAutoCycleStep:=AC_DrillReturn;
					nDrillStep := 0;
					bInCycle:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoClampAStart:=FALSE;
					bAutoClampBStart:=FALSE;
					bACoolantSolenoid:=FALSE;
					bBCoolantSolenoid:=FALSE;
					bZAAxisMove:=FALSE;
					bZBAxisMove:=FALSE;
					bZAStop := TRUE;
					bZBStop := TRUE;
					bVFD_ARun:=FALSE;
					bVFD_BRun:=FALSE;
					bDwellTime:= FALSE;
					bAutoTransferDownAndLoad := FALSE;
				ELSE
					(* S1: Move to Strart Depth at Startfeed *)
					(* S2: Wait for Move Done bit *)
					(* S3: Move to Finish Depth at Finish Feed *)
					(* S4: Wait for Move Done bit *)
					(* S5: If Dead Spindle Retract Then-Turn off Spindles *)
					(* T5: VFD's at Zero Speed *)
					(* S6: If Not Dead Spindle Retract then use Dwell Timer *)
					CASE nDrillStep OF
					0: (* S1: Set Execute for Z Axis *)
						IF bSideAEnabled THEN
							bZAAxisMove:=TRUE;
							fZAMovePosition:= fStartDepth;
							fZAMoveVelocity:= fStartFeed/60;
						END_IF
						IF bSideBEnabled THEN
							bZBAxisMove:=TRUE;
							fZBMovePosition:= fStartDepth;
							fZBMoveVelocity:= fStartFeed/60;
						END_IF
						(* T1: Wait for Busy bit *)
						IF (fbZAAxisMove.Busy OR NOT(bSideAEnabled)) AND
							(fbZBAxisMove.Busy OR NOT(bSideBEnabled)) THEN
							nDrillStep:=nDrillStep+1;
						END_IF

					1:(* S2: Wait for Move Start Depth Done bit *)
						IF (fbZAAxisMove.Done OR NOT(bSideAEnabled)) AND
							(fbZBAxisMove.Done OR NOT(bSideBEnabled)) THEN
							bZAAxisMove:=FALSE;
							bZBAxisMove:=FALSE;
							nDrillStep:=nDrillStep+1;
						END_IF

					2: (* S3: Move to Finish Depth at Finish Feed *)
						IF bSideAEnabled THEN
							bZAAxisMove:=TRUE;
							fZAMovePosition:= fFinishDepth;
							fZAMoveVelocity:= fFinishFeed/60;
						END_IF
						IF bSideBEnabled THEN
							bZBAxisMove:=TRUE;
							fZBMovePosition:= fFinishDepth;
							fZBMoveVelocity:= fFinishFeed/60;
						END_IF
						(* T1: Wait for Busy bit *)
						IF (fbZAAxisMove.Busy OR NOT(bSideAEnabled)) AND
							(fbZBAxisMove.Busy OR NOT(bSideBEnabled)) THEN
							nDrillStep:=nDrillStep+1;
						END_IF

					3: (* S4: Wait for Move Done bit *)
						IF (fbZAAxisMove.Done OR NOT(bSideAEnabled)) AND
							(fbZBAxisMove.Done OR NOT(bSideBEnabled)) THEN
							bZAAxisMove:=FALSE;
							bZBAxisMove:=FALSE;
							nDrillStep:=nDrillStep+1;
						END_IF

					4: (* If Dead Spindle Retract then go to Step 5, Else Step 6 *)
						IF bSpindleRetractMode THEN
							nDrillStep:=nDrillStep+1;
						ELSE
							nDrillStep:=6;
						END_IF

					5: (* S5: Turn off Spindles *)
						(* Turn off the VFD Run singnals *)
						bVFD_ARun:=FALSE;
						bVFD_BRun:=FALSE;
						tCycleWatchdogTime := t#5s;
						bCycleWatchdogTimer:=TRUE;
						IF (NOT(bSideAEnabled) OR (stVFD_A1DriveInfo.nActualSpeed < 5) OR
							(stVFD_A2DriveInfo.nActualSpeed < 5) OR (stVFD_A3DriveInfo.nActualSpeed < 5) )
							AND (NOT(bSideBEnabled) OR  (stVFD_A1DriveInfo.nActualSpeed < 5) OR
							(stVFD_A2DriveInfo.nActualSpeed < 5) OR (stVFD_A3DriveInfo.nActualSpeed < 5) )
						THEN
							bCycleWatchdogTimer := FALSE;
							nDrillStep:=0;
							nAutoCycleStep:=AC_Retract;
						(* If This took too long then jump to next step *)
						ELSIF fbCycleWatchdogTimer.Q THEN
							bCycleWatchdogTimer := FALSE;
							nDrillStep:=0;
							nAutoCycleStep:=AC_Retract;
						END_IF

					6: (* S6: Dwell Timer *)
						IF fDwellTime > 0.0 THEN
							bDwellTime:= TRUE;
							fbDwellTimeTON(IN:=bDwellTime, PT:=LREAL_TO_TIME(fDwellTime) );
							IF fbDwellTimeTON.Q THEN
								bDwellTime:= FALSE;
								nDrillStep:=0;
								nAutoCycleStep:=AC_Retract;
							END_IF
						ELSE (* No Dwell Time *)
							nDrillStep:=0;
							nAutoCycleStep:=AC_Retract;
						END_IF

					END_CASE
				END_IF

			AC_DrillReturn:
				(* Keep transfer disabled until Z axes have returned to drill tip offset. *)
				bAutoTransferPartsToDrill:=FALSE;
				bAutoTransferDownAndLoad:=FALSE;
				CASE nDrillReturnCount OF
				0: (* Wait for the Stop to finish and Move to Drill Tip Offset *)
					IF NOT bZAStop AND NOT bZBStop THEN
						bZAAxisMove:=TRUE;
						bZBAxisMove:=TRUE;
						fZAMovePosition:=fDrillTipOffset;
						fZBMovePosition:=fDrillTipOffset;
						fZAMoveVelocity:=50;
						fZBMoveVelocity:=50;
						nDrillReturnCount:=nDrillReturnCount+1;
					END_IF

				1: (* Wait for move to be done *)
					IF fbZAAxisMove.Done AND fbZBAxisMove.Done THEN
						bZAAxisMove:=FALSE;
						bZBAxisMove:=FALSE;
						bMachineMode:=FALSE;
						nAutoModeState:=AM_NotInCycle;
						nDrillReturnCount:=0;
					END_IF
				END_CASE


			AC_Retract:
				(* Keep transfer disabled until drills are fully retracted and spindle/coolant shutdown is complete. *)
				bAutoTransferPartsToDrill:=FALSE;
				bAutoTransferDownAndLoad:=FALSE;
				IF bMachineFault  AND
					(*Faults Array 4 are ones that should not stop the drill cycle *)
					NOT( (nActiveFaults[4]>0)
						AND nActiveFaults[1]=0
						AND nActiveFaults[2]=0
						AND nActiveFaults[3]=0)
				THEN
					nAutoCycleStep:=AC_Init;
					nDrillStep := 0;
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoClampAStart:=FALSE;
					bAutoClampBStart:=FALSE;
					bACoolantSolenoid:=FALSE;
					bBCoolantSolenoid:=FALSE;
					bZAAxisMove:=FALSE;
					bZBAxisMove:=FALSE;
					bZAStop := TRUE;
					bZBStop := TRUE;
					bVFD_ARun:=FALSE;
					bVFD_BRun:=FALSE;
					bAutoTransferDownAndLoad := FALSE;
					nAutoModeState:=AM_NotInCycle;
				(* T1: Move Done Bit *)
				ELSIF (fbZAAxisMove.Done OR NOT(bSideAEnabled)) AND
						(fbZBAxisMove.Done OR NOT(bSideBEnabled)) THEN
					bZAAxisMove:=FALSE;
					bZBAxisMove:=FALSE;
					nAutoCycleStep:=AC_SpindleOff;
				(* S1: Move to Start Position *)
				ELSE
					IF bSideAEnabled THEN
						bZAAxisMove:=TRUE;
						fZAMovePosition:= (0.0 + fDrillTipOffset);
						fZAMoveVelocity:= fRetractRate/60;
					END_IF
					IF bSideBEnabled THEN
						bZBAxisMove:=TRUE;
						fZBMovePosition:= (0.0 + fDrillTipOffset);
						fZBMoveVelocity:= fRetractRate/60;
					END_IF
				END_IF

			AC_SpindleOff:
				(* Turn off the VFD Run singnals *)
				bVFD_ARun:=FALSE;
				bVFD_BRun:=FALSE;
				nAutoCycleStep:=AC_CoolantOff;

			AC_CoolantOff:
				(* Turn off the Coolant Valves *)
				bACoolantSolenoid:=FALSE;
				bBCoolantSolenoid:=FALSE;
				(* Add a time delay so we don't squirt coolant before Unclamping *)
				bCoolantTimer:=TRUE;
				tCoolantTime:=t#250ms;
				IF ( bMachineFault  AND
					(*Faults Array 4 are ones that should not stop the drill cycle *)
					NOT( (nActiveFaults[4]>0)
						AND nActiveFaults[1]=0
						AND nActiveFaults[2]=0
						AND nActiveFaults[3]=0) )
					OR fbCycleWatchdogTimer.Q
				THEN
					nAutoCycleStep:=AC_Init;
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCoolantTimer:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoClampAStart:=FALSE;
					bAutoClampBStart:=FALSE;
					bAutoTransferDownAndLoad := FALSE;
					IF fbCycleWatchdogTimer.Q THEN
						nModeError:=Er_MMCoolantValveStopTimeout;
					END_IF
					nAutoModeState:=AM_NotInCycle;
				ELSIF NOT(bACoolantPressure) AND NOT(bBCoolantPressure) THEN
					bCycleWatchdogTimer := FALSE;
					bCoolantTimer:=FALSE;
					nCyclesComplete:=nCyclesComplete+1;
					IF bSideAEnabled THEN
						nPartsCompleteTotal:=nPartsCompleteTotal+3;
						nPartsCompleteA1:=nPartsCompleteA1+1;
						nPartsCompleteA2:=nPartsCompleteA2+1;
						nPartsCompleteA3:=nPartsCompleteA3+1;
					END_IF
					IF bSideBEnabled THEN
						nPartsCompleteTotal:=nPartsCompleteTotal+3;
						nPartsCompleteB1:=nPartsCompleteB1+1;
						nPartsCompleteB2:=nPartsCompleteB2+1;
						nPartsCompleteB3:=nPartsCompleteB3+1;
					END_IF
					nAutoCycleStep:=AC_Unclamp;
				ELSE
					bCycleWatchdogTimer := TRUE;
					tCycleWatchdogTime := t#10s;
				END_IF

			AC_Unclamp:
				(* Turn off the Clamp Starts *)
				bAutoClampAStart:=FALSE;
				bAutoClampBStart:=FALSE;
				IF ( bMachineFault  AND
					(*Faults Array 4 are ones that should not stop the drill cycle *)
					NOT( (nActiveFaults[4]>0)
						AND nActiveFaults[1]=0
						AND nActiveFaults[2]=0
						AND nActiveFaults[3]=0) )
					OR fbCycleWatchdogTimer.Q
				THEN
					nAutoCycleStep:=AC_Init;
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoTransferDownAndLoad := FALSE;
					bAutoUpDelayWhileUnclamp := FALSE;
					bAutoUnclampAStart:=FALSE;
					bAutoUnclampBStart:=FALSE;
					nAC_UnclampStep:=0;
					IF fbCycleWatchdogTimer.Q THEN
						nModeError:=Er_AMUnclampTimeout;
					END_IF
					nAutoModeState:=AM_NotInCycle;
				END_IF

				CASE nAC_UnclampStep OF
				0: (* Wait for Transfer to beAt Load Station and Up *)
					IF bTransferAtLoadIndicator AND
						fbProx516TON.Q AND NOT(bProx517)
					THEN
						nAC_UnclampStep := nAC_UnclampStep + 1;
					END_IF

				1: (* Once Delay timer done we can start the Unclamp process *)
					(* Watchdog happens in FB, so we need to make this one longer -
						not necessary, but did not want to remove without parts to run. *)
					bCycleWatchdogTimer := TRUE;
					tCycleWatchdogTime := t#15s;
					(* Unclamp the sides that are enabled *)
					IF bSideAEnabled THEN
						bAutoUnclampAStart:=TRUE;
					END_IF
					IF bSideBEnabled THEN
						bAutoUnclampBStart:=TRUE;
					END_IF
					bUnclampDelayTimer := FALSE;
					nAC_UnclampStep := nAC_UnclampStep + 1;

				2: (* Wait for Unload to be done on the sides that are enabled *)
					(* Unclamp Done, Trigger Transfer *)
					IF (NOT(bSideAEnabled) OR bAutoUnclampADone) AND
							(NOT(bSideBEnabled) OR bAutoUnclampBDone) THEN
						bAutoUnclampAStart:=FALSE;
						bAutoUnclampBStart:=FALSE;
						bCycleWatchdogTimer := FALSE;
						bAutoTransferDownAndLoad := FALSE;
						nAC_UnclampStep := 0;
						nAutoCycleStep := AC_TransferParts;
					(* Capture and Report Cycle Time *)
						tLastCycleTime:=fbCycleTimer.ET;
						nCycleTimeMinutes:=TRUNC(TIME_TO_LREAL(tLastCycleTime)/60000);
						nCycleTimeSeconds:=
							TRUNC((TIME_TO_LREAL(tLastCycleTime)-(nCycleTimeMinutes*60000))/1000);
						bCycleTimer:=FALSE;
					(* At this point if we made it trough a cycle without faults we know there are drilled parts on the side
					that are enabled.  Set a bit to track the parts to make sure they ended up at the unload station *)
						IF bSideAEnabled THEN
							bSideADrilledParts:=TRUE;
						END_IF
						IF bSideBEnabled THEN
							bSideBDrilledParts:=TRUE;
						END_IF
					END_IF

				END_CASE (* nAC_UnClampStep *)

			AC_CellRunoutFinish:
				(* If we have a machine fault at this point we want to exit Auto now *)
				IF bMachineFault THEN (* Added condition V1.5 *)
					nAutoCycleStep:=AC_Init;
					bInCycle:=FALSE;
					bMachineMode:=FALSE;
					bCycleStartControlReset:=TRUE;
					bCycleStartControlHold:=FALSE;
					bCycleTimer:=FALSE;
					bCycleWatchdogTimer := FALSE;
					bAutoTransferDownAndLoad := FALSE;
					nAutoModeState:=AM_NotInCycle;
				(* Finished so Jump out of Cycle and turn off request *)
				ELSIF bTransferAtLoadIndicator THEN
					bCellRunoutRequest:=FALSE;
					nCellRunoutCounter:= 0;
					bInCycle:=FALSE;
					nAutoCycleStep:=AC_Init;
				ELSE
					bAutoTransferDownAndLoad := TRUE;
				END_IF


			END_CASE	(* AutoCycle *)

		END_CASE	(* Auto Mode State *)

	END_IF	(*Automatic or Manual Mode*)

ELSE	(* Reset Variables from MCR Out *)
	(* Turn off Auto Mode bits *)
	bMachineMode:=FALSE;
	nAutoCycleStep:=AC_Init;
	bInCycle:=FALSE;
	bAutoTransferPartsToDrill:=FALSE;
	bAutoTransferDownAndLoad := FALSE;
	bLoadPartsConfirmed:= FALSE;
	bUnloadPartsConfirmed:= FALSE;
	bAutoClampAStart:=FALSE;
	bAutoClampBStart:=FALSE;
	bAutoUnclampAStart:=FALSE;
	bAutoUnclampBStart:=FALSE;
	nAC_UnclampStep := 0;
	nManualModeState:=MM_Nothing;
	nDrillReturnCount:=0;

	bCoolantTimer:= FALSE;
	(* Turn off Motors and Enables *)
	bVFD_A_Enable:=FALSE;
	bVFD_B_Enable:=FALSE;
	bVFD_ARun:=FALSE;
	bVFD_BRun:=FALSE;
	bHighPressureMotorControl:=FALSE;
	bTransferPumpMotorControl:=FALSE;
	bChipConveyorMotorControl:=FALSE;

	(* Turn off Solenoids *)
	bACoolantSolenoid := FALSE;
	bBCoolantSolenoid := FALSE;
	(* Turn off soft starts in case we were in Coolant Start *)
	bHPCoolantStart_A :=FALSE;
	bHPCoolantStart_B :=FALSE;

END_IF

(*	Light Tower and Fault Light Control *)
IF bMachineFault THEN
		bFaultLight:=TRUE;
		bTowerFaultLight:=TRUE;
		bTowerInCycle:=FALSE;
		bTowerNotInCycle:=FALSE;
ELSIF bMachineWarning THEN
	IF fbFaultLightBlink.ET>t#490ms THEN
		bFaultLight:=TRUE;
		bTowerFaultLight:=TRUE;
	ELSE
		bFaultLight:=FALSE;
		bTowerFaultLight:=FALSE;
	END_IF
	IF NOT(bFaultLightBlink) THEN
		bFaultLightBlink:=TRUE;
	ELSIF bFaultLightBlink AND fbFaultLightBlink.Q THEN
		bFaultLightBlink:=FALSE;
	END_IF
	bTowerInCycle:=FALSE;
	bTowerNotInCycle:=FALSE;
ELSIF bInCycle THEN
	bFaultLight:=FALSE;
	bTowerFaultLight:=FALSE;
	bTowerInCycle:=TRUE;
	bTowerNotInCycle:=FALSE;
ELSE
	bFaultLight:=FALSE;
	bTowerFaultLight:=FALSE;
	bTowerInCycle:=FALSE;
	bTowerNotInCycle:=TRUE;
END_IF
bLT2:=bTowerFaultLight;	(* Red Light on Tower *)
bLT3:=bTowerNotInCycle;	(* Amber Light on Tower *)
bLT4:=bTowerInCycle;		(* Green Light on Tower *)
bLT5:=bFaultLight;			(* Side A Panel fault light *)
bLT6:=bFaultLight;			(* Side B Panel fault light *)

(* Call Programs *)
DEMO;
P_FaultChecking;
Build_Send_Network_Data;
Build_Receive_Network_Data;
P_PartProgramStorage;
P_SaveData;
P_TransferControl;
P_TailstockControl;
P_MPGControl;

(* Call Actions *)
HydraulicPowerUnitControl;
TransferPumpMotorControl;
HighPressureMotorControl;
ChipConveyorMotorControl;
Security;
CycleStartControl;
VFDControl;
Z_AxisControl;

bSetup:=bSetupA OR bSetupB;
(* Triggers and Timers *)
fbMachineModeChangeRTrig(CLK:=bEnterAutoModePB);
fbSetupModeATimer(IN:= bSetupA , PT:=t#4s);
fbSetupModeBTimer(IN:= bSetupB , PT:=t#4s);
fbPS1DelayTON(IN:=bACoolantPressure , PT:= tCoolantTime);
fbPS2DelayTON(IN:=bBCoolantPressure , PT:= tCoolantTime);
fbUpToSpeedATON(in:=(bVFD_A1UpToSpeed AND bVFD_A2UpToSpeed AND
	 bVFD_A3UpToSpeed) , PT:=tCycleDelayTime);
fbUpToSpeedBTON(in:=(bVFD_B1UpToSpeed AND bVFD_B2UpToSpeed AND
	bVFD_B3UpToSpeed) , PT:=tCycleDelayTime);
fbSoftStartTimer(IN:= bTransferPumpMotorRunning , PT:= t#5s);
fbSoftStartTimer2(IN:= bHighPressureMotorRunning , PT:=t#5s);
fbCycleWatchdogTimer(IN:=bCycleWatchdogTimer, PT:=tCycleWatchdogTime);
fbProx517TON(IN:=bProx517, PT:=t#1.0s);			(* Delay of the Down Prox *)
fbProx516TON(IN:=bProx516, PT:=t#1.0s);			(* Delay of the Up Prox *)
fbUnclampDelayTON(IN:=bUnclampDelayTimer, PT:=t#1.0s);(* Delay the Unclamp cycle *)
fbStoppingSetupTON(IN:= bStoppingSetup, PT:=t#15s);
fbFaultLightBlink(IN:=bFaultLightBlink ,PT:=t#1000ms);
(* VFD Enable to wait for Data Valid bit, 0=Data Valid, 1= Data Invalid *)
fbVFD_ADataValid(IN:=stVFD_A1DriveInfo.bDataValid AND
					stVFD_A2DriveInfo.bDataValid AND
					stVFD_A3DriveInfo.bDataValid, PT:=t#500ms);
fbVFD_BDataValid(IN:=stVFD_B1DriveInfo.bDataValid AND
					stVFD_B2DriveInfo.bDataValid AND
					stVFD_B3DriveInfo.bDataValid, PT:=t#500ms);
(* Emerson Status Word bit 0 is Drive Healthy, *)
(* Delay of VFD starting - used to send internal reset *)
fbVFD_AHealthyTON( IN:=	stVFD_A1DriveInfo.nStatusWord.0 AND
						stVFD_A2DriveInfo.nStatusWord.0 AND
						stVFD_A3DriveInfo.nStatusWord.0,
						PT:= t#1500ms);
fbVFD_AStarting(CLK:=fbVFD_AHealthyTON.Q);
fbVFD_BHealthyTON(IN:=	stVFD_B1DriveInfo.nStatusWord.0 AND
						stVFD_B2DriveInfo.nStatusWord.0 AND
						stVFD_B3DriveInfo.nStatusWord.0,
						PT:= t#1500ms);
fbVFD_BStarting( CLK:=fbVFD_BHealthyTON.Q);
(* Trigger two Internal Fault Reset - 1) Aftre VFD's Healthy bit is true,
							2) After the VFD's have been Enabled*)
fbVFD_A_EnableTON(IN:=bVFD_A_Enable , PT:=t#1000ms);
fbVFD_B_EnableTON(IN:=bVFD_B_Enable , PT:=t#1000ms);
fbAResetInternalTrig(CLK:=fbVFD_A_EnableTON.Q);
fbBResetInternalTrig(CLK:=fbVFD_B_EnableTON.Q);
IF bSideAEnabled AND (fbVFD_AStarting.Q OR fbAResetInternalTrig.Q) THEN
	(*The bit is turned False in Fault Checking *)
	bAFaultResetInternal:=TRUE;
END_IF
(* Else side B is Enabled *)
IF bSideBEnabled AND (fbVFD_BStarting.Q OR fbBResetInternalTrig.Q) THEN
	(*The bit is turned False in Fault Checking *)
	bBFaultResetInternal:=TRUE;
END_IF

(* Rising Edge Trigger of the Load/Unload Confirm PB's *)
fbPB1AConfirmRTrig(CLK:= bPB1AConfirm);
fbPB1BConfirmRTrig(CLK:= bPB1BConfirm);

(* When the transfer is within .1 MM of the Load Position set the indicator *)
IF ((fUAxisLoadSidePosition-0.1) <= stUAxis.NcToPlc.ActPos) AND
		(stUAxis.NcToPlc.ActPos <= (fUAxisLoadSidePosition+0.1)) THEN
	bTransferAtLoadIndicator:= TRUE;
ELSE
	bTransferAtLoadIndicator:= FALSE;
END_IF

(* When the transfer is within .1 MM of the Unload Position set the indicator *)
IF  ( (stUAxis.NcToPlc.ActPos-0.1) <= fUAxisUnloadSidePosition ) AND
	( fUAxisUnloadSidePosition <=  (stUAxis.NcToPlc.ActPos+0.1) )
THEN
	bTransferAtUnloadIndicator := TRUE;
ELSE
	bTransferAtUnloadIndicator := FALSE;
END_IF
END_PROGRAM
ACTION	ChipConveyorMotorControl:
(* The Chip conveyor has a Contactor in the Power Cabinet,
	and it has a VFD on the Conveyor itself *)

(* Pull in the Chip Conveyor Contactor when the MCR is on *)

(* Chip Conveyor Contactor *)
fbChipConveyorMotorControl(
	bStart:= bMCR AND NOT( bChipConveyorMotorControlError),
	bAuxContact:= bChipConveyorMotorRunning
);

bChipConveyorOn:=fbChipConveyorMotorControl.bMSOn;
bChipConveyorMotorControlError:=fbChipConveyorMotorControl.bError;

(* VFD Output *)
(* The VFD Run command is controlled in MM_CoolantOn and MM_Coolant_Off part of Main *)
bConveyorFWDReq:=bChipConveyorMotorControl;

(* Chip Conveyor VFD Fault *)
bChipConveyorVFDFault;
END_ACTION

ACTION	CycleStartControl:
fbCycleStartControl(
	bCS1:= bPB2ACycleStart OR bPB2BCycleStart,
	bCS2:= bPB3ACycleCommon OR bPB3BCycleCommon,
	bHold:= bCycleStartControlHold,
	bReset:= bCycleStartControlReset,
);

bCycleStartControlEnable:=fbCycleStartControl.bEnable;
END_ACTION

ACTION	HighPressureMotorControl:
fbHighPressureMotorControl(
	bStart:=bHighPressureMotorControl ,
	bAuxContact:= bHighPressureMotorRunning
);

bHighPressureMotorOn:=fbHighPressureMotorControl.bMSOn;
bHighPressureMotorControlError:=fbHighPressureMotorControl.bError;

(* When we have a Low tank level or Overflow Switch Fault
	we shut off the High Pressure Pump imediately *)
IF bHighPressureMotorControl THEN
	IF NOT fbCoolantLevelDelayTOF.Q THEN
		bHighPressureMotorControl:=FALSE;
		nModeError:=Er_CleanTankLow;
	ELSIF NOT bCoolantTankOverflow THEN
		bHighPressureMotorControl:=FALSE;
		nModeError:=Er_CoolantOverflow;
	END_IF
END_IF
END_ACTION

ACTION	HydraulicPowerUnitControl:
(* TEMPERATURE FAULT *)
IF bHydraulicTemperature OR bHydraulicPowerUnitMotorControlError THEN
	bHydraulicPowerUnitMotorControl:=FALSE;
END_IF

fbHydraulicPowerUnitMotorControl(
	bStart:=bHydraulicPowerUnitMotorControl ,
	bAuxContact:= bHydraulicPowerUnitRunning
);

bHydraulicUnitOn:=fbHydraulicPowerUnitMotorControl.bMSOn;
bHydraulicPowerUnitMotorControlError:=fbHydraulicPowerUnitMotorControl.bError;

END_ACTION

ACTION	Security:
(* Set the User Level to 0 if in Auto, else to whoever has logged in *)
IF bMachineMode OR bLogoutPB THEN
	CurrentUserLevel:=0;
	sUsername:='';
	sPassword:='';
ELSIF (sUsername = sUsernameKays OR  sUsername = sUsernameKaysEngineering OR sUsername = sUsernameKaysLC) AND
		sPassword = sPasswordKays THEN
	OldUserLevel:=CurrentUserLevel;
	CurrentUserLevel:=7;
	sPassword:='';
ELSIF (sUsername = sUsernameMaint OR sUsername = sUsernameMaintLC OR
		sUsername = sUsernameMaintenance OR sUsername = sUsernameMaintenanceLC) AND
		(sPassword = sPasswordMaintenance OR sPassword = sPasswordMaint) THEN
	OldUserLevel:=CurrentUserLevel;
	CurrentUserLevel:=6;
	sPassword:='';
ELSIF (sUsername = sUsernameSuper OR sUsername = sUsernameSuperLC OR
		sUsername = sUsernameSupervisor OR sUsername = sUsernameSupervisorLC) AND
		(sPassword = sPasswordSupervisor OR sPassword = sPasswordSupervisorUC OR
		sPassword = sPasswordSuper OR sPassword = sPasswordSuperUC) THEN
	OldUserLevel:=CurrentUserLevel;
	CurrentUserLevel:=5;
	sPassword:='';
END_IF


(* Clear the User Names *)
IF (CurrentUserLevel = 5) AND
	(sUsername = sUsernameSupervisor OR sUsername = sUsernameSupervisorLC OR
	sUsername = sUsernameSuper OR sUsername = sUsernameSuperLC)
THEN
	sUsername:='';
ELSIF (CurrentUserLevel = 6) AND
	(sUsername = sUsernameMaintenance OR sUsername = sUsernameMaintenanceLC OR
	sUsername = sUsernameMaint OR sUsername = sUsernameMaintLC)
THEN
	sUsername:='';
ELSIF (CurrentUserLevel = 7) AND
	(sUsername = sUsernameKays OR sUsername = sUsernameKaysLC OR
	sUsername = sUsernameKaysEngineering)
THEN
	sUsername:='';
END_IF

(* Clear the Passwords and User Names on the screen Display boxes *)

END_ACTION

ACTION	TransferPumpMotorControl:
fbTransferPumpMotorControl(
	bStart:= bTransferPumpMotorControl ,
	bAuxContact:=bTransferPumpMotorRunning
);

bTransferPumpOn:=fbTransferPumpMotorControl.bMSOn;
bTransferPumpMotorControlError:=fbTransferPumpMotorControl.bError;

END_ACTION

ACTION	VFDControl:
(*The nVFDAdjustedRPM variable adjusts the entered speed command to correct for actual speed
A line like the one below should be in the Spindle Setup for the actual machine*)
(*nVFDAdjustedRPM:=LREAL_TO_UINT(nVFDControlRPM*1.0);*)

(* The Red Lion Tack's are set to 2500 for max scale *)
nRPMScaleMax:=2500;


(* Display the Tach Feedback inputs as Spindle Speeds*)
(* Side A Tacks when VFD's Enabled *)
IF bVFD_ARun THEN
	nSpindleRPM1A :=
		LREAL_TO_UDINT(nSpindleTachA1/32767.0*nRPMScaleMax);
	nSpindleRPM2A :=
		LREAL_TO_UDINT(nSpindleTachA2/32767.0*nRPMScaleMax);
	nSpindleRPM3A :=
		LREAL_TO_UDINT(nSpindleTachA3/32767.0*nRPMScaleMax);
ELSE
	nSpindleRPM1A := 0;
	nSpindleRPM2A := 0;
	nSpindleRPM3A := 0;
END_IF
(* Side B Tacks when VFD's Enabled *)
IF bVFD_BRun THEN
	nSpindleRPM1B :=
		LREAL_TO_UDINT(nSpindleTachB1/32767.0*nRPMScaleMax);
	nSpindleRPM2B :=
		LREAL_TO_UDINT(nSpindleTachB2/32767.0*nRPMScaleMax);
	nSpindleRPM3B :=
		LREAL_TO_UDINT(nSpindleTachB3/32767.0*nRPMScaleMax);
ELSE
	nSpindleRPM1B := 0;
	nSpindleRPM2B := 0;
	nSpindleRPM3B := 0;
END_IF


nVFDControlRPM:=LREAL_TO_UINT(fRPMRequest);
(* The Ratio is Motor Pulley 34 Teeth Spindle Pulley 45 teeth = 0.755556 *)
fVFDControlRatio:=(45.0/34.0);

(* 		Spindle #A1 VFD control function block *)
fbVFD_A1(
	bRun:= bVFD_ARun ,
	nRPM:= nVFDControlRPM ,
	nOverride:= 100,
	fRatio:= fVFDControlRatio ,
	bMotorDirection:= bVFDControlDirection ,
	bDataValid:= NOT(bVFD_A1DataValid),
	bReset:= bFaultResetPB OR fbCommonFautlResetTON.Q OR bAFaultResetInternal ,
	sNetId:= fbGetAMS.AxisNetId ,
	nSlaveAddr:= nVFD_A1Addr,
	bEnableDrive=> ,
	bUpToSpeed=> bVFD_A1UpToSpeed ,
	bError=> bVFD_A1Error ,
	nErrorID=> nVFD_A1ErrorID ,
	stVFDInfo=> stVFD_A1DriveInfo );

(* 		Spindle #A2 VFD control function block *)
fbVFD_A2(
	bRun:= bVFD_ARun ,
	nRPM:= nVFDControlRPM ,
	nOverride:= 100,
	fRatio:= fVFDControlRatio ,
	bMotorDirection:= bVFDControlDirection ,
	bDataValid:= NOT(bVFD_A2DataValid),
	bReset:= bFaultResetPB OR fbCommonFautlResetTON.Q OR bAFaultResetInternal ,
	sNetId:= fbGetAMS.AxisNetId ,
	nSlaveAddr:= nVFD_A2Addr,
	bEnableDrive=> ,
	bUpToSpeed=> bVFD_A2UpToSpeed ,
	bError=> bVFD_A2Error ,
	nErrorID=> nVFD_A2ErrorID ,
	stVFDInfo=> stVFD_A2DriveInfo );

(* 		Spindle #A3 VFD control function block *)
fbVFD_A3(
	bRun:= bVFD_ARun ,
	nRPM:= nVFDControlRPM ,
	nOverride:= 100,
	fRatio:= fVFDControlRatio ,
	bMotorDirection:= bVFDControlDirection ,
	bDataValid:= NOT(bVFD_A3DataValid),
	bReset:= bFaultResetPB OR fbCommonFautlResetTON.Q OR bAFaultResetInternal ,
	sNetId:= fbGetAMS.AxisNetId ,
	nSlaveAddr:= nVFD_A3Addr,
	bEnableDrive=> ,
	bUpToSpeed=> bVFD_A3UpToSpeed ,
	bError=> bVFD_A3Error ,
	nErrorID=> nVFD_A3ErrorID ,
	stVFDInfo=> stVFD_A3DriveInfo );

(* 		Spindle #B1 VFD control function block *)
fbVFD_B1(
	bRun:= bVFD_BRun ,
	nRPM:= nVFDControlRPM ,
	nOverride:= 100,
	fRatio:= fVFDControlRatio ,
	bMotorDirection:= bVFDControlDirection ,
	bDataValid:= NOT(bVFD_B1DataValid),
	bReset:= bFaultResetPB OR fbCommonFautlResetTON.Q OR bBFaultResetInternal ,
	sNetId:= fbGetAMS.AxisNetId ,
	nSlaveAddr:= nVFD_B1Addr,
	bEnableDrive=> ,
	bUpToSpeed=> bVFD_B1UpToSpeed ,
	bError=> bVFD_B1Error ,
	nErrorID=> nVFD_B1ErrorID ,
	stVFDInfo=> stVFD_B1DriveInfo );

(* 		Spindle #B2 VFD control function block *)
fbVFD_B2(
	bRun:= bVFD_BRun ,
	nRPM:= nVFDControlRPM ,
	nOverride:= 100,
	fRatio:= fVFDControlRatio ,
	bMotorDirection:= bVFDControlDirection ,
	bDataValid:= NOT(bVFD_B2DataValid),
	bReset:= bFaultResetPB OR fbCommonFautlResetTON.Q OR bBFaultResetInternal ,
	sNetId:= fbGetAMS.AxisNetId ,
	nSlaveAddr:= nVFD_B2Addr,
	bEnableDrive=> ,
	bUpToSpeed=> bVFD_B2UpToSpeed ,
	bError=> bVFD_B2Error ,
	nErrorID=> nVFD_B2ErrorID ,
	stVFDInfo=> stVFD_B2DriveInfo );

(* 		Spindle #B3 VFD control function block *)
fbVFD_B3(
	bRun:= bVFD_BRun ,
	nRPM:= nVFDControlRPM ,
	nOverride:= 100,
	fRatio:= fVFDControlRatio ,
	bMotorDirection:= bVFDControlDirection ,
	bDataValid:= NOT(bVFD_B3DataValid),
	bReset:= bFaultResetPB OR fbCommonFautlResetTON.Q OR bBFaultResetInternal ,
	sNetId:= fbGetAMS.AxisNetId ,
	nSlaveAddr:= nVFD_B3Addr,
	bEnableDrive=> ,
	bUpToSpeed=> bVFD_B3UpToSpeed ,
	bError=> bVFD_B3Error ,
	nErrorID=> nVFD_B3ErrorID ,
	stVFDInfo=> stVFD_B3DriveInfo );

(* Get the AMS Net ID of the CX TwinCAT when the MCC_V Contactor Pulled In *)
fbGetAMS(
	sNetId:='' ,
	iAxisId:=1 ,
	bExecute:=bMCC_V );

END_ACTION

ACTION	Z_AxisControl:
(* Turn on MC_Power when Hard Enable is ON *)
bZAAxisPower := bAServoEnable;

fbZAAxisPower(
	Enable:=bZAAxisPower ,
	Enable_Positive:=bZAAxisPower ,
	Enable_Negative:=bZAAxisPower ,
	Override:=100 ,
	BufferMode:=MC_Aborting ,
	Axis:=stZAAxis );

fbZAAxisSetZero(
	Execute:=bZAAxisSetZero,
	Position:=0.0,
	HomingMode:=MC_Direct,
	Axis:=stZAAxis );

fbZAAxisMove(
	Execute:= bZAAxisMove ,
	Position:= fZAMovePosition ,
	Velocity:= fZAMoveVelocity ,
	Acceleration:= 0 ,
	Deceleration:= 0,
	Jerk := 0,
	BufferMode:=MC_Aborting ,
	Axis := stZAAxis );

(* When the Axis Stop is done, then turn off the enable
	Must be above the Command so the done bit will be true for a scan *)
IF bZAStop AND fbZAAxisStop.Done THEN
	bZAStop:=FALSE;
END_IF
fbZAAxisStop(
	Execute := bZAStop,
	Deceleration := 0,
	Jerk := 0,
	Axis := stZAAxis );

fbZAAxisMCReset(
	Execute:=bZAMCResetRequest ,
	Axis:=stZAAxis );

fbZAAxisDriveReset(
	NetId:='' ,
	Execute:=bZWADriveResetRequest ,
	Timeout:=t#10s ,
	Axis:= stZAAxis, );

stZAAxis.ReadStatus();

(* If one of the ZA Axis overtravel limit switches is made, then turn on the bit that allows
Movement off of the limit switchs *)
IF NOT(DriveZAWAdinputs.0) OR NOT(DriveZAWAdinputs.1) THEN
	bZADeCtrlEnable:=TRUE;
ELSE
	bZADeCtrlEnable:=FALSE;
END_IF
stZAAxis.PlcToNc.ControlDWord :=
AxisSetAcceptBlockedDriveSignal(stZAAxis.PlcToNc.ControlDWord,
	bEnable:= bZADeCtrlEnable );

(* If a Drive reset was requested then when the Drive Reset is done we want to do a MC Reset of the NC Axis *)
IF bZWADriveResetRequest AND (NOT (fbZAAxisDriveReset.Busy) OR  fbZAAxisDriveReset.Error) THEN
	bZAMCResetRequest:=TRUE;
(* Else if the MC Reset is on when when the Drive Reset it busy it must have stuck on so we want to turn it off *)
ELSIF bZWADriveResetRequest AND fbZAAxisDriveReset.Busy AND bZAMCResetRequest THEN
	bZAMCResetRequest:=FALSE;
END_IF
IF fbZAAxisMCReset.Done THEN
	bZAMCResetRequest:=FALSE;
	bZWADriveResetRequest:=FALSE;
END_IF

(* 			Z Axis Side B 			*)

(* Turn on MC_Power when Hard Enable is ON *)
bZBAxisPower := bBServoEnable;

fbZBAxisPower(
	Enable:=bZBAxisPower ,
	Enable_Positive:=bZBAxisPower ,
	Enable_Negative:=bZBAxisPower ,
	Override:=100 ,
	BufferMode:=MC_Aborting ,
	Axis:=stZBAxis );

fbZBAxisSetZero(
	Execute:=bZBAxisSetZero,
	Position:=0.0,
	HomingMode:=MC_Direct,
	Axis:=stZBAxis );

fbZBAxisMove(
	Execute:= bZBAxisMove ,
	Position:= fZBMovePosition ,
	Velocity:= fZBMoveVelocity ,
	Acceleration:= 0 ,
	Deceleration:= 0,
	Jerk := 0,
	BufferMode:=MC_Aborting ,
	Axis := stZBAxis );

(* When the Axis Stop is done, then turn off the enable
	Must be above the Command so the done bit will be true for a scan *)
IF bZBStop AND fbZBAxisStop.Done THEN
	bZBStop:=FALSE;
END_IF
fbZBAxisStop(
	Execute := bZBStop,
	Deceleration := 0,
	Jerk := 0,
	Axis := stZBAxis );

fbZBAxisMCReset(
	Execute:=bZBMCResetRequest ,
	Axis:=stZBAxis );

fbZBAxisDriveReset(
	NetId:='' ,
	Execute:=bZWBDriveResetRequest ,
	Timeout:=t#10s ,
	Axis:= stZBAxis, );

stZBAxis.ReadStatus();

(* If one of the ZB Axis overtravel limit switches is made, then turn on the bit that allows
Movement off of the limit switchs *)
IF NOT(DriveZBWBdinputs.0) OR NOT(DriveZBWBdinputs.1) THEN
	bZBDeCtrlEnable:=TRUE;
ELSE
	bZBDeCtrlEnable:=FALSE;
END_IF
stZBAxis.PlcToNc.ControlDWord :=
AxisSetAcceptBlockedDriveSignal(stZBAxis.PlcToNc.ControlDWord,
	bEnable:= bZBDeCtrlEnable );

(* If a Drive reset was requested then when the Drive Reset is done we want to do a MC Reset of the NC Axis *)
IF bZWBDriveResetRequest AND (NOT (fbZBAxisDriveReset.Busy) OR  fbZBAxisDriveReset.Error) THEN
	bZBMCResetRequest:=TRUE;
(* Else if the MC Reset is on when when the Drive Reset it busy it must have stuck on so we want to turn it off *)
ELSIF bZWBDriveResetRequest AND fbZBAxisDriveReset.Busy AND bZBMCResetRequest THEN
	bZBMCResetRequest:=FALSE;
END_IF
IF fbZBAxisMCReset.Done THEN
	bZBMCResetRequest:=FALSE;
	bZWBDriveResetRequest:=FALSE;
END_IF
END_ACTION











(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM P_FaultChecking
VAR
	nSpindleSpeedVariationMax: UDINT := 0;
	nSpindleSpeedVariationMin: UDINT := 0;
	bFaultResetRequested: BOOL := FALSE;

	(* Flow Monitors *)
	bHighFlow1A: BOOL := FALSE;
	bLowFlow1A: BOOL := FALSE;
	bHighFlow2A: BOOL := FALSE;
	bLowFlow2A: BOOL := FALSE;
	bHighFlow3A: BOOL := FALSE;
	bLowFlow3A: BOOL := FALSE;
	bHighFlow1B: BOOL := FALSE;
	bLowFlow1B: BOOL := FALSE;
	bHighFlow2B: BOOL := FALSE;
	bLowFlow2B: BOOL := FALSE;
	bHighFlow3B: BOOL := FALSE;
	bLowFlow3B: BOOL := FALSE;
	fbFlowAverageTimer1AHIGH: TON;
	fbFlowAverageTimer1ALOW: TON;
	fbFlowAverageTimer2AHIGH: TON;
	fbFlowAverageTimer2ALOW: TON;
	fbFlowAverageTimer3AHIGH: TON;
	fbFlowAverageTimer3ALOW: TON;
	fbFlowAverageTimer1BHIGH: TON;
	fbFlowAverageTimer1BLOW: TON;
	fbFlowAverageTimer2BHIGH: TON;
	fbFlowAverageTimer2BLOW: TON;
	fbFlowAverageTimer3BHIGH: TON;
	fbFlowAverageTimer3BLOW: TON;
	fbCoolantOnDelayTON: TON;

	(* Filter Fault Variables *)
	nDirtyCount1: UDINT := 0;
	nDirtyCount2: UDINT := 0;
	nDirtyCount3: UDINT := 0;
	nDirtyCount4: UDINT := 0;
	bFilter1Timer: BOOL := FALSE;
	bFilter2Timer: BOOL := FALSE;
	bFilter3Timer: BOOL := FALSE;
	bFilter4Timer: BOOL := FALSE;

(*Timers and Triggers *)
	fbCycleCommonTimeout: TON;
	fbFilter1Timer: TON;
	fbFilter2Timer: TON;
	fbFilter3Timer: TON;
	fbFilter4Timer: TON;

	fbLowPressureFaultADelay: TON;
	fbLowPressureFaultBDelay: TON;
	fbCoolantStartTimer: TON;
	fbCoolantTempFaultTON: TON;
	fbCoolantTempWarningTON: TON;
	fbHydraulicSystemOnTON: TON;
	fbHydraulicFluidLowTON: TON;
	fbLubePressureTON: TON;				(* Timer to fault with low lube pressure *)
	fbLubeLevelCheckRTrig: R_TRIG;		(* Check for Low Lube Level at end of Cycle *)
	nLubeLevelLowCount: INT :=0;			(* Count the number of cycles with Low Lube for Fault *)

	fbServoAThrustMaxDelayTON: TON;
	fbServoBThrustMaxDelayTON: TON;
	fbALoadFaultDelay: TON;				(* Side A Spindle Load Fault Delay Timer *)
	fbBLoadFaultDelay: TON;				(* Side B Spindle Load Fault Delay Timer *)
	(* Spindle Speed Timers *)
	fbASpeedDelayTimer: TON;
	fbSpeedVariationTimer1ALOW: TON;
	fbSpeedVariationTimer1AHIGH: TON;
	fbSpeedVariationTimer2ALOW: TON;
	fbSpeedVariationTimer2AHIGH: TON;
	fbSpeedVariationTimer3ALOW: TON;
	fbSpeedVariationTimer3AHIGH: TON;
	fbBSpeedDelayTimer: TON;
	fbSpeedVariationTimer1BLOW: TON;
	fbSpeedVariationTimer1BHIGH: TON;
	fbSpeedVariationTimer2BLOW: TON;
	fbSpeedVariationTimer2BHIGH: TON;
	fbSpeedVariationTimer3BLOW: TON;
	fbSpeedVariationTimer3BHIGH: TON;
(* Fault Program Variables *)
	nFaultState: UDINT := 0;
	nHistoryStep : USINT := 1;
	arrFaultHistoryTemp: ARRAY[1..80] OF STRING (52) := 80('');
	arrFaultWarningCurrent : ARRAY[0..9] OF STRING (52) := 10('');
	fbFaultResetWatchdog: TON;	(* Make sure we do not get stuck in the Fault Reset step *)
	nCurrent : USINT := 0;
	nUnStored : USINT := 0;

	fbInternalResetTON: TON;				(* A time delay to trigger turning off the Internal Reset *)
	fbMCRJustOnTON: TON;				(* A time delay of the MCR just turned on *)
END_VAR
(* @END_DECLARATION := '0' *)
fbCycleCommonTimeout(IN:= bPB2ACycleStart OR bPB3ACycleCommon OR bPB2BCycleStart OR bPB3BCycleCommon , PT:=t#10s);
(* When the Common PB is made for 1/2 second without the Cycle Start PB then Trigger a Fault Reset *)
fbCommonFautlResetTON(IN:= (bPB3ACycleCommon AND NOT(bPB2ACycleStart)) OR
	(bPB3BCycleCommon AND NOT(bPB2BCycleStart)) , PT:=t#500ms );
fbFilter1Timer(IN:= bFilter1Timer , PT:=t#40s);
fbFilter2Timer(IN:= bFilter2Timer , PT:=t#40s);
fbFilter3Timer(IN:= bFilter3Timer , PT:=t#40s);
fbFilter4Timer(IN:= bFilter4Timer , PT:=t#40s);
fbCoolantStartTimer(IN:= MAIN.bTransferPumpMotorControl,	PT:=t#15s);
fbCoolantTempFaultTON(IN:=bCoolantTempFault, PT:=t#100ms);
fbCoolantTempWarningTON(IN:=bCoolantTempWarning, PT:=t#100ms);
fbCoolantOnDelayTON(IN:=bACoolantSolenoid  OR bBCoolantSolenoid,PT:=t#1500ms);
(* Flow Monitor Timers *)
fbFlowAverageTimer1ALOW(IN:=bLowFlow1A AND bACoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer1AHIGH(IN:=bHighFlow1A AND bACoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer2ALOW(IN:=bLowFlow2A AND bACoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer2AHIGH(IN:=bHighFlow2A AND bACoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer3ALOW(IN:=bLowFlow3A AND bACoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer3AHIGH(IN:=bHighFlow3A AND bACoolantSolenoid , PT:=t#1000ms);

fbFlowAverageTimer1BLOW(IN:=bLowFlow1B AND bBCoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer1BHIGH(IN:=bHighFlow1B AND bBCoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer2BLOW(IN:=bLowFlow2B AND bBCoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer2BHIGH(IN:=bHighFlow2B AND bBCoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer3BLOW(IN:=bLowFlow3B AND bBCoolantSolenoid , PT:=t#1000ms);
fbFlowAverageTimer3BHIGH(IN:=bHighFlow3B AND bBCoolantSolenoid , PT:=t#1000ms);

fbServoAThrustMaxDelayTON(IN:=nServoAThrustDisplay>nServoThrustMax, PT:=t#200ms);
fbServoBThrustMaxDelayTON(IN:=nServoBThrustDisplay>nServoThrustMax, PT:=t#200ms);

(* Side A Spindle Speed Delay *)
(*	Calculate Comparison Variables *)
nSpindleSpeedVariationMax:=(MAIN.nVFDControlRPM+199);
nSpindleSpeedVariationMin:=(MAIN.nVFDControlRPM-199);
fbASpeedDelayTimer(IN:=bVFD_A1UpToSpeed AND bVFD_A2UpToSpeed AND bVFD_A3UpToSpeed,
	PT:=LREAL_TO_TIME(5+stVFD_A1DriveInfo.fAccelerationTime*1000));
fbSpeedVariationTimer1ALOW(IN:=nSpindleRPM1A<nSpindleSpeedVariationMin ,PT:=t#250ms);
fbSpeedVariationTimer1AHIGH(IN:=nSpindleRPM1A>nSpindleSpeedVariationMax ,PT:=t#250ms);
fbSpeedVariationTimer2ALOW(IN:=nSpindleRPM2A<nSpindleSpeedVariationMin ,PT:=t#250ms);
fbSpeedVariationTimer2AHIGH(IN:=nSpindleRPM2A>nSpindleSpeedVariationMax ,PT:=t#250ms);
fbSpeedVariationTimer3ALOW(IN:=nSpindleRPM3A<nSpindleSpeedVariationMin ,PT:=t#250ms);
fbSpeedVariationTimer3AHIGH(IN:=nSpindleRPM3A>nSpindleSpeedVariationMax ,PT:=t#250ms);
(* Side A Spindle Speed Delay *)
fbBSpeedDelayTimer(IN:=bVFD_B1UpToSpeed AND bVFD_B2UpToSpeed AND bVFD_B3UpToSpeed,
	PT:=LREAL_TO_TIME(5+stVFD_B1DriveInfo.fAccelerationTime*1000));
fbSpeedVariationTimer1BLOW(IN:=nSpindleRPM1B<nSpindleSpeedVariationMin ,PT:=t#250ms);
fbSpeedVariationTimer1BHIGH(IN:=nSpindleRPM1B>nSpindleSpeedVariationMax ,PT:=t#250ms);
fbSpeedVariationTimer2BLOW(IN:=nSpindleRPM2B<nSpindleSpeedVariationMin ,PT:=t#250ms);
fbSpeedVariationTimer2BHIGH(IN:=nSpindleRPM2B>nSpindleSpeedVariationMax ,PT:=t#250ms);
fbSpeedVariationTimer3BLOW(IN:=nSpindleRPM3B<nSpindleSpeedVariationMin ,PT:=t#250ms);
fbSpeedVariationTimer3BHIGH(IN:=nSpindleRPM3B>nSpindleSpeedVariationMax ,PT:=t#250ms);
(*	Spindle Load Delay *)
fbALoadFaultDelay(
	IN:= bVFD_A1UpToSpeed AND bVFD_A2UpToSpeed AND bVFD_A3UpToSpeed ,
	PT:=t#1500ms);
fbBLoadFaultDelay(
	IN:= bVFD_B1UpToSpeed AND bVFD_B2UpToSpeed AND bVFD_B3UpToSpeed ,
	PT:=t#1500ms);

(*	Flow Fault Helper *)
(* SIDE A *)
IF ( fCoolantFlow1ADisplay<fCoolantFlowMin ) AND bACoolantSolenoid THEN
	bLowFlow1A:=TRUE;
ELSE
	bLowFlow1A:=FALSE;
END_IF
IF ( fCoolantFlow1ADisplay>fCoolantFlowMax ) AND bACoolantSolenoid THEN
	bHighFlow1A:=TRUE;
ELSE
	bHighFlow1A:=FALSE;
END_IF
IF ( fCoolantFlow2ADisplay<fCoolantFlowMin ) AND bACoolantSolenoid THEN
	bLowFlow2A:=TRUE;
ELSE
	bLowFlow2A:=FALSE;
END_IF
IF ( fCoolantFlow2ADisplay>fCoolantFlowMax ) AND bACoolantSolenoid THEN
	bHighFlow2A:=TRUE;
ELSE
	bHighFlow2A:=FALSE;
END_IF
IF ( fCoolantFlow3ADisplay<fCoolantFlowMin ) AND bACoolantSolenoid THEN
	bLowFlow3A:=TRUE;
ELSE
	bLowFlow3A:=FALSE;
END_IF
IF ( fCoolantFlow3ADisplay>fCoolantFlowMax ) AND bACoolantSolenoid THEN
	bHighFlow3A:=TRUE;
ELSE
	bHighFlow3A:=FALSE;
END_IF

(* SIDE B *)
IF ( fCoolantFlow1BDisplay<fCoolantFlowMin ) AND bBCoolantSolenoid THEN
	bLowFlow1B:=TRUE;
ELSE
	bLowFlow1B:=FALSE;
END_IF
IF ( fCoolantFlow1BDisplay>fCoolantFlowMax ) AND bBCoolantSolenoid THEN
	bHighFlow1B:=TRUE;
ELSE
	bHighFlow1B:=FALSE;
END_IF
IF ( fCoolantFlow2BDisplay<fCoolantFlowMin ) AND bBCoolantSolenoid THEN
	bLowFlow2B:=TRUE;
ELSE
	bLowFlow2B:=FALSE;
END_IF
IF ( fCoolantFlow2BDisplay>fCoolantFlowMax ) AND bBCoolantSolenoid THEN
	bHighFlow2B:=TRUE;
ELSE
	bHighFlow2B:=FALSE;
END_IF
IF ( fCoolantFlow3BDisplay<fCoolantFlowMin ) AND bBCoolantSolenoid THEN
	bLowFlow3B:=TRUE;
ELSE
	bLowFlow3B:=FALSE;
END_IF
IF ( fCoolantFlow3BDisplay>fCoolantFlowMax ) AND bBCoolantSolenoid THEN
	bHighFlow3B:=TRUE;
ELSE
	bHighFlow3B:=FALSE;
END_IF


(*	Filter Fault Helper *)
IF NOT(bFilter1Dirty) THEN
	nDirtyCount1:=0;
ELSIF bFilter1Dirty AND NOT(bFilter1Timer) THEN
	bFilter1Timer:=TRUE;
END_IF
IF NOT(bFilter2Dirty) THEN
	nDirtyCount2:=0;
ELSIF bFilter2Dirty AND NOT(bFilter2Timer) THEN
	bFilter2Timer:=TRUE;
END_IF
IF NOT(bFilter3Dirty) THEN
	nDirtyCount3:=0;
ELSIF bFilter3Dirty AND NOT(bFilter3Timer) THEN
	bFilter3Timer:=TRUE;
END_IF
IF NOT(bFilter4Dirty) THEN
	nDirtyCount4:=0;
ELSIF bFilter4Dirty AND NOT(bFilter4Timer) THEN
	bFilter4Timer:=TRUE;
END_IF

fbCoolantLevelDelayTOF(IN:=bCleanTankLevel, PT:=t#2s);
(*	Hydraulic Unit On *)
fbHydraulicSystemOnTON(IN:=bHydraulicPowerUnitRunning , PT:=t#1s);
(*	Hydraulic Unit Fluid Level Low Delay *)
fbHydraulicFluidLowTON(IN:=NOT(bHydraulicSystemLevel)
	AND bHydraulicPowerUnitRunning, PT:=t#5s);
(*	Lube Pressure Delayed *)
fbLubePressureTON(IN:= bWayLubePump AND NOT(bLubePressure),
	PT:=t#30m);
(*	Check for Low Lube when at end of cycle *)
fbLubeLevelCheckRTrig(CLK:=(nAutoCycleStep=AC_Unclamp) AND (NOT bLubeLevel));
(* 	Count up when Lube Level is low at the end of a cycle *)
IF fbLubeLevelCheckRTrig.Q THEN
	nLubeLevelLowCount:= nLubeLevelLowCount+1;
(* Reset Count if Lube Level Restored *)
ELSIF bLubeLevel THEN
	nLubeLevelLowCount:=0;
END_IF
(*	Coolant Pressure Low - Side A*)
fbLowPressureFaultADelay(IN:=bACoolantSolenoid AND NOT bACoolantPressure, PT:=t#2000ms);
(*	Coolant Pressure Low - Side B*)
fbLowPressureFaultBDelay(IN:=bBCoolantSolenoid AND NOT bBCoolantPressure, PT:=t#2000ms);

(* Array Assignments:
	nActiveFaults[1] => standard machine faults
	nActiveFaults[2] => Side A Faults
	nActiveFaults[3] => Side B Faults
	nActiveFaults[4] => Specific Faults Like Filter that Do not shut off the machines	*)

CASE nFaultState OF
	0:	(* Check for any faults *)

		IF nActiveFaults[1].0=0 AND NOT( bMCR) THEN
			nActiveFaults[1].0:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F001 - Machine has been in the ESTOP state';
				arrFaultWarningCurrent[nCurrent]:='F001 - Machine has been in the ESTOP state';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].1=0 AND bInCycle
				AND (NOT(bPB4ADrillReturn) OR NOT(bPB4BDrillReturn))
		THEN
			nActiveFaults[1].1:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F002 - Drill Return Activated';
				arrFaultWarningCurrent[nCurrent]:='F002 - Drill Return Activated';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].2=0 AND MAIN.bHighPressureMotorControlError AND MAIN.bHighPressureMotorControl THEN
			nActiveFaults[1].2:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F003 - High Pressure Motor Starter Failed';
				arrFaultWarningCurrent[nCurrent]:='F003 - High Pressure Motor Starter Failed';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].3=0 AND MAIN.bTransferPumpMotorControlError AND MAIN.bTransferPumpMotorControl THEN
			nActiveFaults[1].3:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F004 - Transfer Pump Motor Starter Failed';
				arrFaultWarningCurrent[nCurrent]:='F004 - Transfer Pump Motor Starter Failed';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].4=0 AND (bInCycle OR bSetup) AND NOT(bProx313) THEN
			nActiveFaults[1].4:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F005 - Fixture Door Open Side B';
				arrFaultWarningCurrent[nCurrent]:='F005 - Fixture Door Open Side B';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].5=0 AND ( (NOT(fbCoolantLevelDelayTOF.Q)
			AND fbCoolantStartTimer.Q) OR
			nModeError=Er_CleanTankLow )
		 THEN
			nActiveFaults[1].5:=1;
			IF nModeError=Er_CleanTankLow THEN
				nModeError:=Er_NoModeError;
			END_IF
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F006 - Coolant Tank Level Low';
				arrFaultWarningCurrent[nCurrent]:='F006 - Coolant Tank Level Low';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].6=0 AND fbCoolantTempFaultTON.Q THEN
			nActiveFaults[1].6:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F007 - Coolant Temperature Fault';
				arrFaultWarningCurrent[nCurrent]:='F007 - Coolant Temperature Fault';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].7=0 AND nModeError=Er_CoolantOverflow THEN
			nActiveFaults[1].7:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F008 - Coolant Tank Overflow';
				arrFaultWarningCurrent[nCurrent]:='F008 - Coolant Tank Overflow';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].8=0 AND MAIN.bHydraulicPowerUnitMotorControlError
			AND MAIN.bHydraulicPowerUnitMotorControl
		THEN
			nActiveFaults[1].8:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F009 - Hydraulic Power Unit Motor Starter Failed';
				arrFaultWarningCurrent[nCurrent]:='F009 - Hydraulic Power Unit Motor Starter Failed';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].9=0 AND nModeError=Er_AMUnclampTimeout THEN
			nActiveFaults[1].9:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F010 - Part Unclamp Timeout';
				arrFaultWarningCurrent[nCurrent]:='F010 - Part Unclamped Timeout';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		(* During SETUP Mode an Error occurred with the Clamping *)
		IF nActiveFaults[1].10=0 AND nModeError=Er_SetupError THEN
			nActiveFaults[1].10:=1;
			IF (nFaultArrayIndex<=5) THEN
				CASE nSetupErrorID OF
				1:
					arrFaultMessage[nFaultArrayIndex]:='F011a - Parts Missing';
					arrFaultWarningCurrent[nCurrent]:='F011a - Parts Missing';
				2:
					arrFaultMessage[nFaultArrayIndex]:='F011b - Clamp PS OFF';
					arrFaultWarningCurrent[nCurrent]:='F011b - Clamp PS OFF';
				3:
					arrFaultMessage[nFaultArrayIndex]:='F011c - Unclamp PS ON';
					arrFaultWarningCurrent[nCurrent]:='F011c - Unclamp PS ON';
				END_CASE
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
			nModeError:=Er_NoModeError;
			nSetupErrorID:=0;
		END_IF

		IF nActiveFaults[1].11=0 AND (bInCycle OR bSetup) AND NOT(bProx310) THEN
			nActiveFaults[1].11:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F012 - Tool Change Door Open Side A';
				arrFaultWarningCurrent[nCurrent]:='F012 - Tool Change Door Open Side A';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].12=0 AND (bInCycle OR bSetup) AND NOT(bProx311) THEN
			nActiveFaults[1].12:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F013 - Tool Change Door Open Side B';
				arrFaultWarningCurrent[nCurrent]:='F013 - Tool Change Door Open Side B';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].13=0 AND (bInCycle OR bSetup) AND NOT(bProx312) THEN
			nActiveFaults[1].13:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F014 - Fixture Door Open Side A';
				arrFaultWarningCurrent[nCurrent]:='F014 - Fixture Door Open Side A';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].14=0 AND fbCycleCommonTimeout.Q THEN
			nActiveFaults[1].14:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F015 - Cycle Start or Common Button Held Too Long';
				arrFaultWarningCurrent[nCurrent]:='F015 - Cycle Start or Common Button Held Too Long';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].15=0 AND nModeError=Er_CoolantOff THEN
			nModeError:=Er_NoModeError;
			nActiveFaults[1].15:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F016 - Coolant System Must Be On';
				arrFaultWarningCurrent[nCurrent]:='F016 - Coolant System Must Be On';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].16=0 AND nModeError=Er_VFDUpToSpeedTimeout THEN
			nModeError:=Er_NoModeError;
			nActiveFaults[1].16:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F017 - VFDs Not Up To Speed In Time';
				arrFaultWarningCurrent[nCurrent]:='F017 - VFDs Not Up To Speed In Time';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].17=0 AND nModeError=Er_AMCoolantTimeout THEN
			nActiveFaults[1].17:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F018 - Coolant Up To Pressure Timeout';
				arrFaultWarningCurrent[nCurrent]:='F018 - Coolant Up To Pressure Timeout';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		(* If the MPG is moving the WA Axis we limit the Max Thrust for safety *)
		IF nActiveFaults[1].18=0 AND P_MPGControl.fbMPGWAAxisGearIn.InGear AND
			(ABS(nWAAxisThrust)/10 > 150)
		THEN
			bWAStop:=TRUE;	(* Stop the Axis *)
			nActiveFaults[1].18:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F019 - WA Max Thrust Exceeded';
				arrFaultWarningCurrent[nCurrent]:='F019 - WA Max Thrust Exceeded';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		(* If the MPG is moving the WA Axis limit Max Thrust to 65% for some safety *)
		IF nActiveFaults[1].19=0 AND P_MPGControl.fbMPGWBAxisGearIn.InGear AND
			ABS(nWBAxisThrust/10 > 150)
		THEN
			bWBStop:=TRUE;	(* Stop the Axis *)
			nActiveFaults[1].19:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F020 - WB Max Thrust Exceeded';
				arrFaultWarningCurrent[nCurrent]:='F020 - WB Max Thrust Exceeded';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].20=0 AND nUAxisThrust/10 > nUAxisThrustMax
			AND NOT P_MPGControl.fbMPGUAAxisGearIn.InGear
			AND NOT P_MPGControl.fbMPGXBAxisGearIn.InGear
		THEN
			nActiveFaults[1].20:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F021 - X Axis Max Thrust Exceeded';
				arrFaultWarningCurrent[nCurrent]:='F021 - X Axis Max Thrust Exceeded';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].21=0 AND nModeError=Er_TransferSolError THEN
			nModeError:=Er_NoModeError;
			nActiveFaults[1].21:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F022 - Both Up and Down Solenoids On At Same Time';
				arrFaultWarningCurrent[nCurrent]:='F022 - Both Up and Down Solenoids On At Same Time';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

			IF nActiveFaults[1].22=0 AND bRack3Comm THEN
				nActiveFaults[1].22:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F023 - Com. Lost to Rack 3 Input Module';
					arrFaultWarningCurrent[nCurrent]:='F023 - Com. Lost to Rack 3 Input Module';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[1].23=0 AND bRack4Comm THEN
				nActiveFaults[1].23:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F024 - Com. Lost to Rack 4 Input Module';
					arrFaultWarningCurrent[nCurrent]:='F024 - Com. Lost to Rack 4 Input Module';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[1].24=0 AND bRack5Comm THEN
				nActiveFaults[1].24:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F025 - Com. Lost to Rack 5 Input Module';
					arrFaultWarningCurrent[nCurrent]:='F025 - Com. Lost to Rack 5 Input Module';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

		IF nActiveFaults[1].25=0 AND nModeError=Er_MPG_A_Active
		THEN
			nActiveFaults[1].25:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F026 - MPG Side A Selector Must be OFF';
				arrFaultWarningCurrent[nCurrent]:='F026 - MPG Side A Selector Must be OFF';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].26=0 AND nModeError=Er_MPG_B_Active THEN
			nActiveFaults[1].26:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F027 - MPG Side B Selector Must be OFF';
				arrFaultWarningCurrent[nCurrent]:='F027 - MPG Side B Selector Must be OFF';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].27=0 AND bXAAxisSelected AND bXBAxisSelected THEN
			nActiveFaults[1].27:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F028 - MPG A Side and B Side Both Selected X Axis';
				arrFaultWarningCurrent[nCurrent]:='F028 - MPG A Side and B Side Both Selected X Axis';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].28=0 AND stUAxis.Status.Error  THEN
			nActiveFaults[1].28:=1;
			IF (nFaultArrayIndex<=5) THEN
				IF nUAxisDiagNumber=64720 THEN
					arrFaultMessage[nFaultArrayIndex]:='F029a - X Positive Overtravel - (+) Motion Disabled';
					arrFaultWarningCurrent[nCurrent]:='F029a - X Positive Overtravel - (+) Motion Disabled';
				ELSIF nUAxisDiagNumber=64721 THEN
					arrFaultMessage[nFaultArrayIndex]:='F029b - X Negative Overtravel - (-) Motion Disabled';
					arrFaultWarningCurrent[nCurrent]:='F029b - X Negative Overtravel - (-) Motion Disabled';
				ELSE
					arrFaultMessage[nFaultArrayIndex]:=CONCAT('F029 - Servo X Axis Fault# ',
							UDINT_TO_STRING(stUAxis.Status.ErrorID));
					arrFaultWarningCurrent[nCurrent]:=CONCAT('F029 - Servo X Axis Fault# ',
							UDINT_TO_STRING(stUAxis.Status.ErrorID));
				END_IF
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].29=0 AND nModeError=Er_HomeTimeout THEN
			nActiveFaults[1].29:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F030 - Automation Homing Did not Finish in Anticipated Time';
				arrFaultWarningCurrent[nCurrent]:='F030 - Automation Homing Did not Finish in Anticipated Time';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[1].30=0 AND nModeError=Er_MaxCyclesReached THEN
			nActiveFaults[1].30:=1;
			nModeError:=Er_NoModeError;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F031 - Max Cycles Reached';
				arrFaultWarningCurrent[nCurrent]:='F031 - Max Cycles Reached';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		(***** TRANSFER FAULTS ****
		The text of the fault comes from the the TransferCycle Action of the P_TransferControl (PGM). 
			We assign the 100 series to the warnings by concating a W1 to the beginning of the text.  
			This allows us to assign the Warning series of numbers in an effort to make it more modular.  
			You must go to the function block to see the rest of the number and the description text of the fault. f
			Generally this is at the bottom of the function block or program section. 
			ErrorID < 50 is a WARNING and ErrorID >= 50 are Faults
			If this is reused in a different machine we want to make sure we assign the appropriate #series to the warnings.  *)

		IF nActiveFaults[1].31=0 AND bTransferError  AND nTransferErrorID >= 50THEN
			nActiveFaults[1].31:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:=CONCAT('F1',sTransferErrorText);
				arrFaultWarningCurrent[nCurrent]:=CONCAT('F1',sTransferErrorText);
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

	(* 	SIDE A FAULTS
		The text of the fault comes from the function block "Side_A_Fixture" and we assign the hundreds series # to it below.
		Example: Side A Fixture has F2 is concated to the front of the text so that they are 200 series faults
				Side B fixture has F3 concated to make them 300 series faults..  
		You must go to the function block to see the rest of the number and the description text of the fault. 
		Generally this is at the bottom of the function block. *)
		IF bSideAEnabled THEN
			(* Tailstock Side A *)
			IF nActiveFaults[2].0=0 AND Side_A_Fixture.bError THEN
				nActiveFaults[2].0:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:=CONCAT('F2',Side_A_Fixture.sErrorText);
						arrFaultMessage[nFaultArrayIndex]:=CONCAT(arrFaultMessage[nFaultArrayIndex],' Side A');
					arrFaultWarningCurrent[nCurrent]:=CONCAT('F2',Side_A_Fixture.sErrorText);
						arrFaultWarningCurrent[nCurrent]:=CONCAT(arrFaultWarningCurrent[nCurrent],' Side A');
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].1=0 AND bACoolantSolenoid
				AND bLowFlow1A AND NOT(fCoolantFlowMin<0.5)
				AND fbFlowAverageTimer1ALOW.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[2].1:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F230 - Coolant Flow Below Min #1A';
					arrFaultWarningCurrent[nCurrent]:='F230 - Coolant Flow Below Min #1A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].2=0 AND bACoolantSolenoid
				AND bHighFlow1A AND NOT(fCoolantFlowMax=60)
				AND fbFlowAverageTimer1AHIGH.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[2].2:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F231 - Coolant Flow Exceeded Max #1A';
					arrFaultWarningCurrent[nCurrent]:='F231 - Coolant Flow Exceeded Max #1A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].3=0 AND bACoolantSolenoid
				AND bLowFlow2A AND NOT(fCoolantFlowMin<0.5)
				AND fbFlowAverageTimer2ALOW.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[2].3:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F232 - Coolant Flow Below Min #2A';
					arrFaultWarningCurrent[nCurrent]:='F232 - Coolant Flow Below Min #2A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].4=0 AND bACoolantSolenoid
				AND bHighFlow2A AND NOT(fCoolantFlowMax=60)
				AND fbFlowAverageTimer2AHIGH.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[2].4:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F233 - Coolant Flow Exceeded Max #2A';
					arrFaultWarningCurrent[nCurrent]:='F233 - Coolant Flow Exceeded Max #2A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].5=0 AND bACoolantSolenoid
				AND bLowFlow3A AND NOT(fCoolantFlowMin<0.5)
				AND fbFlowAverageTimer3ALOW.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[2].5:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F234 - Coolant Flow Below Min #3A';
					arrFaultWarningCurrent[nCurrent]:='F234 - Coolant Flow Below Min #3A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
			IF nActiveFaults[2].6=0 AND bACoolantSolenoid
				AND bHighFlow3A AND NOT(fCoolantFlowMax=60)
				AND fbFlowAverageTimer3AHIGH.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[2].6:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F235 - Coolant Flow Exceeded Max #3A';
					arrFaultWarningCurrent[nCurrent]:='F235 - Coolant Flow Exceeded Max #3A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].7=0 AND NOT(nServoThrustMax=0) AND fbServoAThrustMaxDelayTON.Q
				AND bInCycle AND NOT(stZAAxis.Status.InPositionArea) AND (stZAAxis.NcToPlc.AxisState=3) THEN
				nActiveFaults[2].7:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F236 - Servo ZA Thrust Exceeded Max';
					arrFaultWarningCurrent[nCurrent]:='F236 - Servo  ZAThrust Exceeded Max';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].8=0 AND stZAAxis.Status.Error  THEN
				nActiveFaults[2].8:=1;
				IF (nFaultArrayIndex<=5) THEN
 					IF nZAAxisDiagNumber=64720 THEN
						arrFaultMessage[nFaultArrayIndex]:='F237a - ZA Negative Overtravel - (-) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F237a - ZA Negative Overtravel - (-) Motion Disabled';
					ELSIF nZAAxisDiagNumber=64721 THEN
						arrFaultMessage[nFaultArrayIndex]:='F237b - ZA  Positive Overtravel - (+) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F237b - ZA Positive Overtravel - (+) Motion Disabled';
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F237 - Servo ZA Axis Fault# ',
								UDINT_TO_STRING(stZAAxis.Status.ErrorID));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F237 - Servo ZA Axis Fault# ',
								UDINT_TO_STRING(stZAAxis.Status.ErrorID));
					END_IF
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].9=0 AND stWAAxis.Status.Error  THEN
				nActiveFaults[2].9:=1;
				IF (nFaultArrayIndex<=5) THEN
 					IF nWAAxisDiagNumber=64720 THEN
						arrFaultMessage[nFaultArrayIndex]:='F238a - WA Negative Overtravel - (-) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F238a - WA Negative Overtravel - (-) Motion Disabled';
					ELSIF nWAAxisDiagNumber=64721 THEN
						arrFaultMessage[nFaultArrayIndex]:='F238b - WA  Positive Overtravel - (+) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F238b - WA  Positive Overtravel - (+) Motion Disabled';
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F238 - Servo WA Axis Fault# ',
							UDINT_TO_STRING(stWAAxis.Status.ErrorID));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F238 - Servo WA Axis Fault# ',
							UDINT_TO_STRING(stWAAxis.Status.ErrorID));
					END_IF
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].10=0 AND fbWAAxisHome.Error  THEN
				nActiveFaults[2].10:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F239 - Tailstock WA Homing Error';
					arrFaultWarningCurrent[nCurrent]:='F239 - Tailstock WA Homing Error';;
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].11=0 AND nSpindleLoad1ADisplay>nSpindleLoadMax AND NOT(nSpindleLoadMax=0)
				AND bVFD_ARun AND bVFD_A1UpToSpeed AND fbALoadFaultDelay.Q THEN
				 nActiveFaults[2].11:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F240 - Spindle #1A Max Load Exceeded';
					arrFaultWarningCurrent[nCurrent]:='F240 - Spindle #1A Max Load Exceeded';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
	
			IF nActiveFaults[2].12=0 AND nSpindleLoad2ADisplay>nSpindleLoadMax AND NOT(nSpindleLoadMax=0)
				AND bVFD_ARun AND bVFD_A2UpToSpeed AND fbALoadFaultDelay.Q THEN
				 nActiveFaults[2].12:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F241 - Spindle #2A Max Load Exceeded';
					arrFaultWarningCurrent[nCurrent]:='F241 - Spindle #2A Max Load Exceeded';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].13=0 AND nSpindleLoad3ADisplay>nSpindleLoadMax AND NOT(nSpindleLoadMax=0)
				AND bVFD_ARun AND bVFD_A3UpToSpeed AND fbALoadFaultDelay.Q THEN
				 nActiveFaults[2].13:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F242 - Spindle #3A Max Load Exceeded';
					arrFaultWarningCurrent[nCurrent]:='F242 - Spindle #3A Max Load Exceeded';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

		(* Spares - Future Spindles *)

			IF nActiveFaults[2].18=0 AND fbVFD_A1.bError THEN
			(*	Encompasses ALL VFD related Errors *)
			(* uptospeed, drivenotready, drivefaulted, drivewarning, drivecomm *)
				nActiveFaults[2].18:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF fbVFD_A1.nErrorID=Er_DriveComm THEN
						arrFaultMessage[nFaultArrayIndex]:='F243a - Spindle #1A VFD Communcation Failed';
						arrFaultWarningCurrent[nCurrent]:='F243a - Spindle #1A VFD Communcation Failed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A1.nErrorID=Er_DriveFaulted THEN
						arrFaultMessage[nFaultArrayIndex]:='F243b - Spindle #1A VFD Fault';
						arrFaultWarningCurrent[nCurrent]:='F243b - Spindle #1A VFD Fault';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A1.nErrorID=Er_DriveWarning THEN
						arrFaultMessage[nFaultArrayIndex]:='F243c - Spindle #1A VFD Warning';
						arrFaultWarningCurrent[nCurrent]:='F243c - Spindle #1A VFD Warning';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A1.nErrorID=Er_DriveNotReady THEN
						arrFaultMessage[nFaultArrayIndex]:='F243d - Spindle #1A VFD Not Ready';
						arrFaultWarningCurrent[nCurrent]:='F243d - Spindle #1A VFD Not Ready';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A1.nErrorID=Er_InvalidRPM THEN
						arrFaultMessage[nFaultArrayIndex]:='F243e - Spindle #1A VFD Invalid RPM Requested';
						arrFaultWarningCurrent[nCurrent]:='F243e - Spindle #1A VFD Invalid RPM Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A1.nErrorID=Er_InvalidRatio THEN
						arrFaultMessage[nFaultArrayIndex]:='F243f - Spindle #1A VFD Invalid Motor to Spindle Ratio Requested';
						arrFaultWarningCurrent[nCurrent]:='F243f - Spindle #1A VFD Invalid Motor to Spindle Ratio Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A1.nErrorID=Er_InvalidOverride THEN
						arrFaultMessage[nFaultArrayIndex]:='F243g - Spindle #1A VFD Invalid Override Requested';
						arrFaultWarningCurrent[nCurrent]:='F243g - Spindle #1A VFD Invalid Override Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A1.nErrorID=Er_UpToSpeedTimeout THEN
						arrFaultMessage[nFaultArrayIndex]:='F243h - Spindle #1A VFD Not Up To Speed';
						arrFaultWarningCurrent[nCurrent]:='F243h - Spindle #1A VFD Not Up To Speed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F243 - Spindle #1A VFD Error : ',
												UDINT_TO_STRING(fbVFD_A1.stVFDInfo.nActiveFault));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F243 - Spindle #1A VFD Error : ',
												UDINT_TO_STRING(fbVFD_A1.stVFDInfo.nActiveFault));
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					END_IF
				END_IF
			END_IF

			IF nActiveFaults[2].19=0 AND fbVFD_A2.bError THEN
			(*	Encompasses ALL VFD related Errors *)
			(* uptospeed, drivenotready, drivefaulted, drivewarning, drivecomm *)
				nActiveFaults[2].19:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF fbVFD_A2.nErrorID=Er_DriveComm THEN
						arrFaultMessage[nFaultArrayIndex]:='F244a - Spindle #2A VFD Communcation Failed';
						arrFaultWarningCurrent[nCurrent]:='F244a - Spindle #2A VFD Communcation Failed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A2.nErrorID=Er_DriveFaulted THEN
						arrFaultMessage[nFaultArrayIndex]:='F244b - Spindle #2A VFD Fault';
						arrFaultWarningCurrent[nCurrent]:='F244b - Spindle #2A VFD Fault';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A2.nErrorID=Er_DriveWarning THEN
						arrFaultMessage[nFaultArrayIndex]:='F244c - Spindle #2A VFD Warning';
						arrFaultWarningCurrent[nCurrent]:='F244c - Spindle #2A VFD Warning';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A2.nErrorID=Er_DriveNotReady THEN
						arrFaultMessage[nFaultArrayIndex]:='F244d - Spindle #2A VFD Not Ready';
						arrFaultWarningCurrent[nCurrent]:='F244d - Spindle #2A VFD Not Ready';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A2.nErrorID=Er_InvalidRPM THEN
						arrFaultMessage[nFaultArrayIndex]:='F244e - Spindle #2A VFD Invalid RPM Requested';
						arrFaultWarningCurrent[nCurrent]:='F244e - Spindle #2A VFD Invalid RPM Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A2.nErrorID=Er_InvalidRatio THEN
						arrFaultMessage[nFaultArrayIndex]:='F244f - Spindle #2A VFD Invalid Motor to Spindle Ratio Requested';
						arrFaultWarningCurrent[nCurrent]:='F244f - Spindle #2A VFD Invalid Motor to Spindle Ratio Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A2.nErrorID=Er_InvalidOverride THEN
						arrFaultMessage[nFaultArrayIndex]:='F244g - Spindle #2A VFD Invalid Override Requested';
						arrFaultWarningCurrent[nCurrent]:='F244g - Spindle #2A VFD Invalid Override Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A2.nErrorID=Er_UpToSpeedTimeout THEN
						arrFaultMessage[nFaultArrayIndex]:='F244h - Spindle #2A VFD Not Up To Speed';
						arrFaultWarningCurrent[nCurrent]:='F244h - Spindle #2A VFD Not Up To Speed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F244 - Spindle #2A VFD Error : ',
												UDINT_TO_STRING(fbVFD_A2.stVFDInfo.nActiveFault));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F244 - Spindle #2A VFD Error : ',
												UDINT_TO_STRING(fbVFD_A2.stVFDInfo.nActiveFault));
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					END_IF
				END_IF
			END_IF

			IF nActiveFaults[2].20=0 AND fbVFD_A3.bError THEN
			(*	Encompasses ALL VFD related Errors *)
			(* uptospeed, drivenotready, drivefaulted, drivewarning, drivecomm *)
				nActiveFaults[2].20:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF fbVFD_A3.nErrorID=Er_DriveComm THEN
						arrFaultMessage[nFaultArrayIndex]:='F245a - Spindle #3A VFD Communcation Failed';
						arrFaultWarningCurrent[nCurrent]:='F245a - Spindle #3A VFD Communcation Failed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A3.nErrorID=Er_DriveFaulted THEN
						arrFaultMessage[nFaultArrayIndex]:='F245b - Spindle #3A VFD Fault';
						arrFaultWarningCurrent[nCurrent]:='F245b - Spindle #3A VFD Fault';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A3.nErrorID=Er_DriveWarning THEN
						arrFaultMessage[nFaultArrayIndex]:='F245c - Spindle #3A VFD Warning';
						arrFaultWarningCurrent[nCurrent]:='F245c - Spindle #3A VFD Warning';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A3.nErrorID=Er_DriveNotReady THEN
						arrFaultMessage[nFaultArrayIndex]:='F245d - Spindle #3A VFD Not Ready';
						arrFaultWarningCurrent[nCurrent]:='F245d - Spindle #3A VFD Not Ready';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A3.nErrorID=Er_InvalidRPM THEN
						arrFaultMessage[nFaultArrayIndex]:='F245e - Spindle #3A VFD Invalid RPM Requested';
						arrFaultWarningCurrent[nCurrent]:='F245e - Spindle #3A VFD Invalid RPM Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A3.nErrorID=Er_InvalidRatio THEN
						arrFaultMessage[nFaultArrayIndex]:='F245f - Spindle #3A VFD Invalid Motor to Spindle Ratio Requested';
						arrFaultWarningCurrent[nCurrent]:='F245f - Spindle #3A VFD Invalid Motor to Spindle Ratio Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A3.nErrorID=Er_InvalidOverride THEN
						arrFaultMessage[nFaultArrayIndex]:='F245g - Spindle #3A VFD Invalid Override Requested';
						arrFaultWarningCurrent[nCurrent]:='F245g - Spindle #3A VFD Invalid Override Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_A3.nErrorID=Er_UpToSpeedTimeout THEN
						arrFaultMessage[nFaultArrayIndex]:='F245h - Spindle #3A VFD Not Up To Speed';
						arrFaultWarningCurrent[nCurrent]:='F245h - Spindle #3A VFD Not Up To Speed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F245 - Spindle #3A VFD Error : ',
												UDINT_TO_STRING(fbVFD_A3.stVFDInfo.nActiveFault));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F245 - Spindle #3A VFD Error : ',
												UDINT_TO_STRING(fbVFD_A3.stVFDInfo.nActiveFault));
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					END_IF
				END_IF
			END_IF

			(* Coolant Pressure Fault for Auto Mode *)
			IF nActiveFaults[2].21=0 AND fbLowPressureFaultADelay.Q
				AND bMachineMode
			THEN
				nActiveFaults[2].21:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F246 - Coolant Pressure Low - Side A';
					arrFaultWarningCurrent[nCurrent]:='F246 - Coolant Pressure Low - Side A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].22=0 AND fbSpeedVariationTimer1AHIGH.Q
				AND bVFD_ARun  AND bVFD_A1UpToSpeed AND (bInCycle OR bSetupA)
				AND fbASpeedDelayTimer.Q THEN
				nActiveFaults[2].22:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F247 - Spindle Speed Not Correct #1A (HIGH)';
					arrFaultWarningCurrent[nCurrent]:='F247 - Spindle Speed Not Correct #1A (HIGH)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].23=0 AND fbSpeedVariationTimer1ALOW.Q
				AND bVFD_ARun AND bVFD_A1UpToSpeed AND (bInCycle OR bSetupA)
				AND fbASpeedDelayTimer.Q THEN
				nActiveFaults[2].23:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F248 - Spindle Speed Not Correct #1A (LOW)';
					arrFaultWarningCurrent[nCurrent]:='F248 - Spindle Speed Not Correct #1A (LOW)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
	
			IF nActiveFaults[2].24=0 AND fbSpeedVariationTimer2AHIGH.Q
				AND bVFD_ARun  AND bVFD_A2UpToSpeed AND (bInCycle OR bSetupA)
				AND fbASpeedDelayTimer.Q THEN
				nActiveFaults[2].24:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F249 - Spindle Speed Not Correct #2A (HIGH)';
					arrFaultWarningCurrent[nCurrent]:='F249 - Spindle Speed Not Correct #2A (HIGH)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
			IF nActiveFaults[2].25=0 AND fbSpeedVariationTimer2ALOW.Q
				AND bVFD_ARun AND bVFD_A2UpToSpeed AND (bInCycle OR bSetupA)
				AND fbASpeedDelayTimer.Q THEN
				nActiveFaults[2].25:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F250 - Spindle Speed Not Correct #2A (LOW)';
					arrFaultWarningCurrent[nCurrent]:='F250- Spindle Speed Not Correct #2A (LOW)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
	
			IF nActiveFaults[2].26=0 AND fbSpeedVariationTimer3AHIGH.Q
				AND bVFD_ARun  AND bVFD_A3UpToSpeed AND (bInCycle OR bSetupA)
				AND fbASpeedDelayTimer.Q THEN
				nActiveFaults[2].26:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F251 - Spindle Speed Not Correct #3A (HIGH)';
					arrFaultWarningCurrent[nCurrent]:='F251 - Spindle Speed Not Correct #3A (HIGH)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].27=0 AND fbSpeedVariationTimer3ALOW.Q
				AND bVFD_ARun AND bVFD_A3UpToSpeed AND (bInCycle OR bSetupA)
				AND fbASpeedDelayTimer.Q THEN
				nActiveFaults[2].27:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F252 - Spindle Speed Not Correct #3A (LOW)';
					arrFaultWarningCurrent[nCurrent]:='F252 - Spindle Speed Not Correct #3A (LOW)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].28=0 AND nModeError=Er_SideAColletSolError THEN
				nModeError:=Er_NoModeError;
				nActiveFaults[2].28:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F253 - Both A Clamp and UnClamp Solenoids On At Same Time';
					arrFaultWarningCurrent[nCurrent]:='F253 - Both A Clamp and UnClamp Solenoids On At Same Time';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].29=0 AND nModeError=Er_SideAEjectorsSolError THEN
				nModeError:=Er_NoModeError;
				nActiveFaults[2].29:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F254 - Both A Ejector Advance  and Retract Solenoids On At Same Time';
					arrFaultWarningCurrent[nCurrent]:='F254 - Both A Ejector Advance  and Retract Solenoids On At Same Time';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[2].30=0 AND bRack6Comm THEN
				nActiveFaults[2].30:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F255 - Com. Lost to Side A Tailstock Input Module';
					arrFaultWarningCurrent[nCurrent]:='F255 - Com. Lost to Side A Tailstock Input Module';;
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			(* If we lose Side A Clamp PS In the AutoCycle between AC_Clamp and AC_Unclamp we Fault *)
			IF nActiveFaults[2].31=0 AND (nAutoCycleStep > AC_Clamp) AND ( nAutoCycleStep < AC_Unclamp) AND
				NOT bPS617
			THEN
				nActiveFaults[2].31:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F256 - Clamp Pressure Lost - Side A';
					arrFaultWarningCurrent[nCurrent]:='F256 - Clamp Pressure Lost - Side A';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

		END_IF (*	Side A Faults *)

	(* 	SIDE B FAULTS
		The text of the fault comes from the function block "Side_B_Fixture" and we assign the hundreds series # to it below.
		Example: Side A Fixture has F2 is concated to the front of the text so that they are 200 series faults
				Side B fixture has F3 concated to make them 300 series faults..  
		You must go to the function block to see the rest of the number and the description text of the fault. 
		Generally this will be at the bottom of the function block. 	*)
		IF bSideBEnabled THEN
			(* Tailstock Side A *)
			IF nActiveFaults[3].0=0 AND Side_B_Fixture.bError THEN
				nActiveFaults[3].0:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:=CONCAT('F3',Side_B_Fixture.sErrorText);
						arrFaultMessage[nFaultArrayIndex]:=CONCAT(arrFaultMessage[nFaultArrayIndex],' Side B');
					arrFaultWarningCurrent[nCurrent]:=CONCAT('F3',Side_B_Fixture.sErrorText);
						arrFaultWarningCurrent[nCurrent]:=CONCAT(arrFaultWarningCurrent[nCurrent],' Side B');
					nCurrent:=nCurrent+1;
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].1=0 AND bBCoolantSolenoid
				AND bLowFlow1B AND NOT(fCoolantFlowMin<0.5)
				AND fbFlowAverageTimer1BLOW.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[3].1:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F330 - Coolant Flow Below Min #1B';
					arrFaultWarningCurrent[nCurrent]:='F330 - Coolant Flow Below Min #1B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
			IF nActiveFaults[3].2=0 AND bBCoolantSolenoid
				AND bHighFlow1B AND NOT(fCoolantFlowMax=60)
				AND fbFlowAverageTimer1BHIGH.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[3].2:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F331 - Coolant Flow Exceeded Max #1B';
					arrFaultWarningCurrent[nCurrent]:='F331 - Coolant Flow Exceeded Max #1B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].3=0 AND bBCoolantSolenoid
				AND bLowFlow2B AND NOT(fCoolantFlowMin<0.5)
				AND fbFlowAverageTimer2BLOW.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[3].3:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F332 - Coolant Flow Below Min #2B';
					arrFaultWarningCurrent[nCurrent]:='F332 - Coolant Flow Below Min #2B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
			IF nActiveFaults[3].4=0 AND bBCoolantSolenoid
				AND bHighFlow2B AND NOT(fCoolantFlowMax=60)
				AND fbFlowAverageTimer2BHIGH.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[3].4:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F333 - Coolant Flow Exceeded Max #2B';
					arrFaultWarningCurrent[nCurrent]:='F333 - Coolant Flow Exceeded Max #2B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].5=0 AND bBCoolantSolenoid
				AND bLowFlow3B AND NOT(fCoolantFlowMin<0.5)
				AND fbFlowAverageTimer3BLOW.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[3].5:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F334 - Coolant Flow Below Min #3B';
					arrFaultWarningCurrent[nCurrent]:='F334 - Coolant Flow Below Min #3B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
			IF nActiveFaults[3].6=0 AND bBCoolantSolenoid
				AND bHighFlow3B AND NOT(fCoolantFlowMax=60)
				AND fbFlowAverageTimer3BHIGH.Q AND fbCoolantOnDelayTON.Q
			THEN
				nActiveFaults[3].6:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F335 - Coolant Flow Exceeded Max #3B';
					arrFaultWarningCurrent[nCurrent]:='F335 - Coolant Flow Exceeded Max #3B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].7=0 AND NOT(nServoThrustMax=0) AND fbServoBThrustMaxDelayTON.Q
				AND bInCycle AND NOT(stZBAxis.Status.InPositionArea) AND (stZBAxis.NcToPlc.AxisState=3) THEN
				nActiveFaults[3].7:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F336 - Servo ZB Thrust Exceeded Max';
					arrFaultWarningCurrent[nCurrent]:='F336 - Servo  ZBThrust Exceeded Max';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].8=0 AND stZBAxis.Status.Error  THEN
				nActiveFaults[3].8:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF nZBAxisDiagNumber=64720 THEN
						arrFaultMessage[nFaultArrayIndex]:='F337a - ZB Negative Overtravel - (-) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F337a - ZB Negative Overtravel - (-) Motion Disabled';
					ELSIF nZBAxisDiagNumber=64721 THEN
						arrFaultMessage[nFaultArrayIndex]:='F337b - ZB Positive Overtravel - (+) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F337b - ZB Positive Overtravel - (+) Motion Disabled';
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F337 - Servo ZB Axis Fault# ',
							UDINT_TO_STRING(stZBAxis.Status.ErrorID));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F337 - Servo ZB Axis Fault# ',
							UDINT_TO_STRING(stZBAxis.Status.ErrorID));
					END_IF
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].9=0 AND stWBAxis.Status.Error  THEN
				nActiveFaults[3].9:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF nWBAxisDiagNumber=64720 THEN
						arrFaultMessage[nFaultArrayIndex]:='F338a - WB Negative Overtravel - (-) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F338a - WB Negative Overtravel - (-) Motion Disabled';
					ELSIF nWBAxisDiagNumber=64721 THEN
						arrFaultMessage[nFaultArrayIndex]:='F338b - WB Positive Overtravel - (+) Motion Disabled';
						arrFaultWarningCurrent[nCurrent]:='F338b - WB Positive Overtravel - (+) Motion Disabled';
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F338 - Servo WB Axis Fault# ',
							UDINT_TO_STRING(stWBAxis.Status.ErrorID));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F338 - Servo WB Axis Fault# ',
							UDINT_TO_STRING(stWBAxis.Status.ErrorID));
					END_IF
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].10=0 AND fbHomeWB.Error  THEN
				nActiveFaults[3].10:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F339 - Tailstock WB Homing Error';
					arrFaultWarningCurrent[nCurrent]:='F339 - Tailstock WB Homing Error';;
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].11=0 AND nSpindleLoad1BDisplay>nSpindleLoadMax AND NOT(nSpindleLoadMax=0)
				AND bVFD_BRun AND bVFD_B1UpToSpeed AND fbBLoadFaultDelay.Q THEN
				 nActiveFaults[3].11:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F340 - Spindle #1B Max Load Exceeded';
					arrFaultWarningCurrent[nCurrent]:='F340 - Spindle #1B Max Load Exceeded';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].12=0 AND nSpindleLoad2BDisplay>nSpindleLoadMax AND NOT(nSpindleLoadMax=0)
				AND bVFD_BRun AND bVFD_B2UpToSpeed AND fbBLoadFaultDelay.Q THEN
				 nActiveFaults[3].12:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F341 - Spindle #2B Max Load Exceeded';
					arrFaultWarningCurrent[nCurrent]:='F341 - Spindle #2B Max Load Exceeded';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].13=0 AND nSpindleLoad3BDisplay>nSpindleLoadMax AND NOT(nSpindleLoadMax=0)
				AND bVFD_BRun AND bVFD_B3UpToSpeed AND fbBLoadFaultDelay.Q THEN
				 nActiveFaults[3].13:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F342 - Spindle #3B Max Load Exceeded';
					arrFaultWarningCurrent[nCurrent]:='F342 - Spindle #3B Max Load Exceeded';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

	(* Spares *)

			IF nActiveFaults[3].18=0 AND fbVFD_B1.bError THEN
			(*	Encompasses ALL VFD related Errors *)
			(* uptospeed, drivenotready, drivefaulted, drivewarning, drivecomm *)
				nActiveFaults[3].18:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF fbVFD_B1.nErrorID=Er_DriveComm THEN
						arrFaultMessage[nFaultArrayIndex]:='F343a - Spindle #1B VFD Communcation Failed';
						arrFaultWarningCurrent[nCurrent]:='F343a - Spindle #1B VFD Communcation Failed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B1.nErrorID=Er_DriveFaulted THEN
						arrFaultMessage[nFaultArrayIndex]:='F343b - Spindle #1B VFD Fault';
						arrFaultWarningCurrent[nCurrent]:='F343b - Spindle #1B VFD Fault';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B1.nErrorID=Er_DriveWarning THEN
						arrFaultMessage[nFaultArrayIndex]:='F343c - Spindle #1B VFD Warning';
						arrFaultWarningCurrent[nCurrent]:='F343c - Spindle #1B VFD Warning';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B1.nErrorID=Er_DriveNotReady THEN
						arrFaultMessage[nFaultArrayIndex]:='F343d - Spindle #1B VFD Not Ready';
						arrFaultWarningCurrent[nCurrent]:='F343d - Spindle #1B VFD Not Ready';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B1.nErrorID=Er_InvalidRPM THEN
						arrFaultMessage[nFaultArrayIndex]:='F343e - Spindle #1B VFD Invalid RPM Requested';
						arrFaultWarningCurrent[nCurrent]:='F343e - Spindle #1B VFD Invalid RPM Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B1.nErrorID=Er_InvalidRatio THEN
						arrFaultMessage[nFaultArrayIndex]:='F343f - Spindle #1B VFD Invalid Motor to Spindle Ratio Requested';
						arrFaultWarningCurrent[nCurrent]:='F343f - Spindle #1B VFD Invalid Motor to Spindle Ratio Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B1.nErrorID=Er_InvalidOverride THEN
						arrFaultMessage[nFaultArrayIndex]:='F343g - Spindle #1B VFD Invalid Override Requested';
						arrFaultWarningCurrent[nCurrent]:='F343g - Spindle #1B VFD Invalid Override Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B1.nErrorID=Er_UpToSpeedTimeout THEN
						arrFaultMessage[nFaultArrayIndex]:='F343h - Spindle #1B VFD Not Up To Speed';
						arrFaultWarningCurrent[nCurrent]:='F343h - Spindle #1B VFD Not Up To Speed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F343 - Spindle #1B VFD Error : ',
												UDINT_TO_STRING(fbVFD_B1.stVFDInfo.nActiveFault));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F343 - Spindle #1B VFD Error : ',
												UDINT_TO_STRING(fbVFD_B1.stVFDInfo.nActiveFault));
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					END_IF
				END_IF
			END_IF

			IF nActiveFaults[3].19=0 AND fbVFD_B2.bError THEN
			(*	Encompasses ALL VFD related Errors *)
			(* uptospeed, drivenotready, drivefaulted, drivewarning, drivecomm *)
				nActiveFaults[3].19:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF fbVFD_B2.nErrorID=Er_DriveComm THEN
						arrFaultMessage[nFaultArrayIndex]:='F344a - Spindle #2B VFD Communcation Failed';
						arrFaultWarningCurrent[nCurrent]:='F344a - Spindle #2B VFD Communcation Failed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B2.nErrorID=Er_DriveFaulted THEN
						arrFaultMessage[nFaultArrayIndex]:='F344b - Spindle #2B VFD Fault';
						arrFaultWarningCurrent[nCurrent]:='F344b - Spindle #2B VFD Fault';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B2.nErrorID=Er_DriveWarning THEN
						arrFaultMessage[nFaultArrayIndex]:='F344c - Spindle #2B VFD Warning';
						arrFaultWarningCurrent[nCurrent]:='F344c - Spindle #2B VFD Warning';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B2.nErrorID=Er_DriveNotReady THEN
						arrFaultMessage[nFaultArrayIndex]:='F344d - Spindle #2B VFD Not Ready';
						arrFaultWarningCurrent[nCurrent]:='F344d - Spindle #2B VFD Not Ready';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B2.nErrorID=Er_InvalidRPM THEN
						arrFaultMessage[nFaultArrayIndex]:='F344e - Spindle #2B VFD Invalid RPM Requested';
						arrFaultWarningCurrent[nCurrent]:='F344e - Spindle #2B VFD Invalid RPM Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B2.nErrorID=Er_InvalidRatio THEN
						arrFaultMessage[nFaultArrayIndex]:='F344f - Spindle #2B VFD Invalid Motor to Spindle Ratio Requested';
						arrFaultWarningCurrent[nCurrent]:='F344f - Spindle #2B VFD Invalid Motor to Spindle Ratio Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B2.nErrorID=Er_InvalidOverride THEN
						arrFaultMessage[nFaultArrayIndex]:='F344g - Spindle #2B VFD Invalid Override Requested';
						arrFaultWarningCurrent[nCurrent]:='F344g - Spindle #2B VFD Invalid Override Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B2.nErrorID=Er_UpToSpeedTimeout THEN
						arrFaultMessage[nFaultArrayIndex]:='F344h - Spindle #2B VFD Not Up To Speed';
						arrFaultWarningCurrent[nCurrent]:='F344h - Spindle #2B VFD Not Up To Speed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F344 - Spindle #2B VFD Error : ',
												UDINT_TO_STRING(fbVFD_B2.stVFDInfo.nActiveFault));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F344 - Spindle #2B VFD Error : ',
												UDINT_TO_STRING(fbVFD_B2.stVFDInfo.nActiveFault));
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					END_IF
				END_IF
			END_IF

			IF nActiveFaults[3].20=0 AND fbVFD_B3.bError THEN
			(*	Encompasses ALL VFD related Errors *)
			(* uptospeed, drivenotready, drivefaulted, drivewarning, drivecomm *)
				nActiveFaults[3].20:=1;
				IF (nFaultArrayIndex<=5) THEN
					IF fbVFD_B3.nErrorID=Er_DriveComm THEN
						arrFaultMessage[nFaultArrayIndex]:='F345a - Spindle #3B VFD Communcation Failed';
						arrFaultWarningCurrent[nCurrent]:='F345a - Spindle #3B VFD Communcation Failed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B3.nErrorID=Er_DriveFaulted THEN
						arrFaultMessage[nFaultArrayIndex]:='F345b - Spindle #3B VFD Fault';
						arrFaultWarningCurrent[nCurrent]:='F345b - Spindle #3B VFD Fault';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B3.nErrorID=Er_DriveWarning THEN
						arrFaultMessage[nFaultArrayIndex]:='F345c - Spindle #3B VFD Warning';
						arrFaultWarningCurrent[nCurrent]:='F345c - Spindle #3B VFD Warning';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B3.nErrorID=Er_DriveNotReady THEN
						arrFaultMessage[nFaultArrayIndex]:='F345d - Spindle #3B VFD Not Ready';
						arrFaultWarningCurrent[nCurrent]:='F345d - Spindle #3B VFD Not Ready';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B3.nErrorID=Er_InvalidRPM THEN
						arrFaultMessage[nFaultArrayIndex]:='F345e - Spindle #3B VFD Invalid RPM Requested';
						arrFaultWarningCurrent[nCurrent]:='F345e - Spindle #3B VFD Invalid RPM Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B3.nErrorID=Er_InvalidRatio THEN
						arrFaultMessage[nFaultArrayIndex]:='F345f - Spindle #3B VFD Invalid Motor to Spindle Ratio Requested';
						arrFaultWarningCurrent[nCurrent]:='F345f - Spindle #3B VFD Invalid Motor to Spindle Ratio Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B3.nErrorID=Er_InvalidOverride THEN
						arrFaultMessage[nFaultArrayIndex]:='F345g - Spindle #3B VFD Invalid Override Requested';
						arrFaultWarningCurrent[nCurrent]:='F345g - Spindle #3B VFD Invalid Override Requested';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSIF fbVFD_B3.nErrorID=Er_UpToSpeedTimeout THEN
						arrFaultMessage[nFaultArrayIndex]:='F345h - Spindle #3B VFD Not Up To Speed';
						arrFaultWarningCurrent[nCurrent]:='F345h - Spindle #3B VFD Not Up To Speed';
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					ELSE
						arrFaultMessage[nFaultArrayIndex]:=CONCAT('F345 - Spindle #3B VFD Error : ',
												UDINT_TO_STRING(fbVFD_B3.stVFDInfo.nActiveFault));
						arrFaultWarningCurrent[nCurrent]:=CONCAT('F345 - Spindle #3B VFD Error : ',
												UDINT_TO_STRING(fbVFD_B3.stVFDInfo.nActiveFault));
						nFaultArrayIndex:=nFaultArrayIndex+1;
						nCurrent:=nCurrent+1;
					END_IF
				END_IF
			END_IF

			(* Coolant Pressure Fault for Auto Mode *)
			IF nActiveFaults[3].21=0 AND fbLowPressureFaultBDelay.Q
				AND bMachineMode
			THEN
				nActiveFaults[3].21:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F346 - Coolant Pressure Low - Side B';
					arrFaultWarningCurrent[nCurrent]:='F346 - Coolant Pressure Low - Side B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].22=0 AND fbSpeedVariationTimer1BHIGH.Q
				AND bVFD_BRun  AND bVFD_B1UpToSpeed AND (bInCycle OR bSetupB)
				AND fbBSpeedDelayTimer.Q THEN
				nActiveFaults[3].22:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F347 - Spindle Speed Not Correct #1B (HIGH)';
					arrFaultWarningCurrent[nCurrent]:='F333 - Spindle Speed Not Correct #1B (HIGH)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
			IF nActiveFaults[3].23=0 AND fbSpeedVariationTimer1BLOW.Q
				AND bVFD_BRun AND bVFD_B1UpToSpeed AND (bInCycle OR bSetupB)
				AND fbBSpeedDelayTimer.Q THEN
				nActiveFaults[3].23:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F348 - Spindle Speed Not Correct #1B (LOW)';
					arrFaultWarningCurrent[nCurrent]:='F348 - Spindle Speed Not Correct #1B (LOW)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].24=0 AND fbSpeedVariationTimer2BHIGH.Q
				AND bVFD_BRun  AND bVFD_B2UpToSpeed AND (bInCycle OR bSetupB)
				AND fbBSpeedDelayTimer.Q THEN
				nActiveFaults[3].24:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F349 - Spindle Speed Not Correct #2B (HIGH)';
					arrFaultWarningCurrent[nCurrent]:='F349 - Spindle Speed Not Correct #2B (HIGH)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].25=0 AND fbSpeedVariationTimer2BLOW.Q
				AND bVFD_BRun AND bVFD_B2UpToSpeed AND (bInCycle OR bSetupB)
				AND fbBSpeedDelayTimer.Q THEN
				nActiveFaults[3].25:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F350 - Spindle Speed Not Correct #2B (LOW)';
					arrFaultWarningCurrent[nCurrent]:='F350 - Spindle Speed Not Correct #2B (LOW)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].26=0 AND fbSpeedVariationTimer3BHIGH.Q
				AND bVFD_BRun  AND bVFD_B3UpToSpeed AND (bInCycle OR bSetupB)
				AND fbBSpeedDelayTimer.Q THEN
				nActiveFaults[3].26:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F351 - Spindle Speed Not Correct #3B (HIGH)';
					arrFaultWarningCurrent[nCurrent]:='F351 - Spindle Speed Not Correct #3B (HIGH)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].27=0 AND fbSpeedVariationTimer3BLOW.Q
				AND bVFD_BRun AND bVFD_B3UpToSpeed AND (bInCycle OR bSetupB)
				AND fbBSpeedDelayTimer.Q THEN
				nActiveFaults[3].27:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F352 - Spindle Speed Not Correct #3B (LOW)';
					arrFaultWarningCurrent[nCurrent]:='F352 - Spindle Speed Not Correct #3B (LOW)';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].28=0 AND nModeError=Er_SideBColletSolError THEN
				nModeError:=Er_NoModeError;
				nActiveFaults[3].28:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F353 - Both B Clamp and UnClamp Solenoids On At Same Time';
					arrFaultWarningCurrent[nCurrent]:='F353 - Both B Clamp and UnClamp Solenoids On At Same Time';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].29=0 AND nModeError=Er_SideBEjectorsSolError THEN
				nModeError:=Er_NoModeError;
				nActiveFaults[3].29:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F354 - Both B Ejector Advance  and Retract Solenoids On At Same Time';
					arrFaultWarningCurrent[nCurrent]:='F354 - Both B Ejector Advance  and Retract Solenoids On At Same Time';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			IF nActiveFaults[3].30=0 AND bRack7Comm THEN
				nActiveFaults[3].30:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F355 - Com. Lost to Side B Tailstock Input Module';
					arrFaultWarningCurrent[nCurrent]:='F355 - Com. Lost to Side B Tailstock Input Module';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

			(* If we lose Side B Clamp PS In the AutoCycle between AC_Clamp and AC_Unclamp we Fault *)
			IF nActiveFaults[3].31=0 AND (nAutoCycleStep > AC_Clamp) AND (nAutoCycleStep < AC_Unclamp) AND
				NOT bPS727
			THEN
				nActiveFaults[3].31:=1;
				IF (nFaultArrayIndex<=5) THEN
					arrFaultMessage[nFaultArrayIndex]:='F356 - Clamp Pressure Lost - Side B';
					arrFaultWarningCurrent[nCurrent]:='F356 - Clamp Pressure Lost - Side B';
					nFaultArrayIndex:=nFaultArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF

		END_IF (*	Side B Faults *)

	(* Faults that do not Stop a Drilling Cycle *)

		IF nActiveFaults[4].0=0 AND bFilter1Dirty AND nDirtyCount1=5 THEN
			nActiveFaults[4].0:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F400 - Filter #1 Clogged (MUST CHANGE)';
				arrFaultWarningCurrent[nCurrent]:='F400 - Filter #1 Clogged (MUST CHANGE)';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[4].1=0 AND bFilter2Dirty AND nDirtyCount2=5 THEN
			nActiveFaults[4].1:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F401 - Filter #2 Clogged (MUST CHANGE)';
				arrFaultWarningCurrent[nCurrent]:='F401 - Filter #2 Clogged (MUST CHANGE)';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[4].2=0 AND bFilter3Dirty AND nDirtyCount3=5 THEN
			nActiveFaults[4].2:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F402 - Filter #3 Clogged (MUST CHANGE)';
				arrFaultWarningCurrent[nCurrent]:='F402 - Filter #3 Clogged (MUST CHANGE)';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[4].3=0 AND bFilter4Dirty AND nDirtyCount4=5 THEN
			nActiveFaults[4].3:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F403 - Filter #4 Clogged (MUST CHANGE)';
				arrFaultWarningCurrent[nCurrent]:='F403 - Filter #4 Clogged (MUST CHANGE)';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveFaults[4].4=0 AND NOT(bLubeLevel) AND (nLubeLevelLowCount>=3) THEN
			nActiveFaults[4].4:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F404 - Lube Level Low (MUST FILL)';
				arrFaultWarningCurrent[nCurrent]:='F404 - Lube Level Low (MUST FILL)';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		(* Fault if Side A Collet Clamped and X selected on MPG *)
		IF nActiveFaults[4].5=0 AND ( ( (bPS617 OR bATailstockColletClamp) AND bXAAxisSelected) OR
			( (bPS727 OR bBTailstockColletClamp) AND bXBAxisSelected) ) THEN
			nActiveFaults[4].5:=1;
			IF (nFaultArrayIndex<=5) THEN
				IF bXAAxisSelected THEN
					arrFaultMessage[nFaultArrayIndex]:='F405A - MPG XA Selected While Clamped';
					arrFaultWarningCurrent[nCurrent]:='F405A - MPG XA Selected While Clamped';
				ELSE
					arrFaultMessage[nFaultArrayIndex]:='F405B - MPG XB Selected While Clamped';
					arrFaultWarningCurrent[nCurrent]:='F405B - MPG XB Selected While Clamped';
				END_IF
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		(* Fault if Side A Collet Clamped and ZA or WA selected on MPG *)
		IF nActiveFaults[4].6=0 AND (bPS617 OR bATailstockColletClamp) AND (bZAAxisSelected OR bWAAxisSelected) THEN
			nActiveFaults[4].6:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F406 - MPG ZA or WA Selected While Clamped';
				arrFaultWarningCurrent[nCurrent]:='F406 - MPG ZA or WA Selected While Clamped';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		(* Fault if Side B Collet Clamped and ZB or WB selected on MPG *)
		IF nActiveFaults[4].7=0 AND (bPS727 OR bBTailstockColletClamp) AND (bZBAxisSelected OR bWBAxisSelected) THEN
			nActiveFaults[4].7:=1;
			IF (nFaultArrayIndex<=5) THEN
				arrFaultMessage[nFaultArrayIndex]:='F407 - MPG ZB or WB Selected While Clamped';
				arrFaultWarningCurrent[nCurrent]:='F407 - MPG ZB or WB Selected While Clamped';
				nFaultArrayIndex:=nFaultArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

	(* 	WARNINGS		*)

		IF nActiveWarnings[1].0=0 AND fbCoolantTempWarningTON.Q THEN
			nActiveWarnings[1].0:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W001 - Coolant Temperature Warning';
				arrFaultWarningCurrent[nCurrent]:='W001 - Coolant Temperature Warning';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF NOT( bCoolantTempWarning) AND nActiveWarnings[1].0=1 THEN
			IF FIND(arrFaultMessage[6], 'W001')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].0:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W001')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].0:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W001')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].0:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W001')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].0:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W001')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].0:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].0:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].1=0 AND NOT(bProx310)
			AND (bMachineMode OR bEnterAutoModePB) AND NOT(bInCycle) THEN
			nActiveWarnings[1].1:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W002 - Tool Change Door Open Side A';
				arrFaultWarningCurrent[nCurrent]:='W002 - Tool Change Door Open Side A';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF bProx310 AND nActiveWarnings[1].1 THEN
			IF FIND(arrFaultMessage[6], 'W002')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].1:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W002')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].1:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W002')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].1:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W002')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].1:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W002')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].1:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].1:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].2=0 AND NOT(bProx312)
			AND (bMachineMode OR bEnterAutoModePB) AND NOT(bInCycle) THEN
			nActiveWarnings[1].2:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W003 - Tailstock Door Open Side A';
				arrFaultWarningCurrent[nCurrent]:='W003 - Tailstock Door Open Side A';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF bProx312 AND nActiveWarnings[1].2 THEN
			IF FIND(arrFaultMessage[6], 'W003')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].2:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W003')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].2:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W003')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].2:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W003')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].2:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W003')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].2:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].2:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].3=0 AND NOT(bProx313)
			AND (bMachineMode OR bEnterAutoModePB) AND NOT(bInCycle) THEN
			nActiveWarnings[1].3:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W004 - Tailstock Door Open Side B';
				arrFaultWarningCurrent[nCurrent]:='W004 - Tailstock Door Open Side B';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF bProx313 AND nActiveWarnings[1].3 THEN
			IF FIND(arrFaultMessage[6], 'W004')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].3:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W004')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].3:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W004')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].3:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W004')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].3:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W004')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].3:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].3:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].4=0 AND fbFilter1Timer.Q AND nDirtyCount1<5 THEN
			nDirtyCount1:=nDirtyCount1+1;
			nActiveWarnings[1].4:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W005 - Filter #1 is Dirty';
				arrFaultWarningCurrent[nCurrent]:='W005 - Filter #1 is Dirty';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].5=0 AND bMachineMode AND (fStartFeed=0) THEN
				nActiveWarnings[1].5:=1;
				IF (nWarningArrayIndex<=5) THEN
					arrFaultMessage[nWarningArrayIndex+5]:='W006a - Start Feedrate Must Be Nonzero';
					arrFaultWarningCurrent[nCurrent]:='W006a - Start Feedrate Must Be Nonzero';
					nWarningArrayIndex:=nWarningArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
		END_IF

		IF nActiveWarnings[1].6=0 AND bMachineMode AND (fFinishFeed=0) THEN
			nActiveWarnings[1].6:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W007 - Finish Feedrate Must Be Nonzero';
				arrFaultWarningCurrent[nCurrent]:='W007 - Finish Feedrate Must Be Nonzero';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].7=0 AND NOT(bLubeLevel) AND bMCR THEN
			nActiveWarnings[1].7:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W008 - Lube Level Low';
				arrFaultWarningCurrent[nCurrent]:='W008 - Lube Level Low';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF bLubeLevel AND nActiveWarnings[1].7=1 THEN
			IF FIND(arrFaultMessage[6], 'W008')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].7:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W008')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].7:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W008')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].7:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W008')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].7:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W008')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].7:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].7:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].8=0 AND fbFilter2Timer.Q AND nDirtyCount2<5 THEN
			nDirtyCount2:=nDirtyCount2+1;
			nActiveWarnings[1].8:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W009 - Filter #2 is Dirty';
				arrFaultWarningCurrent[nCurrent]:='W009 - Filter #2 is Dirty';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].9=0 AND fbFilter3Timer.Q AND nDirtyCount3<5 THEN
			nDirtyCount3:=nDirtyCount3+1;
			nActiveWarnings[1].9:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W010 - Filter #3 is Dirty';
				arrFaultWarningCurrent[nCurrent]:='W010 - Filter #3 is Dirty';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].10=0 AND fbFilter4Timer.Q AND nDirtyCount4<5 THEN
			nDirtyCount4:=nDirtyCount4+1;
			nActiveWarnings[1].10:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W011 - Filter #4 is Dirty';
				arrFaultWarningCurrent[nCurrent]:='W011 - Filter #4 is Dirty';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].11=0 AND bMCR AND NOT(bPneumaticSystemPressure) THEN
			nActiveWarnings[1].11:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W012 - Main Air Pressure Lost';
				arrFaultWarningCurrent[nCurrent]:='W012 - Main Air Pressure Lost';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF bPneumaticSystemPressure AND nActiveWarnings[1].11 THEN
			IF FIND(arrFaultMessage[6], 'W012')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].11:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W012')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].11:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W012')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].11:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W012')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].11:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W012')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].11:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].11:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].12=0 AND NOT(bProx311)
			AND (bMachineMode OR bEnterAutoModePB) AND NOT(bInCycle) THEN
			nActiveWarnings[1].12:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W013 - Tool Change Door Open Side B';
				arrFaultWarningCurrent[nCurrent]:='W013 - Tool Change Door Open Side B';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF bProx311 AND nActiveWarnings[1].12 THEN
			IF FIND(arrFaultMessage[6], 'W013')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W013')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W013')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W013')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W013')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].13=0 AND nModeError=Er_LoadPartMissing THEN
			nActiveWarnings[1].13:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W014 - Load Side Missing Parts';
				arrFaultWarningCurrent[nCurrent]:='W014 - Load Side Missing Parts';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].14=0 AND nModeError=Er_UnloadPartPresent THEN
			nActiveWarnings[1].14:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W015 - Unload Side Remove Parts';
				arrFaultWarningCurrent[nCurrent]:='W015 - Unload Side Remove Parts';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].15=0 AND nModeError=Er_TryingToLeaveAutoInCycle THEN
			nActiveWarnings[1].15:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W016 - Can Not Exit Auto while in Cycle';
				arrFaultWarningCurrent[nCurrent]:='W016 - Can Not Exit Auto while in Cycle';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].16=0 AND nModeError=Er_HydraulicPSOff THEN
			nActiveWarnings[1].16:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W017 - Hydraulic Pressure Low';
				arrFaultWarningCurrent[nCurrent]:='W017 - Hydraulic Pressure Low';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].17=0 AND nModeError=Er_XAxisNotHomed THEN
			nActiveWarnings[1].17:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W018 - X Axis must be Homed';
				arrFaultWarningCurrent[nCurrent]:='W018 - X Axis must be Homed';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].18=0 AND nModeError=Er_ZAAxisNotHomed THEN
			nActiveWarnings[1].18:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W019 - ZA Axis must be Homed';
				arrFaultWarningCurrent[nCurrent]:='W019 - ZA Axis must be Homed';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].19=0 AND nModeError=Er_WAAxisNotHomed THEN
			nActiveWarnings[1].19:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W020 - WA Axis must be Homed';
				arrFaultWarningCurrent[nCurrent]:='W020 - WA Axis must be Homed';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].20=0 AND nModeError=Er_ZBAxisNotHomed THEN
			nActiveWarnings[1].20:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W021 - ZB Axis must be Homed';
				arrFaultWarningCurrent[nCurrent]:='W021 - ZB Axis must be Homed';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].21=0 AND nModeError=Er_WBAxisNotHomed THEN
			nActiveWarnings[1].21:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W022 - WB Axis must be Homed';
				arrFaultWarningCurrent[nCurrent]:='W022 - WB Axis must be Homed';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].22=0 AND nModeError=Er_WANotRetracted THEN
			nActiveWarnings[1].22:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W023 - Tailstock WA must be Retracted';
				arrFaultWarningCurrent[nCurrent]:='W022 - WB Axis must be Homed';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].23=0 AND nModeError=Er_WBNotRetracted THEN
			nActiveWarnings[1].23:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W024 - Tailstock WB must be Retracted';
				arrFaultWarningCurrent[nCurrent]:='W024 - Tailstock WB must be Retracted';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].24=0 AND nModeError=Er_TransferNotAtLoad THEN
			nActiveWarnings[1].24:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W025 - Transfer is not at Load Position';
				arrFaultWarningCurrent[nCurrent]:='W025 - Transfer is not at Load Position';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].25=0 AND nModeError=Er_ACulletNotUnclamped THEN
			nActiveWarnings[1].25:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W026 - Side A Collets Must Be Unclamped';
				arrFaultWarningCurrent[nCurrent]:='W026 - Side A Collets Must Be Unclamped';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].26=0 AND nModeError=Er_BCulletNotUnclamped THEN
			nActiveWarnings[1].26:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W027 - Side B Collets Must Be Unclamped';
				arrFaultWarningCurrent[nCurrent]:='W027 - Side B Collets Must Be Unclamped';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].27=0 AND nModeError=Er_AEjectorsNotRetracted THEN
			nActiveWarnings[1].27:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W028 - Side A Ejectors Not Retracted';
				arrFaultWarningCurrent[nCurrent]:='W028 - Side A Ejectors Not Retracted';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].28=0 AND nModeError=Er_BEjectorsNotRetracted THEN
			nActiveWarnings[1].28:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W029 - Side B Ejectors Not Retracted';
				arrFaultWarningCurrent[nCurrent]:='W029 - Side B Ejectors Not Retracted';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].29=0 AND nModeError=Er_HPPumpOff THEN
			nActiveWarnings[1].29:=1;
			nModeError:=Er_NoModeError;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W030 - Coolant System is OFF';
				arrFaultWarningCurrent[nCurrent]:='W030 - Coolant System is OFF';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[1].30=0 AND bChipConveyorVFDFault THEN
			nActiveWarnings[1].30:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W031 - Chip Conveyor VFD Error';
				arrFaultWarningCurrent[nCurrent]:='W031 - Chip Conveyor VFD Error';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF NOT(bMPGAOn) AND nActiveWarnings[1].30 THEN
			IF FIND(arrFaultMessage[6], 'W031')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].30:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W031')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].30:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W031')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].30:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W031')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[1].30:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W031')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[1].30:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[1].30:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		IF nActiveWarnings[1].31=0 AND bHydraulicTemperature AND
			(bHydraulicUnitOn AND fbHydraulicSystemOnTON.Q)
		THEN
			nActiveWarnings[1].31:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W032 - Hydraulic Fluid Temperature High Alarm';
				arrFaultWarningCurrent[nCurrent]:='W032 - Hydraulic Fluid Temperature High Alarm';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[2].0=0 AND fbLubePressureTON.Q THEN
			nActiveWarnings[2].0:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W033 - Lube Pressure Lost';
				arrFaultWarningCurrent[nCurrent]:='W033 - Lube Pressure Lost';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[2].1=0 AND fbHydraulicFluidLowTON.Q THEN
			nActiveWarnings[2].1:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W034 - Hydraulic Unit Fluid Level Low';
				arrFaultWarningCurrent[nCurrent]:='W034 - Hydraulic Unit Fluid Level Low';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[2].2=0 AND MAIN.fbChipConveyorMotorControl.bError THEN
			nActiveWarnings[2].2:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W035 - Chip Conveyor MS-3 Failure';
				arrFaultWarningCurrent[nCurrent]:='W035 - Chip Conveyor MS-3 Failure';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[2].3=0 AND bMachineMode THEN
			IF  fFinishDepth=0 THEN
				nActiveWarnings[2].3:=1;
				IF (nWarningArrayIndex<=5) THEN
					arrFaultMessage[nWarningArrayIndex+5]:='W036a - Finish Depth Must Be Nonzero';
					arrFaultWarningCurrent[nCurrent]:='W036a - Finish Depth Must Be Nonzero';
					nWarningArrayIndex:=nWarningArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			ELSIF fStartDepth < fFinishDepth THEN
				nActiveWarnings[2].3:=1;
				IF (nWarningArrayIndex<=5) THEN
					arrFaultMessage[nWarningArrayIndex+5]:='W036b - Check Start Depth';
					arrFaultWarningCurrent[nCurrent]:='W036b - Check Start Depth';
					nWarningArrayIndex:=nWarningArrayIndex+1;
					nCurrent:=nCurrent+1;
				END_IF
			END_IF
		END_IF

		(* Coolant Pressure Warning Side A in Setup Mode *)
		IF nActiveWarnings[2].4=0 AND fbLowPressureFaultADelay.Q
				AND NOT bMachineMode
			THEN
			nActiveWarnings[2].4:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W037 - Coolant Pressure Low - Side A';
				arrFaultWarningCurrent[nCurrent]:='W037 - Coolant Pressure Low - Side A';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF  nActiveWarnings[2].4 AND (NOT(bACoolantSolenoid) OR bACoolantPressure) THEN
			IF FIND(arrFaultMessage[6], 'W037')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].4:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W037')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].4:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W037')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].4:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W037')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].4:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W037')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[2].4:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[2].4:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		(* Coolant Pressure Warning Side B in Setup Mode *)
		IF nActiveWarnings[2].5=0 AND fbLowPressureFaultBDelay.Q
				AND NOT bMachineMode
			THEN
			nActiveWarnings[2].5:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W038 - Coolant Pressure Low - Side B';
				arrFaultWarningCurrent[nCurrent]:='W038 - Coolant Pressure Low - Side B';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF  nActiveWarnings[2].5 AND (NOT(bBCoolantSolenoid) OR bBCoolantPressure) THEN
			IF FIND(arrFaultMessage[6], 'W038')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].5:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W038')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].5:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W038')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].5:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W038')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].5:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W038')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[2].5:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[2].5:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

(* SPARES *)

		(* MPGA Axis Selected *)
		bMPGAOn:=(bWAAxisSelected OR bXAAxisSelected OR bYAAxisSelected OR bZAAxisSelected);
		IF nActiveWarnings[2].12=0 AND (bMachineMode OR bEnterAutoModePB) AND
			bMPGAON AND NOT(bInCycle) THEN
			nActiveWarnings[2].12:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W130 - MPG A Must Be Off';
				arrFaultWarningCurrent[nCurrent]:='W130 - MPG A Must Be Off';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF NOT(bMPGAOn) AND nActiveWarnings[2].12 THEN
			IF FIND(arrFaultMessage[6], 'W130')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W130')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W130')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W130')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W130')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[2].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[2].12:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		(* MPGB Axis Selected *)
		bMPGBOn:=(bWBAxisSelected OR bXBAxisSelected OR bYBAxisSelected OR bZBAxisSelected);
		IF nActiveWarnings[2].13=0 AND (bMachineMode OR bEnterAutoModePB) AND
			bMPGBON AND NOT(bInCycle) THEN
			nActiveWarnings[2].13:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W131 - MPG B Must Be Off';
				arrFaultWarningCurrent[nCurrent]:='W131 - MPG B Must Be Off';
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		ELSIF NOT(bMPGAOn) AND nActiveWarnings[2].12 THEN
			IF FIND(arrFaultMessage[6], 'W131')>0 THEN
				arrFaultMessage[6]:=arrFaultMessage[7];
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].13:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[7], 'W131')>0 THEN
				arrFaultMessage[7]:=arrFaultMessage[8];
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].13:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[8], 'W131')>0 THEN
				arrFaultMessage[8]:=arrFaultMessage[9];
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].13:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[9], 'W131')>0 THEN
				arrFaultMessage[9]:=arrFaultMessage[10];
				arrFaultMessage[10]:='';
				nActiveWarnings[2].13:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSIF FIND(arrFaultMessage[10], 'W131')>0 THEN
				arrFaultMessage[10]:='';
				nActiveWarnings[2].13:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			ELSE
				nActiveWarnings[2].13:=0;
				nWarningArrayIndex:=nWarningArrayIndex-1;
			END_IF
		END_IF

		(***** TRANSFER WARNINGS ****
		The text of the Warning comes from the the TransferCycle Action of the P_TransferControl (PGM). 
			We assign the 100 series to the warnings by concating a W1 to the beginning of the text.  
			This allows us to assign the Warning series of numbers in an effort to make it more modular.  
			You must go to the function block to see the rest of the number and the description text of the fault. f
			Generally this is at the bottom of the function block or program section. 
			ErrorID < 50 is a WARNING and ErrorID >= 50 are Faults
			If this is reused in a different machine we want to make sure we assign the appropriate #series to the warnings.  *)
		IF  nActiveWarnings[2].14=0  AND bTransferError  AND nTransferErrorID < 50THEN
			nActiveWarnings[2].14:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:=CONCAT('W1',sTransferErrorText);
				arrFaultWarningCurrent[nCurrent]:=CONCAT('W1',sTransferErrorText);
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF

		IF nActiveWarnings[4].0=0 AND bLoadSideNotSelected THEN
			bLoadSideNotSelected:=FALSE;
			nActiveWarnings[4].0:=1;
			IF (nWarningArrayIndex<=5) THEN
				arrFaultMessage[nWarningArrayIndex+5]:='W??? - Load Side not selected - Call Maintenance';
				arrFaultWarningCurrent[nCurrent]:='W??? - Load Side not selected - Call Maintenance';;
				nWarningArrayIndex:=nWarningArrayIndex+1;
				nCurrent:=nCurrent+1;
			END_IF
		END_IF



		(* Did we have any faults? *)
		IF nActiveFaults[1]>0
		OR nActiveFaults[2]>0
		OR nActiveFaults[3]>0
		OR nActiveFaults[4]>0 THEN
			bMachineFault:=TRUE;
		END_IF
		(* Did we have any Warning? *)
		IF nActiveWarnings[1]>0
		OR nActiveWarnings[2]>0
		OR nActiveWarnings[3]>0
		OR nActiveWarnings[4]>0 THEN
			bMachineWarning:=TRUE;
		ELSE
			bMachineWarning:=FALSE;
		END_IF
		(* If so then we go to state 1 to wait for a Reset *)
		IF bMachineFault OR bMachineWarning THEN
			nFaultState:=nFaultState+1;
			(* Special condition withing the first 40 seconds of Master Start
				check for servo faults to trigger an Internal Fault Reset *)
			IF bMCR AND NOT  fbMCRJustOnTON.Q THEN
				IF bSideAEnabled AND ( stZAAxis.NcToPlc.StateDWord.31 OR
					stWAAxis.NcToPlc.StateDWord.31)
				THEN
					bAFaultResetInternal:=TRUE;
				END_IF
				IF bSideBEnabled AND (stZBAxis.NcToPlc.StateDWord.31 OR
					stWBAxis.NcToPlc.StateDWord.31)
				THEN
					bBFaultResetInternal:=TRUE;
				END_IF
				IF stUAxis.NcToPlc.StateDWord.31 THEN
					(* Just need to trigger a reset, so either side would do *)
					bAFaultResetInternal:=TRUE;
				END_IF
			END_IF
		(* When the Internal Resets are on and we do not have any faults we want to turn it off *)
		ELSIF fbInternalResetTON.Q THEN
			bAFaultResetInternal:=FALSE;
			bBFaultResetInternal:=FALSE;
		END_IF

	(* If we get a fault reset reset requested by a push button or internal request then we check the drives for faults .
	  If a drive has a fault then we set the bit to reset that drive.  The bit will be reset in the servo control section, 
		so we want to wait for it before we move on.
	  Once we no longer have any of the drives requiring a reset, then we jump to step 2. 
	  If we do not get a reset request or a drive reset then we go back and check for more faults. *)

	1:	(* Wait for Fault Resets *)

		(* When Fault Reset Requested we check to see if the drives are resetting *)
		IF bFaultResetRequested THEN
			(* The Drive Resets are cleared by the servo control sections *)
			IF NOT(bZWADriveResetRequest OR bZWBDriveResetRequest OR bUDriveResetRequest) OR
				(* Timer does not allow to get stuck in this step *)
				fbFaultResetWatchdog.Q
			 THEN
				bFaultResetRequested:=FALSE;
				nFaultState:=nFaultState+1;
			END_IF

		(* If Fault Reset PB's or internal reset then turn on reset requested *)
		ELSIF bFaultResetPB OR fbCommonFautlResetTON.Q OR
			bAFaultResetInternal OR bBFaultResetInternal
		THEN
			bFaultResetRequested:=TRUE;

			(* Do A reset of the Servo Drives if they are faulted, then we need to do a MCReset for the same drives *)

			(* Do a FB_SoEReset of the Drive when one of the Servo Axis has the Fault State bit set *)
			IF bSideAEnabled AND ( stZAAxis.NcToPlc.StateDWord.31 OR stWAAxis.NcToPlc.StateDWord.31) THEN
				bZWADriveResetRequest:=TRUE;
			END_IF
			IF bSideBEnabled AND (stZBAxis.NcToPlc.StateDWord.31 OR stWBAxis.NcToPlc.StateDWord.31) THEN
				bZWBDriveResetRequest:=TRUE;
			END_IF
			IF stUAxis.NcToPlc.StateDWord.31THEN
				bUDriveResetRequest:=TRUE;
			END_IF
			(* Reset the MPG if it is faulted *)
			IF stAxisMPG_A.NcToPlc.StateDWord.31 THEN
				bMPGA_MCResetRequest:=TRUE;
			END_IF
			IF stAxisMPG_B.NcToPlc.StateDWord.31 THEN
				bMPGB_MCResetRequest:=TRUE;
			END_IF

		(* Go back and check for more faults if no Reset action was requested *)
		ELSE
			nFaultState:=nFaultState-1;
		END_IF


	2:	(* Take Action on the Requested Fault *)
		(* Clear the Fault Display Messages and the Active Faults/Warnings *)
		arrFaultMessage[1]:='';
		arrFaultMessage[2]:='';
		arrFaultMessage[3]:='';
		arrFaultMessage[4]:='';
		arrFaultMessage[5]:='';
		arrFaultMessage[6]:='';
		arrFaultMessage[7]:='';
		arrFaultMessage[8]:='';
		arrFaultMessage[9]:='';
		arrFaultMessage[10]:='';
		nFaultArrayIndex:=1;
		nWarningArrayIndex:=1;
		nActiveFaults[1]:=0;
		nActiveFaults[2]:=0;
		nActiveFaults[3]:=0;
		nActiveFaults[4]:=0;
		nActiveWarnings[1]:=0;
		nActiveWarnings[2]:=0;
		nActiveWarnings[3]:=0;
		nActiveWarnings[4]:=0;
		bMachineFault:=FALSE;
		bMachineWarning:=FALSE;
		bFaultHistoryFileError:=FALSE;

		(* Reset the Filter Timers *)
		IF fbFilter1Timer.Q THEN
			bFilter1Timer:=FALSE;
		END_IF
		IF fbFilter2Timer.Q THEN
			bFilter2Timer:=FALSE;
		END_IF
		IF fbFilter3Timer.Q THEN
			bFilter3Timer:=FALSE;
		END_IF
		IF fbFilter4Timer.Q THEN
			bFilter4Timer:=FALSE;
		END_IF

		(* When the PB is Released then we jump out of this state or
			if it is internal reset we reset and jump out *)
		IF NOT(bFaultResetPB OR fbCommonFautlResetTON.Q) OR (* put two into one Not ored toghether *)
			bAFaultResetInternal OR bBFaultResetInternal
		THEN
			bAFaultResetInternal:=FALSE;
			bBFaultResetInternal:=FALSE;
			nFaultState:=0;
		END_IF

END_CASE

(* When the Internal Fault Reset has been on for a while without a bMachineFault we trigger a reset *)
fbInternalResetTON(IN:= (bAFaultResetInternal OR bBFaultResetInternal)
	AND NOT bMachineFault, PT:=t#250ms);
(* The Servo will sometimes fault and need to be reset withing 30 seconds of the MCR being pulled in *)
fbMCRJustOnTON(IN:=bMCR, PT:=t#40s);

(* When we have a fault we need to write it to fault history *)
IF nCurrent>nUnStored THEN
	(* This will take the number of nCurrent Scans to store current faults to history *)
	CASE nHistoryStep OF
	1:	(*	Copy nFaultHistory[1-79] to nFaultHistoryTemp[2-80]	*)
		IF MEMCPY(
			ADR(arrFaultHistoryTemp[2]),
			ADR(arrFaultHistory[1]),
			SIZEOF(arrFaultHistory)-SIZEOF(arrFaultHistory[1])
		) <> 0 THEN (* Returneing a Zero meanse Error*)
			nHistoryStep:=nHistoryStep+1;
		END_IF

	2:	(*	Copy current Fault/Waring into nFaultHistoryTemp[1]	*)
		IF MEMCPY(
			ADR(arrFaultHistoryTemp[1]),
			ADR(arrFaultWarningCurrent[nUnStored MOD 8]),
			SIZEOF(arrFaultHistoryTemp[1])
		) <> 0 THEN
			nHistoryStep:=nHistoryStep+1;
		END_IF

	3:	(*	Copy nFaultHistoryTemp to nFaultHistory	*)
		IF MEMCPY(
			ADR(arrFaultHistory[1]),
			ADR(arrFaultHistoryTemp[1]),
			SIZEOF(arrFaultHistory)
		) <> 0 THEN
			nHistoryStep:=1;
			(*	Increment nUnStored	*)
			nUnStored:=nUnStored+1;
		END_IF

	END_CASE

ELSIF nCurrent=nUnStored THEN
	nCurrent:=0;
	nUnStored:=0;
END_IF

(* Coolant Temp Monitoring *)
fCoolantTempDisplay:=(nCoolantTemp/10.0);
IF fCoolantTempDisplay>=43.33 THEN
	bCoolantTempFault:=TRUE;
ELSIF fCoolantTempDisplay>=40.55 THEN
	bCoolantTempWarning:=TRUE;
	bCoolantTempFault:=FALSE;
ELSE
	bCoolantTempFault:=FALSE;
	bCoolantTempWarning:=FALSE;
END_IF

fbFaultResetWatchdog(IN:=bFaultResetRequested, PT:=t#5s);
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM P_MPGControl
VAR

	fbMPGAAxisEnable: MC_Power;
	bMPGAAxisEnable : BOOL := FALSE;

	fbMPGBAxisEnable: MC_Power;
	bMPGBAxisEnable : BOOL := FALSE;

	fbMPGUAOn: R_TRIG;
	fbMPGYAOn: R_TRIG;
	fbMPGZAOn: R_TRIG;
	fbMPGWAOn: R_TRIG;

	fbMPGXBOn: R_TRIG;
	fbMPGYBOn: R_TRIG;
	fbMPGZBOn: R_TRIG;
	fbMPGWBOn: R_TRIG;

	fbAAxisSelectDelay: TON;				(* Side A MPG Axis Selected Delay Timer *)

	fbBAxisSelectDelay: TON;				(* Side B MPG Axis Selected Delay Timer *)

	fbMPGUAAxisGearIn: MC_GearInDyn;
	bMPGUAAxisGearIn : BOOL;
	fbMPGUAAxisGearOut : MC_GearOut;
	bMPGUAAxisGearOut : BOOL;

	fbMPGZAAxisGearIn : MC_GearInDyn;
	bMPGZAAxisGearIn : BOOL;
	fbMPGZAAxisGearOut : MC_GearOut;
	bMPGZAAxisGearOut : BOOL;

	fbMPGWAAxisGearIn : MC_GearInDyn;
	bMPGWAAxisGearIn : BOOL;
	fbMPGWAAxisGearOut : MC_GearOut;
	bMPGWAAxisGearOut : BOOL;

	fbMPGXBAxisGearIn: MC_GearInDyn;
	bMPGXBAxisGearIn : BOOL;
	fbMPGXBAxisGearOut : MC_GearOut;
	bMPGXBAxisGearOut : BOOL;

	fbMPGZBAxisGearIn : MC_GearInDyn;
	bMPGZBAxisGearIn : BOOL;
	fbMPGZBAxisGearOut : MC_GearOut;
	bMPGZBAxisGearOut : BOOL;

	fbMPGWBAxisGearIn : MC_GearInDyn;
	bMPGWBAxisGearIn : BOOL;
	fbMPGWBAxisGearOut : MC_GearOut;
	bMPGWBAxisGearOut : BOOL;

	MPG_A_Rate: INT := 1;		(*Side A MPG Rate*)
	MPG_B_Rate: INT := 1;		(*Side B MPG Rate*)

	MPGMode: INT := 0;		(*MPG State Mode Counter*)
	nMPG_A_State: INT := 0;		(*MPG Side A State Counter*)
	nMPG_B_State: INT := 0;		(*MPG Side A State Counter*)

	nMPGA_ErrorID : UDINT := 0;
	fGearRatioA: LREAL := 0.1;		(*Gear Ratio Input to the Gear In FB*)
	nMPGB_ErrorID : UDINT := 0;
	fGearRatioB: LREAL := 0.1;		(*Gear Ratio Input to the Gear In FB*)

	fbMPGWatchdog : TON;			(* Watchdog Timer for MPG A Control *)
	bMPGWatchdog : BOOL := FALSE;	(* Watchdog Timer TRigger for MPG A *)
	fbMPGBWatchdog : TON;			(* Watchdog Timer for MPG  B Control *)
	bMPGBWatchdog : BOOL := FALSE;	(* Watchdog Timer TRigger for MPG B *)
END_VAR
(* @END_DECLARATION := '0' *)
(* When the MCC_S comes in Enable the MPG's *)
bMPGAAxisEnable := bMCC_SConfirm;
bMPGBAxisEnable := bMCC_SConfirm;

(* Only Available if Manual Mode and the MCC_S pulled in *)
IF bMCC_SConfirm AND NOT bMachineMode THEN
	CASE MPGMode OF
		0: (* Check if an Axis is selected *)
			IF bMachineFault THEN	(* Fault so stay in this step *)
				MPGMode := 0;
				nMPG_A_State:=0;
				(* Do not really need to Gear Out at this point, but this is what the Eaton program did *)
				bMPGUAAxisGearOut := TRUE;
				bMPGZAAxisGearOut := TRUE;
				bMPGWAAxisGearOut := TRUE;
				bMPGXBAxisGearOut := TRUE;
				bMPGZBAxisGearOut := TRUE;
				bMPGWBAxisGearOut := TRUE;
			ELSIF fbMPGUAOn.Q THEN
				bMPGUAAxisGearIn := FALSE;
				bMPGUAAxisGearOut := FALSE;
				MPGMode := 1;
			ELSIF fbMPGZAOn.Q THEN
				bMPGZAAxisGearIn := FALSE;
				bMPGZAAxisGearOut := FALSE;
				MPGMode := 3;
			ELSIF fbMPGWAOn.Q THEN
				bMPGWAAxisGearIn := FALSE;
				bMPGWAAxisGearOut := FALSE;
				MPGMode := 4;
			ELSIF fbMPGXBOn.Q THEN
				bMPGXBAxisGearIn := FALSE;
				bMPGXBAxisGearOut := FALSE;
				MPGMode := 5;
			ELSIF fbMPGZBOn.Q THEN
				bMPGZBAxisGearIn := FALSE;
				bMPGZBAxisGearOut := FALSE;
				MPGMode := 7;
			ELSIF fbMPGWBOn.Q THEN
				bMPGWBAxisGearIn := FALSE;
				bMPGWBAxisGearOut := FALSE;
				MPGMode := 8;
			END_IF

		1: (* U Axis Selected *)
			CASE nMPG_A_State OF
			0:	(* INIT *)
				IF NOT bXAAxisSelected THEN
					MPGMode := 0;
				ELSE
					nMPG_A_State := nMPG_A_State + 1;
				END_IF

			1:	(* Request Gear In *)
				IF bMPGUAAxisGearIn AND fbMPGUAAxisGearIn.InGear THEN
					nMPG_A_State:=nMPG_A_State+1;
				ELSIF bMPGUAAxisGearIn AND fbMPGUAAxisGearIn.Error THEN
					bMPGUAAxisGearIn := FALSE;
					nMPGA_ErrorID := fbMPGUAAxisGearIn.ErrorID;
					nMPG_A_State := 5;
				ELSE
					bMPGUAAxisGearIn:=TRUE;
				END_IF

			2:	(* Wait for Axis Selector Change or end if a Fault Occurs *)
				IF NOT(bXAAxisSelected) OR bMachineFault THEN
					bMPGUAAxisGearIn:=FALSE;
					nMPG_A_State:=nMPG_A_State+1;
				END_IF

			3:	(* Request Gear Out *)
				IF bMPGUAAxisGearOut AND fbMPGUAAxisGearOut.Done AND NOT(fbMPGUAAxisGearOut.Error) THEN
					bMPGUAAxisGearOut:=FALSE;
					nMPG_A_State := nMPG_A_State+1;
				ELSIF bMPGUAAxisGearOut AND fbMPGUAAxisGearOut.Error THEN
					bMPGUAAxisGearOut:=FALSE;
					nMPGA_ErrorID := fbMPGUAAxisGearOut.ErrorID;
					nMPG_A_State:=4;
				ELSE
					bMPGUAAxisGearOut:=TRUE;
				END_IF

			4:	(* Request Axis Stop *)
				IF bUStop AND fbUAxisStop.Done	AND NOT(fbUAxisStop.Error) THEN
					bUStop:=FALSE;
					nMPG_A_State:=nMPG_A_State+1;
				ELSIF bUStop AND fbUAxisStop.Error THEN
					bUStop:=FALSE;
					nMPG_A_State:=5;
				ELSE
					bUStop:=TRUE;
				END_IF

			5:	(* Fault/Clean Up State *)
				bUStop:=FALSE;
				bMPGUAAxisGearIn:=FALSE;
				bMPGUAAxisGearOut:=FALSE;
				IF NOT(bXAAxisSelected) THEN
					nMPG_A_State:=0;
					MPGMode := 0;
				END_IF
			END_CASE	(* U *)

		3: (* ZA Axis Selected *)
			CASE nMPG_A_State OF
			0:	(* INIT *)
				IF NOT bZAAxisSelected THEN
					MPGMode := 0;
				ELSE
					nMPG_A_State := nMPG_A_State + 1;
				END_IF

			1:	(* Request Gear In *)
				IF bMPGZAAxisGearIn AND fbMPGZAAxisGearIn.InGear THEN
					nMPG_A_State:=nMPG_A_State+1;
				ELSIF bMPGZAAxisGearIn AND fbMPGZAAxisGearIn.Error THEN
					bMPGZAAxisGearIn := FALSE;
					nMPGA_ErrorID := fbMPGZAAxisGearIn.ErrorID;
					nMPG_A_State := 5;
				ELSE
					bMPGZAAxisGearIn:=TRUE;
				END_IF

			2:	(* Wait for Axis Selector Change or end if a Fault Occurs *)
				IF NOT(bZAAxisSelected) OR bMachineFault THEN
					bMPGZAAxisGearIn:=FALSE;
					nMPG_A_State:=nMPG_A_State+1;
				END_IF

			3:	(* Request Gear Out *)
				IF bMPGZAAxisGearOut AND fbMPGZAAxisGearOut.Done AND NOT(fbMPGZAAxisGearOut.Error) THEN
					bMPGZAAxisGearOut:=FALSE;
					nMPG_A_State := nMPG_A_State+1;
				ELSIF bMPGZAAxisGearOut AND fbMPGZAAxisGearOut.Error THEN
					bMPGZAAxisGearOut:=FALSE;
					nMPGA_ErrorID := fbMPGZAAxisGearOut.ErrorID;
					nMPG_A_State:=4;
				ELSE
					bMPGZAAxisGearOut:=TRUE;
				END_IF

			4:	(* Request Axis Stop *)
				IF bZAStop AND fbZAAxisStop.Done	AND NOT(fbZAAxisStop.Error) THEN
					bZAStop:=FALSE;
					nMPG_A_State:=nMPG_A_State+1;
				ELSIF bZAStop AND fbZAAxisStop.Error THEN
					bZAStop:=FALSE;
					nMPG_A_State:=5;
				ELSE
					bZAStop:=TRUE;
				END_IF

			5:	(* Fault/Clean Up State *)
				bZAStop:=FALSE;
				bMPGZAAxisGearIn:=FALSE;
				bMPGZAAxisGearOut:=FALSE;
				IF NOT(bZAAxisSelected) THEN
					nMPG_A_State:=0;
					MPGMode := 0;
				END_IF
			END_CASE	(* ZA *)

		4: (* WA Axis Selected *)
			CASE nMPG_A_State OF
			0:	(* INIT *)
				IF NOT bWAAxisSelected THEN
					MPGMode := 0;
				ELSE
					nMPG_A_State := nMPG_A_State + 1;
				END_IF

			1:	(* Request Gear In *)
				IF bMPGWAAxisGearIn AND fbMPGWAAxisGearIn.InGear THEN
					nMPG_A_State:=nMPG_A_State+1;
				ELSIF bMPGWAAxisGearIn AND fbMPGWAAxisGearIn.Error THEN
					bMPGWAAxisGearIn := FALSE;
					nMPGA_ErrorID := fbMPGWAAxisGearIn.ErrorID;
					nMPG_A_State := 5;
				ELSE
					bMPGWAAxisGearIn:=TRUE;
				END_IF

			2:	(* Wait for Axis Selector Change or end if a Fault Occurs *)
				IF NOT(bWAAxisSelected) OR bMachineFault THEN
					nMPG_A_State:=nMPG_A_State+1;
				END_IF

			3:	(* Request Gear Out *)
				IF bMPGWAAxisGearOut AND fbMPGWAAxisGearOut.Done AND NOT(fbMPGWAAxisGearOut.Error) THEN
					bMPGWAAxisGearOut:=FALSE;
					nMPG_A_State := nMPG_A_State+1;
				ELSIF bMPGWAAxisGearOut AND fbMPGWAAxisGearOut.Error THEN
					bMPGWAAxisGearOut:=FALSE;
					nMPGA_ErrorID := fbMPGWAAxisGearOut.ErrorID;
					nMPG_A_State:=4;
				ELSE
					bMPGWAAxisGearIn:=FALSE;
					bMPGWAAxisGearOut:=TRUE;
				END_IF

			4:	(* Request Axis Stop *)
				IF bWAStop AND fbWAAxisStop.Done AND NOT(fbWAAxisStop.Error) THEN
					bWAStop:=FALSE;
					nMPG_A_State:=nMPG_A_State+1;
				ELSIF bWAStop AND fbWAAxisStop.Error THEN
					bWAStop:=FALSE;
					nMPG_A_State:=5;
				ELSE
					bWAStop:=TRUE;
				END_IF

			5:	(* Fault/Clean Up State *)
				bWAStop:=FALSE;
				bMPGWAAxisGearIn:=FALSE;
				bMPGWAAxisGearOut:=FALSE;
				IF NOT(bWAAxisSelected) THEN
					nMPG_A_State:=0;
					MPGMode := 0;
				END_IF
			END_CASE	(* WA *)

		5: (* XB Axis Selected *)
			CASE nMPG_B_State OF
			0:	(* INIT *)
				IF NOT bXBAxisSelected THEN
					MPGMode := 0;
				ELSE
					nMPG_B_State := nMPG_B_State + 1;
				END_IF

			1:	(* Request Gear In *)
				IF bMPGXBAxisGearIn AND fbMPGXBAxisGearIn.InGear THEN
					nMPG_B_State:=nMPG_B_State+1;
				ELSIF bMPGXBAxisGearIn AND fbMPGXBAxisGearIn.Error THEN
					bMPGXBAxisGearIn := FALSE;
					nMPGB_ErrorID := fbMPGXBAxisGearIn.ErrorID;
					nMPG_B_State := 5;
				ELSE
					bMPGXBAxisGearIn:=TRUE;
				END_IF

			2:	(* Wait for Axis Selector Change or end if a Fault Occurs *)
				IF NOT(bXBAxisSelected) OR bMachineFault THEN
					nMPG_B_State:=nMPG_B_State+1;
				END_IF

			3:	(* Request Gear Out *)
				IF bMPGXBAxisGearOut AND fbMPGXBAxisGearOut.Done AND NOT(fbMPGXBAxisGearOut.Error) THEN
					bMPGXBAxisGearOut:=FALSE;
					nMPG_B_State := nMPG_B_State+1;
				ELSIF bMPGXBAxisGearOut AND fbMPGXBAxisGearOut.Error THEN
					bMPGXBAxisGearOut:=FALSE;
					nMPGB_ErrorID := fbMPGXBAxisGearOut.ErrorID;
					nMPG_B_State:=4;
				ELSE
					bMPGXBAxisGearIn:=FALSE;
					bMPGXBAxisGearOut:=TRUE;
				END_IF

			4:	(* Request Axis Stop *)
				IF bUStop AND fbUAxisStop.Done AND NOT(fbUAxisStop.Error) THEN
					bUStop:=FALSE;
					nMPG_B_State:=nMPG_B_State+1;
				ELSIF bUStop AND fbUAxisStop.Error THEN
					bUStop:=FALSE;
					nMPG_B_State:=5;
				ELSE
					bUStop:=TRUE;
				END_IF

			5:	(* Fault/Clean Up State *)
				bUStop:=FALSE;
				bMPGXBAxisGearIn:=FALSE;
				bMPGXBAxisGearOut:=FALSE;
				IF NOT(bXBAxisSelected) THEN
					nMPG_B_State:=0;
					MPGMode := 0;
				END_IF
			END_CASE	(* XB *)

		7: (* ZB Axis Selected *)
			CASE nMPG_B_State OF
			0:	(* INIT *)
				IF NOT bZBAxisSelected THEN
					MPGMode := 0;
				ELSE
					nMPG_B_State := nMPG_B_State + 1;
				END_IF

			1:	(* Request Gear In *)
				IF bMPGZBAxisGearIn AND fbMPGZBAxisGearIn.InGear THEN
					nMPG_B_State:=nMPG_B_State+1;
				ELSIF bMPGZBAxisGearIn AND fbMPGZBAxisGearIn.Error THEN
					bMPGZBAxisGearIn := FALSE;
					nMPGB_ErrorID := fbMPGZBAxisGearIn.ErrorID;
					nMPG_B_State := 5;
				ELSE
					bMPGZBAxisGearIn:=TRUE;
				END_IF

			2:	(* Wait for Axis Selector Change or end if a Fault Occurs *)
				IF NOT(bZBAxisSelected) OR bMachineFault THEN
					bMPGZBAxisGearIn:=FALSE;
					nMPG_B_State:=nMPG_B_State+1;
				END_IF

			3:	(* Request Gear Out *)
				IF bMPGZBAxisGearOut AND fbMPGZBAxisGearOut.Done AND NOT(fbMPGZBAxisGearOut.Error) THEN
					bMPGZBAxisGearOut:=FALSE;
					nMPG_B_State := nMPG_B_State+1;
				ELSIF bMPGZBAxisGearOut AND fbMPGZBAxisGearOut.Error THEN
					bMPGZBAxisGearOut:=FALSE;
					nMPGB_ErrorID := fbMPGZBAxisGearOut.ErrorID;
					nMPG_B_State:=4;
				ELSE
					bMPGZBAxisGearOut:=TRUE;
				END_IF

			4:	(* Request Axis Stop *)
				IF bZBStop AND fbZBAxisStop.Done	AND NOT(fbZBAxisStop.Error) THEN
					bZBStop:=FALSE;
					nMPG_B_State:=nMPG_B_State+1;
				ELSIF bZBStop AND fbZBAxisStop.Error THEN
					bZBStop:=FALSE;
					nMPG_B_State:=5;
				ELSE
					bZBStop:=TRUE;
				END_IF

			5:	(* Fault/Clean Up State *)
				bZBStop:=FALSE;
				bMPGZBAxisGearIn:=FALSE;
				bMPGZBAxisGearOut:=FALSE;
				IF NOT(bZBAxisSelected) THEN
					nMPG_B_State:=0;
					MPGMode := 0;
				END_IF
			END_CASE	(* ZB *)

		8: (* WB Axis Selected *)
			CASE nMPG_B_State OF
			0:	(* INIT *)
				IF NOT bWBAxisSelected THEN
					MPGMode := 0;
				ELSE
					nMPG_B_State := nMPG_B_State + 1;
				END_IF

			1:	(* Request Gear In *)
				IF bMPGWBAxisGearIn AND fbMPGWBAxisGearIn.InGear THEN
					nMPG_B_State:=nMPG_B_State+1;
				ELSIF bMPGWBAxisGearIn AND fbMPGWBAxisGearIn.Error THEN
					bMPGWBAxisGearIn := FALSE;
					nMPGB_ErrorID := fbMPGWBAxisGearIn.ErrorID;
					nMPG_B_State := 5;
				ELSE
					bMPGWBAxisGearIn:=TRUE;
				END_IF

			2:	(* Wait for Axis Selector Change or end if a Fault Occurs *)
				IF NOT(bWBAxisSelected) OR bMachineFault THEN
					nMPG_B_State:=nMPG_B_State+1;
				END_IF

			3:	(* Request Gear Out *)
				IF bMPGWBAxisGearOut AND fbMPGWBAxisGearOut.Done AND NOT(fbMPGWBAxisGearOut.Error) THEN
					bMPGWBAxisGearOut:=FALSE;
					nMPG_B_State := nMPG_B_State+1;
				ELSIF bMPGWBAxisGearOut AND fbMPGWBAxisGearOut.Error THEN
					bMPGWBAxisGearOut:=FALSE;
					nMPGB_ErrorID := fbMPGWBAxisGearOut.ErrorID;
					nMPG_B_State:=4;
				ELSE
					bMPGWBAxisGearIn:=FALSE;
					bMPGWBAxisGearOut:=TRUE;
				END_IF

			4:	(* Request Axis Stop *)
				IF bWBStop AND fbWBAxisStop.Done AND NOT(fbWBAxisStop.Error) THEN
					bWBStop:=FALSE;
					nMPG_B_State:=nMPG_B_State+1;
				ELSIF bWBStop AND fbWBAxisStop.Error THEN
					bWBStop:=FALSE;
					nMPG_B_State:=5;
				ELSE
					bWBStop:=TRUE;
				END_IF

			5:	(* Fault/Clean Up State *)
				bWBStop:=FALSE;
				bMPGWBAxisGearIn:=FALSE;
				bMPGWBAxisGearOut:=FALSE;
				IF NOT(bWBAxisSelected) THEN
					nMPG_B_State:=0;
					MPGMode := 0;
				END_IF
			END_CASE	(* WB *)

	END_CASE	(* Check for MPG Selection *)

ELSE (* Auto Mode or MCC_S is out *)
	bMPGUAAxisGearIn := FALSE;
	bMPGZAAxisGearIn := FALSE;
	bMPGWAAxisGearIn := FALSE;
	bMPGXBAxisGearIn:=FALSE;
	bMPGZBAxisGearIn:=FALSE;
	bMPGWBAxisGearIn:=FALSE;

	bMPGUAAxisGearOut := TRUE;
	bMPGZAAxisGearOut := TRUE;
	bMPGWAAxisGearOut := TRUE;
	bMPGXBAxisGearOut := TRUE;
	bMPGZBAxisGearOut := TRUE;
	bMPGWBAxisGearOut := TRUE;

END_IF

(* Set the Side A MPG Rate by the Selector Switch Input *)
IF bARate1X THEN
	MPG_A_Rate := 1;
ELSIF bARate10X THEN
	MPG_A_Rate := 10;
ELSIF bARate100X THEN
	MPG_A_Rate := 100;
END_IF

(* Set the Side B MPG Rate by the Selector Switch Input *)
IF bBRate1X THEN
	MPG_B_Rate := 1;
ELSIF bBRate10X THEN
	MPG_B_Rate := 10;
ELSIF bBRate100X THEN
	MPG_B_Rate := 100;
END_IF

(*		SIDE A 	 MPG		*)
fbMPGUAOn(CLK:= bXAAxisSelected AND fbAAxisSelectDelay.Q);
fbMPGYAOn(CLK:= bYAAxisSelected AND fbAAxisSelectDelay.Q);
fbMPGZAOn(CLK:= bZAAxisSelected AND fbAAxisSelectDelay.Q);
fbMPGWAOn(CLK:= bWAAxisSelected AND fbAAxisSelectDelay.Q);
fbAAxisSelectDelay(IN:= (bWAAxisSelected XOR bXAAxisSelected XOR bYAAxisSelected XOR bZAAxisSelected)
, PT:=t#500ms);

fbMPGAAxisEnable(
	Enable:=bMPGAAxisEnable ,
	Enable_Positive:= bMPGAAxisEnable ,
	Enable_Negative:= bMPGAAxisEnable ,
	Override:=100 ,
	BufferMode:=MC_Aborting ,
	Axis := stAxisMPG_A );

fGearRatioA := MPG_A_Rate/100.0;

fbMPGUAAxisGearIn(
	Enable:= bMPGUAAxisGearIn ,
	GearRatio:= -fGearRatioA ,
	Acceleration:=0 ,
	Deceleration:=0 ,
	Jerk:=0 ,
	Master := stAxisMPG_A ,
	Slave := stUAxis
);

fbMPGUAAxisGearOut(
	Execute := bMPGUAAxisGearOut ,
	Slave := stUAxis
);

fbMPGWAAxisGearIn(
	Enable:= bMPGWAAxisGearIn ,
	GearRatio:= -fGearRatioA ,
	Acceleration:=0 ,
	Deceleration:=0 ,
	Jerk:=0 ,
	Master := stAxisMPG_A ,
	Slave := stWAAxis
);

fbMPGWAAxisGearOut(
	Execute := bMPGWAAxisGearOut ,
	Slave := stWAAxis
);

fbMPGZAAxisGearIn(
	Enable:= bMPGZAAxisGearIn ,
	GearRatio:= -fGearRatioA ,
	Acceleration:=0 ,
	Deceleration:=0 ,
	Jerk:=0 ,
	Master := stAxisMPG_A ,
	Slave := stZAAxis
);

fbMPGZAAxisGearOut(
	Execute:= bMPGZAAxisGearOut ,
	Slave:=stZAAxis
);

(*		SIDE B		 MPG		*)
fbMPGXBOn(CLK:= bXBAxisSelected AND fbBAxisSelectDelay.Q);
fbMPGYBOn(CLK:= bYBAxisSelected AND fbBAxisSelectDelay.Q);
fbMPGZBOn(CLK:= bZBAxisSelected AND fbBAxisSelectDelay.Q);
fbMPGWBOn(CLK:= bWBAxisSelected AND fbBAxisSelectDelay.Q);
fbBAxisSelectDelay(IN:= (bWBAxisSelected XOR bXBAxisSelected XOR bYBAxisSelected XOR bZBAxisSelected)
, PT:=t#500ms);

fbMPGBAxisEnable(
	Enable:=bMPGBAxisEnable ,
	Enable_Positive:= bMPGBAxisEnable ,
	Enable_Negative:= bMPGBAxisEnable ,
	Override:=100 ,
	BufferMode:=MC_Aborting ,
	Axis := stAxisMPG_B );

fGearRatioB := MPG_B_Rate/100.0;

fbMPGWBAxisGearIn(
	Enable:= bMPGWBAxisGearIn ,
	GearRatio:= -fGearRatioB ,
	Acceleration:=0 ,
	Deceleration:=0 ,
	Jerk:=0 ,
	Master := stAxisMPG_B ,
	Slave := stWBAxis
);

fbMPGWBAxisGearOut(
	Execute := bMPGWBAxisGearOut ,
	Slave := stWBAxis
);

fbMPGXBAxisGearIn(
	Enable:= bMPGXBAxisGearIn ,
	GearRatio:= -fGearRatioB ,
	Acceleration:=0 ,
	Deceleration:=0 ,
	Jerk:=0 ,
	Master := stAxisMPG_B ,
	Slave := stUAxis
);

fbMPGXBAxisGearOut(
	Execute := bMPGXBAxisGearOut ,
	Slave := stUAxis
);

fbMPGZBAxisGearIn(
	Enable:= bMPGZBAxisGearIn ,
	GearRatio:= -fGearRatioB ,
	Acceleration:=0 ,
	Deceleration:=0 ,
	Jerk:=0 ,
	Master := stAxisMPG_B ,
	Slave := stZBAxis
);

fbMPGZBAxisGearOut(
	Execute:= bMPGZBAxisGearOut ,
	Slave:=stZBAxis
);


(* Reset the MPG Axis *)
IF fbMPGAAxisMCReset.Done OR fbMPGAAxisMCReset.Error THEN
	bMPGA_MCResetRequest:=FALSE;
END_IF
fbMPGAAxisMCReset(
	Execute:=bMPGA_MCResetRequest,
	Axis:=stAxisMPG_A );

IF fbMPGBAxisMCReset.Done OR fbMPGBAxisMCReset.Error THEN
	bMPGB_MCResetRequest:=FALSE;
END_IF
fbMPGBAxisMCReset(
	Execute:=bMPGB_MCResetRequest,
	Axis:=stAxisMPG_B );

fbMPGWatchdog(IN:=bMPGWatchdog, PT:= t#150ms);
fbMPGBWatchdog(IN:=bMPGBWatchdog, PT:= t#150ms);
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM P_PartProgramStorage
VAR
	fbPartProgramSaveRTRIG: R_TRIG;			(* Trigger for Part Program Save PB *)
	fbPartProgramLoadRTRIG: R_TRIG;			(* Trigger for Part Program Load PB *)
	bSave: BOOL := FALSE;
	bLoad: BOOL := FALSE;
	bFailed: BOOL := FALSE;
	bSuccess: BOOL := FALSE;

	(* Function Blocks w/ Helpers *)
	fbFileOpen: FB_FileOpen;
	bFileOpen: BOOL := FALSE;
	fbFileClose: FB_FileClose;
	nOpenType: DWORD;
	bFileClose: BOOL := FALSE;
	fbFilePuts: FB_FilePuts;
	bFilePuts: BOOL := FALSE;
	fbFileGets: FB_FileGets;
	bFileGets: BOOL := FALSE;
	hFileHandle: UINT := 0;
	sFileName: T_MaxString := '';

	(* State Variables *)
	nStep: USINT := 0;

	(* Read Variables  Note: if size changes it must be changed here and in the program below *)
	arrDataRead: ARRAY [1..25] OF T_MaxString;
	nReadCount: USINT := 0;

	(* Write Variables *)
	arrDataWrite: ARRAY [1..25] OF T_MaxString;
	nWriteCount: USINT := 0;

	nTestCount: INT := 0;		(* Test Counter *)
	bTestbit1: BOOL := FALSE;		(* Test Bit *)
END_VAR
(* @END_DECLARATION := '0' *)

fbPartProgramSaveRTRIG(CLK:= bPartProgramSavePB);
fbPartProgramLoadRTRIG(CLK:= bPartProgramLoadPB);

IF fbPartProgramSaveRTRIG.Q AND NOT(bSave OR bLoad) THEN
	(* When the Yes PB is pressed then check the password input *)
	IF sSavePassword=sPasswordSupervisorUC OR
		sSavePassword=sPasswordSupervisor OR
		sSavePassword=sPasswordSuperUC OR
		sSavePassword=sPasswordSuper
	THEN	(* Reset Values *)
		bFailed:=FALSE;
		bSuccess:=FALSE;
		sFileOpError:='';
		bSave:=TRUE;
		sSavePassword:='';
	END_IF
ELSIF fbPartProgramLoadRTRIG.Q AND NOT(bSave OR bLoad) THEN
	bFailed:=FALSE;
	sFileOpError:='';
	bSuccess:=FALSE;
	bLoad:=TRUE;
END_IF

sFileName:=CONCAT('\Hard Disk\ftp\',CONCAT(sPartProgramName, '.CSV'));


(* Load Part Program *)
IF bLoad AND NOT(bSave) THEN
	CASE nStep OF
	0:(* Open File *)
		nOpenType:=FOPEN_MODEREAD;
		(*ERROR*)
		IF bFileOpen AND fbFileOpen.bError THEN
			bFileOpen:=FALSE;
			bLoad:=FALSE;
			bFailed:=TRUE;
			sFileOpError:=CONCAT('Open Error:  ',UDINT_TO_STRING(fbFileOpen.nErrId));
		ELSIF bFileOpen AND NOT(fbFileOpen.bBusy) THEN
			bFileOpen:=FALSE;
			nReadCount:=1;
			nStep:=nStep+1;
		END_IF
		bFileOpen:=TRUE;

	1:(* Read File *)
		IF (nReadCount<=25) OR NOT(fbFileGets.bEOF) THEN
			(*ERROR*)
			IF bFileGets AND fbFileGets.bError THEN
				nStep:=nStep+1;
				bFailed:=TRUE;
				sFileOpError:=CONCAT('Read Error:  ',UDINT_TO_STRING(fbFileGets.nErrId));
			ELSIF bFileGets AND NOT(fbFileGets.bBusy) THEN
				arrDataRead[nReadCount]:=fbFileGets.sLine;
				bFileGets:=FALSE;
				nReadCount:=nReadCount+1;
			ELSIF NOT(bFileGets) THEN
				bFileGets:=TRUE;
			END_IF
		END_IF
		IF nReadCount>25 THEN
			nStep:=nStep+1;
		END_IF

	2:(* Close File *)
		(*ERROR*)
		IF bFileClose AND fbFileClose.bError THEN
			sFileOpError:=CONCAT('Close Error:  ',UDINT_TO_STRING(fbFileClose.nErrId));
			bFileClose:=FALSE;
			bLoad:=FALSE;
			bFailed:=TRUE;
		ELSIF bFileClose AND NOT(fbFileClose.bBusy) THEN
			bFileClose:=FALSE;
			IF bFailed THEN
				bLoad:=FALSE;
			ELSE
				nStep:=nStep+1;
			END_IF
		END_IF
		bFileClose:=TRUE;

	3:(* Convert Data / Done *)
		fStartFeed				:= STRING_TO_LREAL(arrDataRead[2]);
		fFinishFeed 				:= STRING_TO_LREAL(arrDataRead[3]);
		fStartDepth 				:= STRING_TO_LREAL(arrDataRead[4]);
		fFinishDepth 				:= STRING_TO_LREAL(arrDataRead[5]);
		fDwellTime 				:= STRING_TO_LREAL(arrDataRead[6]);
		fRetractRate 				:= STRING_TO_LREAL(arrDataRead[7]);
		fDrillTipOffset				:= STRING_TO_LREAL(arrDataRead[8]);
		fRPMRequest			:= STRING_TO_LREAL(arrDataRead[9]);
		fToolDiameter			:= STRING_TO_LREAL(arrDataRead[10]);
		fCoolantPressure			:= STRING_TO_LREAL(arrDataRead[11]);
		fCoolantFlowMax			:= STRING_TO_LREAL(arrDataRead[12]);
		fCoolantFlowMin			:= STRING_TO_LREAL(arrDataRead[13]);
		nMaxCycles				:= LREAL_TO_UDINT(STRING_TO_LREAL(arrDataRead[14]));
		fWAxisTransferPosition		:= STRING_TO_LREAL(arrDataRead[15]);
		fWAxisDrillPosition		:= STRING_TO_LREAL(arrDataRead[16]);
		fWAxisMoveOffBushing		:= STRING_TO_LREAL(arrDataRead[17]);
		(*	:= STRING_TO_LREAL(arrDataRead[18]);		*)
		bSpindleRetractMode		:= STRING_TO_BOOL(arrDataRead[19]);
		nSpindleLoadMax			:= LREAL_TO_UDINT(STRING_TO_LREAL(arrDataRead[20]));
		nServoThrustMax			:= LREAL_TO_UDINT(STRING_TO_LREAL(arrDataRead[21]));
		(*	:=STRING_TO_LREAL(arrDataRead[22]);		*)
		(*	:=STRING_TO_LREAL(arrDataRead[23]);		*)
		(*	:=STRING_TO_LREAL(arrDataRead[24]);		*)
		(*	:=STRING_TO_LREAL(arrDataRead[25]);		*)
		(* IF MORE THAN 25 VARIABLES
			THEN MUST CHANGE nReadCount COMPARASONS IN nStep 1 *)
		nStep:=nStep+1;

	4:(* Done *)
		nStep:=0;
		bLoad:=FALSE;
		bSuccess:=TRUE;
		sLastLoadedPartProgramName := sPartProgramName;
		sCurrentPartProgram := sPartProgramName;

	END_CASE


ELSIF bSave AND NOT(bLoad) THEN
	CASE nStep OF
	0:(* Prepare Data *)
		arrDataWrite[1]	:= CONCAT(sPartProgramName,'$L');
		arrDataWrite[2]	:= CONCAT(LREAL_TO_STRING(fStartFeed),'$L');
		arrDataWrite[3]	:= CONCAT(LREAL_TO_STRING(fFinishFeed),'$L');
		arrDataWrite[4]	:= CONCAT(LREAL_TO_STRING(fStartDepth),'$L');
		arrDataWrite[5]	:= CONCAT(LREAL_TO_STRING(fFinishDepth),'$L');
		arrDataWrite[6]	:= CONCAT(LREAL_TO_STRING(fDwellTime),'$L');
		arrDataWrite[7]	:= CONCAT(LREAL_TO_STRING(fRetractRate),'$L');
		arrDataWrite[8]	:= CONCAT(LREAL_TO_STRING(fDrillTipOffset),'$L');
		arrDataWrite[9]	:= CONCAT(LREAL_TO_STRING(fRPMRequest),'$L');
		arrDataWrite[10]	:= CONCAT(LREAL_TO_STRING(fToolDiameter),'$L');
		arrDataWrite[11]	:= CONCAT(LREAL_TO_STRING(fCoolantPressure),'$L');
		arrDataWrite[12]	:= CONCAT(LREAL_TO_STRING(fCoolantFlowMax),'$L');
		arrDataWrite[13]	:= CONCAT(LREAL_TO_STRING(fCoolantFlowMin),'$L');
		arrDataWrite[14]	:= CONCAT(UDINT_TO_STRING(nMaxCycles),'$L');
		arrDataWrite[15]	:= CONCAT(LREAL_TO_STRING(fWAxisTransferPosition),'$L');
		arrDataWrite[16]	:= CONCAT(LREAL_TO_STRING(fWAxisDrillPosition),'$L');
		arrDataWrite[17]	:= CONCAT(LREAL_TO_STRING(fWAxisMoveOffBushing),'$L');
		arrDataWrite[18]	:= '$L';
		arrDataWrite[19]	:= CONCAT(BOOL_TO_STRING(bSpindleRetractMode),'$L');
		arrDataWrite[20]	:= CONCAT(UDINT_TO_STRING(nSpindleLoadMax),'$L');
		arrDataWrite[21]	:= CONCAT(UDINT_TO_STRING(nServoThrustMax),'$L');
		arrDataWrite[22]	:= '$L';
		arrDataWrite[23]	:= '$L';
		arrDataWrite[24]	:= '$L';
		arrDataWrite[25]	:= '$L';
		(* IF MORE THAN 25 VARIABLES
			THEN MUST CHANGE nReadCount COMPARASONS IN nStep 1 *)
		nStep:=nStep+1;

	1:(* Open File *)
		nOpenType:=FOPEN_MODEWRITE;
		(*ERROR*)
		IF bFileOpen AND fbFileOpen.bError THEN
			bFileOpen:=FALSE;
			bSave:=FALSE;
			bFailed:=TRUE;
			sFileOpError:=CONCAT('Open Error:  ',UDINT_TO_STRING(fbFileOpen.nErrId));
		ELSIF bFileOpen AND NOT(fbFileOpen.bBusy) THEN
			bFileOpen:=FALSE;
			nWriteCount:=1;
			nStep:=nStep+1;
		END_IF
		bFileOpen:=TRUE;

	2:(* Write File *)
		(* Wrie the string from the array until we write all of the data *)
		IF (nWriteCount<=25) THEN
			(*ERROR*)
			IF bFilePuts AND fbFilePuts.bError THEN
				nStep:=nStep+1;
				bFailed:=TRUE;
				sFileOpError:=CONCAT('WriteError:  ',UDINT_TO_STRING(fbFilePuts.nErrId));
			(* when no longer bussy then we incriment the count *)
			ELSIF bFilePuts AND NOT(fbFilePuts.bBusy) THEN
				bFilePuts:=FALSE;
				nWriteCount:=nWriteCount+1;
			(* Push the next value into the line and trigger the move (fileputs) *)
			ELSIF NOT(bFilePuts) THEN
				fbFilePuts.sLine:=arrDataWrite[nWriteCount];
				bFilePuts:=TRUE;
			END_IF
		(* Once we've put all of the date into the file we move to the next step *)
		ELSIF nWriteCount>25 THEN
			nStep:=nStep+1;
		END_IF
;
	3:(* Close File *)
		(*ERROR*)
		IF bFileClose AND fbFileClose.bError THEN
			bFileClose:=FALSE;
			bSave:=FALSE;
			bFailed:=TRUE;
			sFileOpError:=CONCAT('Close Error:  ',UDINT_TO_STRING(fbFileClose.nErrId));
		ELSIF bFileClose AND NOT(fbFileClose.bBusy) THEN
			IF NOT(bFailed) THEN
				bSuccess:=TRUE;
			END_IF
			bFileClose:=FALSE;
			bSave:=FALSE;
			nStep:=0;
		END_IF
		bFileClose:=TRUE;

	END_CASE

ELSE (* Not bLoad or bSave *)
	nStep:=0;
	nReadCount:=0;
	nWriteCount:=0;
	bFileOpen:=FALSE;
	bFileClose:=FALSE;
	bFilePuts:=FALSE;
	bFileGets:=FALSE;
END_IF

fbFileOpen(
	sNetId:='' ,
	sPathName:=sFileName ,
	nMode:=nOpenType ,
	ePath:=PATH_GENERIC ,
	bExecute:=bFileOpen ,
	tTimeout:=t#30s
);
hFileHandle:=fbFileOpen.hFile;
fbFileClose(
	sNetId:='' ,
	hFile:= hFileHandle ,
	bExecute:= bFileClose,
	tTimeout:= t#30s
);
fbFileGets(
	sNetId:= '' ,
	hFile:= hFileHandle ,
	bExecute:= bFileGets ,
	tTimeout:=t#30s
);
fbFilePuts(
	sNetId:= '',
	hFile:= hFileHandle,
	sLine:= ,
	bExecute:= bFilePuts ,
	tTimeout:= t#30s
);
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM P_SaveData
VAR
	fbSaveData : FB_WritePersistentData;
	nMotorNominalRPMStore : UDINT := 0;
	sSerialNumberStore  : STRING(20) := '';		(* This holds the serial number of the machine *)
	sKaysJobNumberStore  : STRING(20) := '';		(* This holds the Kayse Engineering Job number of the machine *)
	sModelNumberStore : STRING(20) := '';		(* This variable holds the model of the machine *)
	sCustomerNameStore : STRING(20) := '';		(* This variable holds the customers name *)
	nMachineNumberStore : UDINT := 1;			(* The Machine Number designates what number the machines were delivered in for this series of special machines *)
	sProductionDateStore : STRING(10) := '';		(* This variable holds the date of production and should match that of the machine tags *)

	sLoadSideSetStore : STRING(30) :='None';	(* Holds the side that is currently set as Infeed *)
	nWAAxisThrustMaxStore: UDINT := 100;		(* Tailstock WA Axis Max Thrust *)
	nWBAxisThrustMaxStore: UDINT := 100;		(* Tailstock WB Axis Max Thrust *)
	nUAxisThrustMaxStore : UDINT :=100;		(* Max Thrust Set in secret screen *)
	fWAAxisHomeOffsetStore : LREAL;			(* A Tailstock WA Axis Offset Durring Homing *)
	fWBAxisHomeOffsetStore : LREAL;			(* B Tailstock WB Axis Offset Durring Homing *)
	fWAxisMoveOffBushingStore : LREAL;		(* Amount to Back W Axis' off of Bushing After Drill *)
	nTailstockClampingTorqueLimitStore: INT;
	fTailstockVelocityStore : LREAL;
	fUAxisVelocityStore : LREAL;
	fUAxisLoadSidePositionStore : LREAL;
	fUAxisUnloadSidePositionStore : LREAL;


	nCyclesCompleteStore : UDINT := 0;			(* Holds the # of completed cycles for Ream mode *)
	nMaxCyclesStore : UDINT := 0;				(* Holds the # of Max cycles for Ream mode *)
	sLastLoadedPartProgramNameStore : STRING(25) := '';
	fFlowMonitorMaxStore : LREAL := 0;
	bSideAEnabledStore : BOOL;					(* Enable of Machine Side B *)
	bSideBEnabledStore : BOOL;					(* Enable of Machine Side B *)


	(* Fault History Write Variables *)
	arrFaultHistoryStore : ARRAY[1..80] OF T_MaxString := 80('');	(* This holds the fault history array *)
	bFaultHistoryChanged : BOOL := FALSE;		(* bit to say that the stored value of Fault history does not match actual *)
	bFaultHistoryEmpty : BOOL := FALSE;			(* bit to say that the Fault history has not been loaded into the machine yet *)
	fbWriteFaultHistroyTrigger : TON;			(* A timer to delay the write of fault history *)
	nFaultHistoryStoreStep : UDINT := 0;			(* Fault History Write Counter *)
	nFaultHistoryReadStep : UDINT := 0;			(* Fault History Read Counter *)
	nReadLineStep : UDINT := 0;				(* Fault History Read Line Counter *)
	nCount: UDINT := 0;						(* Counter for Fault History Array *)
	nWriteLineStep : UDINT := 0;				(* Fault History Read Line Counter *)
	stFileName: T_MaxString := '';
	bFileClose: BOOL := FALSE;
	bFileWrite: BOOL := FALSE;
	bFileReadLine: BOOL := FALSE;
	bFileOpen: BOOL := FALSE;
	nOpenMode: UDINT := 0;
	fbFileOpen: FB_FileOpen;
	fbFileWrite: FB_FilePuts;
	fbFileReadLine: FB_FileGets;
	fbFileClose: FB_FileClose;
	nLoopIndex: UDINT := 0;						(* Counter for "FOR" loop  to Clear Fault History *)
	stOutVal: T_MaxString:='';					(* String to wrie to file *)
	stInVal: T_MaxString:='';					(* String to read from file *)

END_VAR
(* @END_DECLARATION := '0' *)
(* When one of the persistent data values change fromt he save value,
	then we trigger a write of the persistent data *)
IF 	nMotorNominalRPMStore<>nMotorNominalRPM OR
	sSerialNumberStore<>sSerialNumber OR
	sModelNumberStore<>sModelNumber OR
	sKaysJobNumberStore<>sKaysJobNumber OR
	sCustomerNameStore<>sCustomerName OR
	sProductionDateStore<>sProductionDate OR
	nMachineNumberStore <> nMachineNumber OR
	nCyclesCompleteStore<>nCyclesComplete OR
	nMaxCyclesStore<>nMaxCycles OR
	sLastLoadedPartProgramNameStore<>sLastLoadedPartProgramName OR
	fFlowMonitorMaxStore<>fFlowMonitorMax OR

	sLoadSideSetStore <> sLoadSideSet OR
	nUAxisThrustMaxStore <> nUAxisThrustMax OR
	fWAAxisHomeOffsetStore <> fWAAxisHomeOffset OR
	fWBAxisHomeOffsetStore <> fWBAxisHomeOffset OR
	fWAxisMoveOffBushingStore <> fWAxisMoveOffBushing OR
	nTailstockClampingTorqueLimitStore <> nTailstockClampingTorqueLimit OR
	fTailstockVelocityStore <> fTailstockVelocity OR
	bSideAEnabledStore <> bSideAEnabled OR
	bSideBEnabledStore <> bSideBEnabled OR
	fUAxisVelocityStore <> fUAxisVelocity OR
	fUAxisLoadSidePositionStore <> fUAxisLoadSidePosition OR
	fUAxisUnloadSidePositionStore <> fUAxisUnloadSidePosition

THEN
	fbSaveData(
		NETID:= ,
		PORT:=801 ,
		START:=TRUE ,
		TMOUT:=t#5s ,
		MODE:=SPDM_2PASS ,
		BUSY=> ,
		ERR=> ,
		ERRID=> );
	IF NOT(fbSaveData.BUSY) THEN
		nMotorNominalRPMStore:=nMotorNominalRPM;
		sSerialNumberStore:= sSerialNumber;
		sModelNumberStore:= sModelNumber;
		sKaysJobNumberStore:= sKaysJobNumber;
		sCustomerNameStore:= sCustomerName;
		sProductionDateStore:= sProductionDate;
		nMachineNumberStore := nMachineNumber;
		nCyclesCompleteStore := nCyclesComplete;
		nMaxCyclesStore := nMaxCycles;
		sLastLoadedPartProgramNameStore := sLastLoadedPartProgramName;
		fFlowMonitorMaxStore := fFlowMonitorMax;

		sLoadSideSetStore := sLoadSideSet;
		nUAxisThrustMaxStore := nUAxisThrustMax;
		fWAAxisHomeOffsetStore := fWAAxisHomeOffset;
		fWBAxisHomeOffsetStore := fWBAxisHomeOffset;
		fWAxisMoveOffBushingStore := fWAxisMoveOffBushing;
		nTailstockClampingTorqueLimitStore := nTailstockClampingTorqueLimit;
		fTailstockVelocityStore := fTailstockVelocity;
		bSideAEnabledStore := bSideAEnabled;
		bSideBEnabledStore := bSideBEnabled;
		fUAxisLoadSidePositionStore := fUAxisLoadSidePosition;
		fUAxisUnloadSidePositionStore := fUAxisUnloadSidePosition;
		fUAxisVelocityStore := fUAxisVelocity;

	END_IF
ELSE
	fbSaveData(START:=FALSE);
END_IF

(*		FAULT HISTORY Save 		*)
(*
IF MEMCMP(ADR(arrFaultHistory), ADR(arrFaultHistoryStore), SIZEOF(arrFaultHistory))<>0 THEN
	bFaultHistoryChanged:=TRUE;
ELSE (* Once they match then turn off bit *)
	bFaultHistoryChanged:=FALSE;
END_IF

(* Wait 1.5 minute after the fault history has changed to store to disk *)
fbWriteFaultHistroyTrigger(in:=bFaultHistoryChanged, PT:=t#90s);

(* Set a Trigger on first Scan to say the Fault History needs to be loaded from file *)
IF SystemTaskInfoArr[1].firstCycle THEN
	bFaultHistoryEmpty:=TRUE;
END_IF

(* Give Reading Priority by position, and do not read and write at the same time *)
IF bFaultHistoryEmpty THEN
	CASE nFaultHistoryReadStep OF
	0: (* Setup *)
		sFileOpError:='';
		(* Prepare For Next Step *)
		nOpenMode:=FOPEN_MODEREAD OR FOPEN_MODETEXT;
		bFileOpen:=FALSE;
		(* Move To Next Step *)
		nFaultHistoryReadStep:=nFaultHistoryReadStep+1;

	1: (* Open The File *)

		(* Check For Completion Of Operation *)
		IF NOT(fbFileOpen.bBusy) AND NOT(fbFileOpen.bError) AND bFileOpen THEN
			(* Prepare For Next Step *)
			bFileReadLine:=FALSE;
			nReadLineStep:=0;
			nCount:=1;
			bFileOpen:=FALSE;
			(* Move To Next Step *)
			nFaultHistoryReadStep:=nFaultHistoryReadStep+1;
		(* Check For Error Condition *)
		ELSIF fbFileOpen.bError AND bFileOpen THEN
			sFileOpError:=CONCAT('Fault History Read Open Error:  ',UDINT_TO_STRING(fbFileOpen.nErrId));
			bFileOpen:=FALSE;
			nFaultHistoryReadStep:=70;
		ELSE
			bFileOpen:=TRUE;
		END_IF

	2: (* Read The File - line by line *)

		CASE nReadLineStep OF
		0: (* Wait For Read To Finish *)
			IF NOT(fbFileReadLine.bBusy) AND bFileReadLine THEN
				(* Toggle off Trigger *)
				bFileReadLine:=FALSE;
				nReadLineStep:=nReadLineStep+1;
			ELSE (* Get The Next Line Of The File *)
				bFileReadLine:=TRUE;
			END_IF

		1: (* Store Retrieved String *)
			stInVal:=fbFileReadLine.sLine;
			(* Move To Next Step *)
			nReadLineStep:=nReadLineStep+1;

		2: (* Check for Read error or End Of File - There should only be 80 lines max  *)
			IF fbFileReadLine.bEOF OR nCount>80 THEN
				(* Move Out of Reading line *)
				nFaultHistoryReadStep:=nFaultHistoryReadStep+1;
				(* Prepare For Next Step *)
				bFileClose:=FALSE;
			ELSIF fbFileReadLine.bError THEN
				(* Error Report And Close File *)
				sFileOpError:=CONCAT('Fault History Read Line Error:  ',UDINT_TO_STRING(fbFileReadLine.nErrId));
				bFileClose:=FALSE;
				nFaultHistoryReadStep:=70;
			ELSE (* Move To Next Step *)
				nReadLineStep:=nReadLineStep+1;
			END_IF

		3: (* Write the value to Array Fault History *)
			(* Extract the End of line character and put the string into the Array *)
			arrFaultHistory[nCount]:=DELETE(stInVal,1,LEN(stInVal));
			(* Jump back to read next line *)
			nCount:=nCount+1;
			bFileReadLine:=FALSE;
			nReadLineStep:=0;

		END_CASE

	3: (*Close file *)
		(* Check For Completion *)
		IF NOT( fbFileClose.bBusy) AND bFileClose THEN
			bFileClose:=FALSE;
			(* Move To Next Step *)
			nFaultHistoryReadStep:=nFaultHistoryReadStep+1;
		(* Check For Error Condition *)
		ELSIF fbFileClose.bError THEN
			sFileOpError:=CONCAT('Fault History Read Close Error:  ',UDINT_TO_STRING(fbFileClose.nErrId));
			bFileClose:=FALSE;
			nFaultHistoryReadStep:=70;
		ELSE
			bFileClose:=TRUE;
		END_IF

	4: (* Done *)
		bFaultHistoryEmpty:=FALSE;
		nFaultHistoryReadStep:=0;

	70: (* Error Recovery *)
		bFaultHistoryEmpty:=FALSE;
		bFaultHistoryFileError:=TRUE;
		nFaultHistoryReadStep:=0;

	END_CASE


ELSIF fbWriteFaultHistroyTrigger.Q THEN

	CASE nFaultHistoryStoreStep OF
	0: (* Setup *)
		sFileOpError:='';
		(* Prepare For Next Step *)
		nOpenMode:=FOPEN_MODEWRITE OR FOPEN_MODETEXT;
		bFileOpen:=FALSE;
		(* Move To Next Step *)
		nFaultHistoryStoreStep:=nFaultHistoryStoreStep+1;

	1: (* Open/Create The File *)
		(* Check For Completion *)
		IF NOT(fbFileOpen.bBusy) AND NOT(fbFileOpen.bError) AND bFileOpen THEN
			bFileOpen:=FALSE;
			bFileWrite:=FALSE;
			nCount:=1;
			nWriteLineStep:=0;
			stOutVal:='';
			nFaultHistoryStoreStep:=nFaultHistoryStoreStep+1;
		(* Check For Error Condition *)
		ELSIF fbFileOpen.bError AND bFileOpen THEN
			sFileOpError:=CONCAT('Fault History Write Open Error:  ',UDINT_TO_STRING(fbFileOpen.nErrId));
			bFileOpen:=FALSE;
			nFaultHistoryStoreStep:=70;
		(*Trigger a file Open to Create/empty the file *)
		ELSE
			bFileOpen:=TRUE;
		END_IF

	2: (* Write file to disk Line by Line *)
		CASE nWriteLineStep OF
			0: (* Create String to write *)
				(* Done if Fault History Array element is blank or above 80 lines *)
				IF arrFaultHistory[nCount]='' OR nCount>=80 THEN
					bFileWrite:=FALSE;
					bFileClose:=FALSE;
					nFaultHistoryStoreStep:=nFaultHistoryStoreStep+1;
				(* Write sting and add EOL character *)
				ELSE
					stOutVal:=arrFaultHistory[nCount];
					stOutVal:=CONCAT(stOutVal,'$L');
					(* Prepare For Next Step *)
					fbFileWrite.sLine:=stOutVal;
					bFileWrite:=FALSE;
					nWriteLineStep:=nWriteLineStep+1;
				END_IF

			1: (* Write Line to Disk *)
				(* Check For Completion *)
				IF NOT( fbFileWrite.bBusy) AND NOT(fbFileWrite.bError) AND bFileWrite THEN
					(* Incriment count for next line *)
					nCount:=nCount+1;
					stOutVal:='';
					(* Jump back to create next line *)
					bFileWrite:=FALSE;
					nWriteLineStep:=0;
				(* Check For Error Condition *)
				ELSIF fbFileWrite.bError AND bFileWrite THEN
					sFileOpError:=CONCAT('Fault History Write Error:  ',UDINT_TO_STRING(fbFileWrite.nErrId));
					bFileWrite:=FALSE;
					bFileClose:=TRUE;
					nFaultHistoryStoreStep:=70;
				ELSE (* Initiate write *)
					bFileWrite:=TRUE;
				END_IF
		END_CASE
	3: (*Close the File *)
		(* Check For Completion *)
		IF NOT( fbFileClose.bBusy) AND NOT(fbFileClose.bError) AND bFileClose THEN
			(* Move To Next Step *)
			nFaultHistoryStoreStep:=nFaultHistoryStoreStep+1;
			bFileClose:=FALSE;
		(* Check For Error Condition *)
		ELSIF fbFileClose.bError AND bFileClose THEN
			sFileOpError:=CONCAT('Fault History Close Error:  ',UDINT_TO_STRING(fbFileClose.nErrId));
			nFaultHistoryStoreStep:=70;
		ELSE
			bFileClose:=TRUE;
		END_IF

	4: (* Set the Array Store Value to ArrayFaultHistory *)
		MEMCPY(ADR(arrFaultHistoryStore), ADR(arrFaultHistory), SIZEOF(arrFaultHistory));
		(* This will automatically turn off bFaultHistoryChanged, so fbWriteFaultHistroyTrigger.Q will go off *)
		nFaultHistoryStoreStep:=0;

	70: (* Error State *)
		bFaultHistoryFileError:=TRUE;
		bFileClose:=FALSE;
		bFaultHistoryChanged:=FALSE; (* turn off the condition for the elsif of this case *)
		nFaultHistoryStoreStep:=0;

	END_CASE
(* Clear the 80 lines of FAult History *)
ELSIF bClearFAultHistoryPB THEN
	FOR nLoopIndex:=1 TO 80 BY 1 DO
		arrFaultHistory[nLoopIndex]:='';
	END_FOR;
	IF nLoopIndex>=80 THEN
		bClearFAultHistoryPB:=FALSE;
	END_IF
END_IF
*)

fbFileOpen(
	sNetId:='' ,
	sPathName:='\Hard Disk\ftp\FaultHistory.csv' ,
	nMode:= nOpenMode,
	ePath:=PATH_GENERIC ,
	bExecute:=bFileOpen ,
	tTimeout:=t#10s );
fbFileReadLine(
	sNetId:='' ,
	hFile:=fbFileOpen.hFile ,
	bExecute:=bFileReadLine ,
	tTimeout:=t#10s,
	bBusy=> ,
	bError=> ,
	nErrId=> ,
	sLine=> ,
	bEOF=> );
fbFileWrite(
	sNetId:='' ,
	hFile:=fbFileOpen.hFile ,
	sline:=stOutVal ,
	bExecute:=bFileWrite ,
	tTimeout:=t#10s );
fbFileClose(
	sNetId:='' ,
	hFile:=fbFileOpen.hFile ,
	bExecute:=bFileClose ,
	tTimeout:=t#10s );
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM P_TailstockControl
VAR
(* WA Axis MC Functions *)
	fbWAAxisPower: MC_Power;
	fbWAAxisMove: MC_MoveAbsolute;
	fbWAAxisSetZero: MC_SetPosition;
	bWAAxisPower: BOOL := FALSE;
	bWAAxisMove: BOOL := FALSE;
	bWAAxisSetZero: BOOL := FALSE;
	fWAAxisSetZeroPosition: LREAL := 0.0;
	bWADeCtrlEnable : BOOL := FALSE;		(* Enable bit for FB to move off overtravel *)
	fbHomeWAPBRTrig : R_TRIG;			(* Capture the Rising Edge of the PB *)

(* WB Axis MC Functions *)
	fbWBAxisPower: MC_Power;
	fbWBAxisMove: MC_MoveAbsolute;
	fbWBAxisSetZero: MC_SetPosition;
	bWBAxisPower: BOOL := FALSE;
	bWBAxisMove: BOOL := FALSE;
	bWBAxisSetZero: BOOL := FALSE;
	fWBAxisSetZeroPosition: LREAL := 0.0;
	bWBDeCtrlEnable : BOOL := FALSE;		(* Enable bit for FB to move off overtravel *)
	fbHomeWBPBRTrig : R_TRIG;			(* Capture the Rising Edge of the PB *)

	bTransferAtPosition: BOOL := FALSE;			(* Transfer is at Load or unload position *)

	bAManualOpenCollet: BOOL := FALSE;		(*Manual Control to Open the Collets on Side A*)
	bAManualCloseCollet: BOOL := FALSE;		(*Manual Control to Close the Collets on Side A*)
	bBManualOpenCollet: BOOL := FALSE;		(*Manual Control to Open the Collets on Side B*)
	bBManualCloseCollet: BOOL := FALSE;		(*Manual Control to Close the Collets on Side B*)

(* Recording Variables *)
	nWAThrustMaxRecorded: DINT := 0;						(* Recorded Max thrust value seen on WA Axis*)
	arraynWAThrustMaxRec: ARRAY [1..20] OF DINT :=20(0);	(* Store the Values of the last 10 runs for WA *)
	nWBThrustMaxRecorded: DINT := 0;						(* Recorded Max thrust value seen on WB Axis *)
	arraynWBThrustMaxRec: ARRAY [1..20] OF DINT :=20(0);	(* Store the Values of the last 10 runs for WB *)
	fbStoreWMaxThrust: R_TRIG;							(* Trigger to stroe the values *)
	nUThrustMaxRecorded: DINT := 0;						(* Recorded Max thrust value seen on U Axis *)


END_VAR
(* @END_DECLARATION := '0' *)
(* Call Actions *)
Tailstock_Function;
(* Check Transfer at Load or Unload Positions *)
bTransferAtPosition:=
	(* Within +/- 0.1mm of Unload position *)
	( (fUAxisUnloadSidePosition+0.1)>=stUAxis.NcToPlc.ActPos AND
	stUAxis.NcToPlc.ActPos>=(fUAxisUnloadSidePosition-0.1) ) OR
	(* Within +/- 0.1mm of Load position *)
	( (fUAxisLoadSidePosition+0.1)>=stUAxis.NcToPlc.ActPos AND
	stUAxis.NcToPlc.ActPos>=(fUAxisLoadSidePosition-0.1) );

(* Turn on MC_Power when Hard Enable is ON *)
bWAAxisPower := bAServoEnable;
bWBAxisPower := bBServoEnable;

fbWAAxisPower(
	Enable:=bWAAxisPower ,
	Enable_Positive:= bWAAxisPower ,
	Enable_Negative:= bWAAxisPower ,
	Override:=100 ,
	BufferMode:=MC_Aborting ,
	Axis:=stWAAxis );

(* When the Stop is Done or has an error then we turn off the trigger *)
IF fbWAAxisStop.Done OR fbWAAxisStop.Error THEN
	bWAStop:=FALSE;
END_IF
fbWAAxisStop(
	Execute := bWAStop,
	Deceleration := 0,
	Jerk := 0,
	Axis := stWAAxis );

fbWAAxisMCReset(
	Execute:=bWAMCResetRequest ,
	Axis:=stWAAxis );

fbWAAxisDriveReset(
	NetId:='' ,
	Execute:=bZWADriveResetRequest ,
	Timeout:=t#10s ,
	Axis:= stWAAxis, );

stWAAxis.ReadStatus();

(* If a Drive reset was requested then when the Drive Reset is done we want to do a MC Reset of the NC Axis *)
IF bZWADriveResetRequest AND (NOT (fbWAAxisDriveReset.Busy) OR  fbWAAxisDriveReset.Error) THEN
	bWAMCResetRequest:=TRUE;
END_IF
IF fbWAAxisMCReset.Done OR fbWAAxisMCReset.Error THEN
	bWAMCResetRequest:=FALSE;
	bZWADriveResetRequest:=FALSE;
END_IF

(* When the Home PB pressed trigger a home *)
fbHomeWAPBRTrig(CLK:=bWAAxisHomePB);
IF fbHomeWAPBRTrig.Q  AND NOT bMachineFault THEN
	bWAAxisHome:=TRUE;
(* When Home is done turn off trigger *)
ELSIF fbWAAxisHome.Done THEN
	bWAAxisHome:=FALSE;
(* if an Error then issue a stop *)
ELSIF  fbWAAxisHome.Error THEN
	bWAAxisHome:=FALSE;
	bWAStop:=TRUE;
END_IF

(* Home WA Axis *)
fbWAAxisHome(
	Execute:= bWAAxisHome,
	Position:= fWAAxisHomeOffset ,
	HomingMode:= ,
	BufferMode:= ,
	Options:= ,
	bCalibrationCam:= DriveZAWAdinputs.6 ,
	Axis:= stWAAxis ,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=>  );

(* If one of the WA Axis overtravel limit switches is made, then turn on the bit that allows
Movement off of the limit switchs *)
IF NOT(DriveZAWAdinputs.3) OR NOT(DriveZAWAdinputs.4) THEN
	bWADeCtrlEnable:=TRUE;
ELSE
	bWADeCtrlEnable:=FALSE;
END_IF
stWAAxis.PlcToNc.ControlDWord :=
AxisSetAcceptBlockedDriveSignal(stWAAxis.PlcToNc.ControlDWord,
	bEnable:= bWADeCtrlEnable );


(*	SIDE B 	*)
bBServoEnable;		(* Display the B Sode Enable Relay for Convenience *)

fbWBAxisPower(
	Enable:= bWBAxisPower ,
	Enable_Positive:= bWBAxisPower ,
	Enable_Negative:= bWBAxisPower ,
	Override:=100 ,
	BufferMode:=MC_Aborting ,
	Axis:=stWBAxis );

(* When the Stop is Done or has an error then we turn off the trigger *)
IF fbWBAxisStop.Done OR fbWBAxisStop.Error THEN
	bWBStop:=FALSE;
END_IF
fbWBAxisStop(
	Execute := bWBStop,
	Deceleration := 0,
	Jerk := 0,
	Axis := stWBAxis );

fbWBAxisMCReset(
	Execute:=bWBMCResetRequest ,
	Axis:=stWBAxis );

fbWBAxisDriveReset(
	NetId:='' ,
	Execute:=bZWBDriveResetRequest ,
	Timeout:=t#10s ,
	Axis:= stWBAxis, );

stWBAxis.ReadStatus();

(* If a Drive reset was requested then when the Drive Reset is done we want to do a MC Reset of the NC Axis *)
IF bZWBDriveResetRequest AND (NOT (fbWBAxisDriveReset.Busy) OR  fbWBAxisDriveReset.Error) THEN
	bWBMCResetRequest:=TRUE;
END_IF
IF fbWBAxisMCReset.Done OR fbWBAxisMCReset.Error THEN
	bWBMCResetRequest:=FALSE;
	bZWBDriveResetRequest:=FALSE;
END_IF

(* When the Home PB pressed trigger a home *)
fbHomeWBPBRTrig(CLK:=bWBAxisHomePB);
IF fbHomeWBPBRTrig.Q AND NOT bMachineFault THEN
	bWBAxisHome:=TRUE;
(* When Home is done turn off trigger *)
ELSIF fbHomeWB.Done THEN
	bWBAxisHome:=FALSE;	(* Also set True from MM_HomeAutomation *)
(* If an error occurs issue a stop *)
ELSIF fbHomeWB.Error THEN
	bWBAxisHome:=FALSE;
	bWBStop:=TRUE;
END_IF

(* Home WB Axis *)
fbHomeWB(
	Execute:= bWBAxisHome,
	Position:= fWBAxisHomeOffset ,
	HomingMode:= ,
	BufferMode:= ,
	Options:= ,
	bCalibrationCam:= DriveZBWBdinputs.6 ,
	Axis:= stWBAxis ,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(* If one of the WB Axis overtravel limit switches is made, then turn on the bit that allows
Movement off of the limit switchs *)
IF NOT(DriveZBWBdinputs.3) OR NOT(DriveZBWBdinputs.4) THEN
	bWBDeCtrlEnable:=TRUE;
ELSE
	bWBDeCtrlEnable:=FALSE;
END_IF
stWBAxis.PlcToNc.ControlDWord :=
AxisSetAcceptBlockedDriveSignal(stWBAxis.PlcToNc.ControlDWord,
	bEnable:= bWBDeCtrlEnable );

(* Assign the Ejectors State *)
nAEjectorAdvancedState.0:=bProx613;
nAEjectorAdvancedState.1:=bProx614;
nAEjectorAdvancedState.2:=bProx615;
nAEjectorRetractedState.0:=bProx610;
nAEjectorRetractedState.1:=bProx611;
nAEjectorRetractedState.2:=bProx612;

nBEjectorAdvancedState.0:=bProx723;
nBEjectorAdvancedState.1:=bProx724;
nBEjectorAdvancedState.2:=bProx725;
nBEjectorRetractedState.0:=bProx720;
nBEjectorRetractedState.1:=bProx721;
nBEjectorRetractedState.2:=bProx722;



(*	******* COLLET CLAMP ******	*)
(* Side A *)
(* Fire Solenoid Valves *)
(* Normal Control is handled in the FB_Fixture Control *)
(* When the MCR is off we turn off the solenoids *)
IF NOT (bMCR AND bHydraulicPowerUnitRunning) THEN
	bATailstockColletUnclamp := FALSE;
	bATailstockColletClamp:=FALSE;
END_IF
(*FAIL-SAFE CONTROL
If Both Outputs are on at the same time then turn them Off and Fault *)
IF bATailstockColletUnclamp AND bATailstockColletClamp THEN
	nModeError:=Er_SideAColletSolError;
	bATailstockColletUnclamp := FALSE;
	bATailstockColletClamp:=FALSE;
END_IF

(* Side B *)
(* Fire Solenoid Valves *)
(* Normal Control is handled in the FB_Fixture Control *)
(* When the MCR is off we turn off the solenoids *)
IF NOT (bMCR AND bHydraulicPowerUnitRunning) THEN
	bBTailstockColletUnclamp := FALSE;
	bBTailstockColletClamp:=FALSE;
END_IF
(*FAIL-SAFE CONTROL
If Both Outputs are on at the same time then turn them Off and Fault *)
IF bBTailstockColletUnclamp AND bBTailstockColletClamp THEN
	nModeError:=Er_SideBColletSolError;
	bBTailstockColletUnclamp := FALSE;
	bBTailstockColletClamp:=FALSE;
END_IF

(*	******* EJECTORS  ******	*)
(* Side A *)
(* Fire Solenoid Valves *)
(* Normal Control is handled in the FB_Fixture Control *)
(* If MCR off or Air Pressure Lost *)
IF NOT (bMCR AND bPneumaticSystemPressure) THEN
	bAEjectorsAdvance := FALSE;
	bAEjectorsRetract := FALSE;
END_IF
(*FAIL-SAFE CONTROL
If Both Outputs are on at the same time then turn them Off and Fault *)
IF bAEjectorsAdvance AND bAEjectorsRetract THEN
	nModeError:=Er_SideAEjectorsSolError;
	bAEjectorsAdvance := FALSE;
	bAEjectorsRetract := FALSE;
END_IF

(* Side B *)
(* Fire Solenoid Valves *)
(* Normal Control is handled in the FB_Fixture Control *)
(* If MCR off or Air Pressure Lost *)
IF NOT (bMCR AND bPneumaticSystemPressure) THEN
	bBEjectorsAdvance := FALSE;
	bBEjectorsRetract := FALSE;
END_IF
(*FAIL-SAFE CONTROL
If Both Outputs are on at the same time then turn them Off and Fault *)
IF bBEjectorsAdvance AND bBEjectorsRetract THEN
	nModeError:=Er_SideBEjectorsSolError;
	bBEjectorsAdvance := FALSE;
	bBEjectorsRetract := FALSE;
END_IF

(* Fault if Manual Move Pressed *)
IF (bWAAxisAdvancePB OR bWAAxisRetractPB) AND
	bMPGAOn
THEN
	nModeError:=Er_MPG_A_Active;
END_IF
IF (bWBAxisAdvancePB OR bWBAxisRetractPB) AND
	bMPGBOn
THEN
	nModeError:=Er_MPG_B_Active;
END_IF


(* Record W Axis Thrust *)
	(* Reset the W Thrust before Drilling *)
(*	IF nAutoCycleStep = AC_SpindleOn THEN
		nWAThrustMaxRecorded:=0;
		nWBThrustMaxRecorded:=0;
	END_IF
*)
	(* Record Max WA Thrust  while in the Clamp State*)
	IF nWAAxisThrust > nWAThrustMaxRecorded AND nAutoCycleStep=AC_Clamp THEN
		nWAThrustMaxRecorded:=nWAAxisThrust;
	END_IF
	(* Record Max WB Thrust *)
	IF nWBAxisThrust > nWBThrustMaxRecorded AND nAutoCycleStep=AC_Clamp THEN
		nWBThrustMaxRecorded:=nWBAxisThrust;
	END_IF
	(* Record Max U Axis Thrust *)
	IF nUAxisThrust > nUThrustMaxRecorded THEN
		nUThrustMaxRecorded:=nUAxisThrust;
	END_IF

(* Store the value in the array when we are done drilling *)
fbStoreWMaxThrust(CLK:=nAutoCycleStep=AC_SpindleOff);
IF fbStoreWMaxThrust.Q THEN
	arraynWAThrustMaxRec[20]	:=arraynWAThrustMaxRec[19];
	arraynWAThrustMaxRec[19]	:=arraynWAThrustMaxRec[18];
	arraynWAThrustMaxRec[18]	:=arraynWAThrustMaxRec[17];
	arraynWAThrustMaxRec[17]	:=arraynWAThrustMaxRec[16];
	arraynWAThrustMaxRec[16]	:=arraynWAThrustMaxRec[15];
	arraynWAThrustMaxRec[15]	:=arraynWAThrustMaxRec[14];
	arraynWAThrustMaxRec[14]	:=arraynWAThrustMaxRec[13];
	arraynWAThrustMaxRec[13]	:=arraynWAThrustMaxRec[12];
	arraynWAThrustMaxRec[12]	:=arraynWAThrustMaxRec[11];
	arraynWAThrustMaxRec[11]	:=arraynWAThrustMaxRec[10];
	arraynWAThrustMaxRec[10]	:=arraynWAThrustMaxRec[9];
	arraynWAThrustMaxRec[9]		:=arraynWAThrustMaxRec[8];
	arraynWAThrustMaxRec[8]		:=arraynWAThrustMaxRec[7];
	arraynWAThrustMaxRec[7]		:=arraynWAThrustMaxRec[6];
	arraynWAThrustMaxRec[6]		:=arraynWAThrustMaxRec[5];
	arraynWAThrustMaxRec[5]		:=arraynWAThrustMaxRec[4];
	arraynWAThrustMaxRec[4]		:=arraynWAThrustMaxRec[3];
	arraynWAThrustMaxRec[3]		:=arraynWAThrustMaxRec[2];
	arraynWAThrustMaxRec[2]		:=arraynWAThrustMaxRec[1];
	arraynWAThrustMaxRec[1]		:=nWAThrustMaxRecorded;
	nWAThrustMaxRecorded		:=0;	(* Reset Variable *)

	arraynWBThrustMaxRec[20]	:=arraynWBThrustMaxRec[19];
	arraynWBThrustMaxRec[19]	:=arraynWBThrustMaxRec[18];
	arraynWBThrustMaxRec[18]	:=arraynWBThrustMaxRec[17];
	arraynWBThrustMaxRec[17]	:=arraynWBThrustMaxRec[16];
	arraynWBThrustMaxRec[16]	:=arraynWBThrustMaxRec[15];
	arraynWBThrustMaxRec[15]	:=arraynWBThrustMaxRec[14];
	arraynWBThrustMaxRec[14]	:=arraynWBThrustMaxRec[13];
	arraynWBThrustMaxRec[13]	:=arraynWBThrustMaxRec[12];
	arraynWBThrustMaxRec[12]	:=arraynWBThrustMaxRec[11];
	arraynWBThrustMaxRec[11]	:=arraynWBThrustMaxRec[10];
	arraynWBThrustMaxRec[10]	:=arraynWBThrustMaxRec[9];
	arraynWBThrustMaxRec[9]		:=arraynWBThrustMaxRec[8];
	arraynWBThrustMaxRec[8]		:=arraynWBThrustMaxRec[7];
	arraynWBThrustMaxRec[7]		:=arraynWBThrustMaxRec[6];
	arraynWBThrustMaxRec[6]		:=arraynWBThrustMaxRec[5];
	arraynWBThrustMaxRec[5]		:=arraynWBThrustMaxRec[4];
	arraynWBThrustMaxRec[4]		:=arraynWBThrustMaxRec[3];
	arraynWBThrustMaxRec[3]		:=arraynWBThrustMaxRec[2];
	arraynWBThrustMaxRec[2]		:=arraynWBThrustMaxRec[1];
	arraynWBThrustMaxRec[1]		:=nWBThrustMaxRecorded;
	nWBThrustMaxRecorded		:=0;	(* Reset Variable *)
END_IF
END_PROGRAM
ACTION	Tailstock_Function:
_FBD_BODY
_NETWORKS : 2
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
Side_A_Fixture
_BOX_EXPR : 24
_OPERAND
_EXPRESSION
_POSITIV
bMCR
_OPERAND
_EXPRESSION
_POSITIV
bAutoClampAStart
_OPERAND
_EXPRESSION
_POSITIV
bAutoUnclampAStart
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
bWAAxisAdvancePB
_OPERAND
_EXPRESSION
_POSITIV
NOT(bMPGAOn)
_EXPRESSION
_POSITIV
AND
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
bWAAxisRetractPB
_OPERAND
_EXPRESSION
_POSITIV
NOT(bMPGAOn)
_EXPRESSION
_POSITIV
AND
_OPERAND
_EXPRESSION
_POSITIV
bAColletClosePB
_OPERAND
_EXPRESSION
_POSITIV
bAColletOpenPB
_OPERAND
_EXPRESSION
_POSITIV
bAEjectorsAdvancePB
_OPERAND
_EXPRESSION
_POSITIV
bAEjectorsRetractPB
_OPERAND
_EXPRESSION
_POSITIV
bPS617
_OPERAND
_EXPRESSION
_POSITIV
bPS616
_OPERAND
_EXPRESSION
_POSITIV
nAEjectorAdvancedState
_OPERAND
_EXPRESSION
_POSITIV
nAEjectorRetractedState
_OPERAND
_EXPRESSION
_POSITIV
bTransferAtPosition
_OPERAND
_EXPRESSION
_POSITIV
fWAxisTransferPosition
_OPERAND
_EXPRESSION
_POSITIV
fWAxisDrillPosition
_OPERAND
_EXPRESSION
_POSITIV
fWAxisMoveOffBushing
_OPERAND
_EXPRESSION
_POSITIV
fWAxisFastVelocity
_OPERAND
_EXPRESSION
_POSITIV
fWAxisClampVelocity
_OPERAND
_EXPRESSION
_POSITIV
nTailstockClampingTorqueLimit
_OPERAND
_EXPRESSION
_POSITIV
nWAAxisThrustMax
_OPERAND
_EXPRESSION
_POSITIV
ABS(nWAAxisThrust)
_OPERAND
_EXPRESSION
_POSITIV
stUAxis.NcToPlc.StateDWord.1
_OPERAND
_EXPRESSION
_POSITIV
stWAAxis
_EXPRESSION
_POSITIV
FB_FixtureControl
_OUTPUTS : 11
_OUTPUT
_POSITIV
_NO_SET
bATailstockColletClamp
_OUTPUT
_POSITIV
_NO_SET
bATailstockColletUnclamp
_OUTPUT
_POSITIV
_NO_SET
bAEjectorsAdvance
_OUTPUT
_POSITIV
_NO_SET
bAEjectorsRetract
_OUTPUT
_POSITIV
_NO_SET
bAutoClampADone
_OUTPUT
_POSITIV
_NO_SET
bAutoUnclampADone
_OUTPUT
_POSITIV
_NO_SET
nWATorqeLimitValue
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
Side_B_Fixture
_BOX_EXPR : 24
_OPERAND
_EXPRESSION
_POSITIV
bMCR
_OPERAND
_EXPRESSION
_POSITIV
bAutoClampBStart
_OPERAND
_EXPRESSION
_POSITIV
bAutoUnclampBStart
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
bWBAxisAdvancePB
_OPERAND
_EXPRESSION
_POSITIV
NOT(bMPGBOn)
_EXPRESSION
_POSITIV
AND
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
bWBAxisRetractPB
_OPERAND
_EXPRESSION
_POSITIV
NOT(bMPGBOn)
_EXPRESSION
_POSITIV
AND
_OPERAND
_EXPRESSION
_POSITIV
bBColletClosePB
_OPERAND
_EXPRESSION
_POSITIV
bBColletOpenPB
_OPERAND
_EXPRESSION
_POSITIV
bBEjectorsAdvancePB
_OPERAND
_EXPRESSION
_POSITIV
bBEjectorsRetractPB
_OPERAND
_EXPRESSION
_POSITIV
bPS727
_OPERAND
_EXPRESSION
_POSITIV
bPS726
_OPERAND
_EXPRESSION
_POSITIV
nBEjectorAdvancedState
_OPERAND
_EXPRESSION
_POSITIV
nBEjectorRetractedState
_OPERAND
_EXPRESSION
_POSITIV
bTransferAtPosition
_OPERAND
_EXPRESSION
_POSITIV
fWAxisTransferPosition
_OPERAND
_EXPRESSION
_POSITIV
fWAxisDrillPosition
_OPERAND
_EXPRESSION
_POSITIV
fWAxisMoveOffBushing
_OPERAND
_EXPRESSION
_POSITIV
fWAxisFastVelocity
_OPERAND
_EXPRESSION
_POSITIV
fWAxisClampVelocity
_OPERAND
_EXPRESSION
_POSITIV
nTailstockClampingTorqueLimit
_OPERAND
_EXPRESSION
_POSITIV
nWBAxisThrustMax
_OPERAND
_EXPRESSION
_POSITIV
ABS(nWBAxisThrust)
_OPERAND
_EXPRESSION
_POSITIV
stUAxis.NcToPlc.StateDWord.1
_OPERAND
_EXPRESSION
_POSITIV
stWBAxis
_EXPRESSION
_POSITIV
FB_FixtureControl
_OUTPUTS : 11
_OUTPUT
_POSITIV
_NO_SET
bBTailstockColletClamp
_OUTPUT
_POSITIV
_NO_SET
bBTailstockColletUnclamp
_OUTPUT
_POSITIV
_NO_SET
bBEjectorsAdvance
_OUTPUT
_POSITIV
_NO_SET
bBEjectorsRetract
_OUTPUT
_POSITIV
_NO_SET
bAutoClampBDone
_OUTPUT
_POSITIV
_NO_SET
bAutoUnclampBDone
_OUTPUT
_POSITIV
_NO_SET
nWBTorqeLimitValue
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY

END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM P_TransferControl
VAR
	bTransferAxisEnable: BOOL;
	fbTransferAxisPower: MC_Power;
	fbTransferAxisMove: MC_MoveAbsolute;
	fbTransferAxisSetZero: MC_SetPosition;
	fbTransferAxisStop: MC_Stop;
	bTransferAxisPower: BOOL := FALSE;
	bTransferAxisHome: BOOL := FALSE;
	bTransferAxisMove: BOOL := FALSE;
	fTransferMovePosition : LREAL := 0.0;
	bTransferAxisStop: BOOL := FALSE;
	bTransferAxisSetZero: BOOL := FALSE;
	fTransferAxisSetZeroPosition: LREAL := 0.0;
	fbHomeUPBRTrig: R_TRIG;				(* Capture the Rising edge of the Home PB *)

	bManualLower: BOOL := FALSE;				(*Manual Set Lower Carrier Cylinder*)
	bManualRaise: BOOL := FALSE;				(*Manual Set Raise Carrier Cylinder*)

(* Inputs *)
	(* bEnable *)
	bSideADisabled : BOOL := FALSE;		(* Set by Supervisory Personnell if Side A is to be disabled *)
	bSideBDisabled : BOOL := FALSE;		(* Set by Supervisory Personnell if Side A is to be disabled *)
	(* PartLoadCompletePB *)				(* Operator Pendant Push Button *)
	(* All of the Load and Unload Nest Proxes should be inputs *)
	(* Raise and Lower Transfer Proxes should be inputs *)
	bSideAClampComplete: BOOL := FALSE;			(* Signal from the Tailstock that it has clamped the parts - OK to lower *)
	bSideBClampComplete: BOOL := FALSE;			(* Signal from the Tailstock that it has clamped the parts - OK to lower *)

(*Outputs *)
	bSideAReadyToClamp : BOOL := FALSE;	(* Output to Tailstock to say Side A is ready to clamp Parts *)
	bSideBReadyToClamp : BOOL := FALSE;	(* Output to Tailstock to say Side B ready to clamp Parts *)

(* Cycle Variables *)

	fbMoveToUnloadRTrig: R_TRIG;
	bAutoMoveToDrill: BOOL := FALSE;
	fbDownAndLoadRTrig: R_TRIG;
	fbAutoTransferWatchdog : TON;
	bAutoTransferWatchdog : BOOL := FALSE;
	tAutoTransferWatchdogTime : TIME;
	fbUAxisStopTrig: R_TRIG;		(* Trigger a Stop of the Transfer U Axis*)
	fbCellRunoutTrig: R_TRIG;		(* R_Trig of the Cell Runout PB was pressed *)
	bLoadSideClearOfParts: BOOL := FALSE;		(* The Load Side does not have any parts loaded*)

	fbTransferUpOffDelay: TON;			(* Delay time of the Raise Output being Off *)
	fbTransferDownOffDelay: TON;			(* Off Delay time of the Lower Output being Off *)

	bTransferEnabled: BOOL := FALSE;		(* Transfer Enable Signal *)
	nTransferState: UDINT := 0;				(* Transfer State Case/Counter Variable *)
	nTransferAutoStep: UDINT := 0;			(* Transfer Automatic Step Case/Counter Variable *)
	nTransferManualStep: UDINT := 0;		(* Transfer Manual Step Case/Counter Variable *)
	bUDeCtrlEnable: BOOL := FALSE;		(* Enable Bit for FB to Move off Overtravel *)
END_VAR
(* @END_DECLARATION := '0' *)
(*Call the Action Transfer Cycle *)
Transfer_Cycle;

(* When we are in Manual Mode we do not need to display message waiting on Unload Confirm *)
IF NOT(bMachineMode) THEN
	bDisplayUnloadConf:=FALSE;
END_IF

(* We need to know when the load and Unload sides are clear of parts *)
IF (sLoadSideSet = 'A') THEN
	bUnloadSideClearOfParts := NOT(bProx510 OR bProx511 OR bProx512 OR bProx513 OR bProx514 OR bProx515);
	bLoadSideClearOfParts := NOT( bProx410 OR bProx411 OR bProx412 OR bProx413 OR bProx414 OR bProx415);
ELSIF (sLoadSideSet ='B') THEN
	bUnloadSideClearOfParts := NOT( bProx410 OR bProx411 OR bProx412 OR bProx413 OR bProx414 OR bProx415);
	bLoadSideClearOfParts := NOT(bProx510 OR bProx511 OR bProx512 OR bProx513 OR bProx514 OR bProx515);
END_IF

(* When the Transfer Down and Load signal is on we want to turn it off when the transfer gets back to the Load postion and is down.
	We cant do this in the Drill Cycle because the transfer movements are somewhat independant of the drill cycle. *)
IF bAutoTransferDownAndLoad AND bProx517 AND bTransferAtLoadIndicator THEN
	bAutoTransferDownAndLoad:=FALSE;
END_IF

(* Turn on the Power to Transfer Axis when Hard Enable is on *)
bTransferAxisPower := bUServoEnable;

fbTransferAxisPower(
	Enable:=bTransferAxisPower ,
	Enable_Positive:=bTransferAxisPower ,
	Enable_Negative:=bTransferAxisPower ,
	Override:=100 ,
	BufferMode:=MC_Aborting ,
	Axis:=stUAxis );

(* When the Stop is Done or has an error then we turn off the trigger *)
IF fbUAxisStop.Done OR fbUAxisStop.Error THEN
	bUStop:=FALSE;
END_IF
fbUAxisStop(
	Execute := bUStop,
	Deceleration := 0,
	Jerk := 0,
	Axis := stUAxis );

fbTransferAxisMove(
	Execute:= bTransferAxisMove ,
	Position:= fTransferMovePosition ,
	Velocity:= fTransferMoveVelo ,
	Acceleration:= 0 ,
	Deceleration:= 0,
	Jerk := 0,
	BufferMode:=MC_Aborting ,
	Axis := stUAxis );

fbUAxisMCReset(
	Execute:=bUMCResetRequest ,
	Axis:=stUAxis );

fbUAxisDriveReset(
	NetId:='' ,
	Execute:=bUDriveResetRequest ,
	Timeout:=t#10s ,
	Axis:= stUAxis, );

stUAxis.ReadStatus();

(* If one of the U Axis overtravel limit switches is made, then turn on the bit that allows
Movement off of the limit switchs 
NOTE: The U Axis uses Prox sensors instead of NC Limit Switches so the next line is different *)
IF (DriveUdinputs.0) OR (DriveUdinputs.1) THEN
	bUDeCtrlEnable:=TRUE;
ELSE
	bUDeCtrlEnable:=FALSE;
END_IF
stUAxis.PlcToNc.ControlDWord :=
AxisSetAcceptBlockedDriveSignal(stUAxis.PlcToNc.ControlDWord,
	bEnable:= bUDeCtrlEnable );

(* If a Drive reset was requested then when the Drive Reset is done we want to do a MC Reset of the NC Axis *)
IF bUDriveResetRequest AND (NOT (fbUAxisDriveReset.Busy) OR  fbUAxisDriveReset.Error) THEN
	bUMCResetRequest:=TRUE;
END_IF
IF fbUAxisMCReset.Done OR fbUAxisMCReset.Error THEN
	buMCResetRequest:=FALSE;
	bUDriveResetRequest:=FALSE;
END_IF

(* When the Home PB pressed trigger a home *)
fbHomeUPBRTrig(CLK:=bHomeUAxisPB);
IF fbHomeUPBRTrig.Q THEN
	bUAxisHome:=TRUE;
(* When Home is done turn off trigger *)
ELSIF fbTransferAxisHome.Done THEN
	bUAxisHome:=FALSE;
(* If an Error Occurs then turn off trigger and Issue a Stop command *)
ELSIF  fbTransferAxisHome.Error  THEN
	bUAxisHome:=FALSE;
	bUStop:=TRUE;
END_IF

fbTransferAxisHome(
	Execute:= bUAxisHome ,
	Position:=0 ,
	HomingMode:= ,
	BufferMode:= ,
	Options:= ,
	bCalibrationCam:= DriveUdinputs.5 ,
	Axis:= stUAxis ,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=>  );

(* 	SOLENOID VALVE CONTROL 	*)
(* This part of the programs handles the solenoid valves for the raising and lowering of the Transfer.
	It prohibits Solenoid A and B being fired at the same time and when the hydraulic unit is running and
	Manual mode is entered it fires the solenoid that corresponds to the feedback inputs *)

(* Fire Solenoid Valves *)
(* Must have MCR and Hydraulic Unit *)
IF bMCR AND bHydraulicPowerUnitRunning
	(* When Drill Return Activated we want to turn off the outputs to stop motion *)
	AND ( NOT nActiveFaults[1].1 AND bPB4ADrillReturn AND bPB4BDrillReturn )
THEN
	IF NOT(bMachineMode) AND bManualRaise OR
		bMachineMode AND bAutoRaise
	THEN
		bTransferDown := FALSE;
		IF fbTransferDownOffDelay.Q THEN
			bTransferUp := TRUE;
		END_IF
	ELSIF NOT(bMachineMode) AND bManualLower OR
		bMachineMode AND bAutoLower
	THEN
		bTransferUp := FALSE;
		IF fbTransferDownOffDelay.Q THEN
			bTransferDown := TRUE;
		END_IF
	END_IF
(* When the MCR is off or Hydraulics Off, we turn off the solenoids *)
ELSE (* NOT Enabled *)
	bTransferDown:=FALSE;
	bTransferUp:=FALSE;
END_IF

(* These timers help not to turn on the opposing solenoid until we make sure the coil is fully de-enrgized *)
fbTransferUpOffDelay(IN:=NOT bTransferUp, PT:= t#100ms);
fbTransferDownOffDelay(IN:= NOT bTransferDown, PT:= t#100ms);

(*FAIL-SAFE CONTROL
If Both Outputs are on at the same time then turn them Off and Fault *)
IF bTransferDown AND bTransferUp THEN
	nModeError:=Er_TransferSolError;
	bTransferDown:=FALSE;
	bTransferUp:=FALSE;
END_IF


END_PROGRAM
ACTION	Transfer_Cycle:
(* This part handles the action of moving the Transfer from the Load to Unload position
     and Lowering the transfer and moving it to the Load position.  Each is triggered by the Auto cycle *)

bTransferEnabled:= bMCC_SConfirm AND bHydraulicPowerUnitRunning;


(* Confirm Enable is active - if not then Clear all states *)
IF bTransferEnabled THEN
	(*Transfer Current States:
		0= Decide if in Manual or Auto
		1= Manual Mode
		2= Auto Mode
		255= Error State	*)
	CASE nTransferState OF
	0:(* Initialize - Select between Auto or Manual *)
		(* Manual and Auto Mode are Mutually Exclusive inputs *)
		IF NOT(bMachineMode) THEN (* Manual Mode *)
			nTransferState:=1;
			nTransferAutoStep:=0;
		ELSE	(* Auto Mode *)
			nTransferState:=2;
			nTransferManualStep:=0;
		END_IF

	1: (*** MANUAL MODE ***)
		CASE nTransferManualStep OF
		0: (* Initial State *)
			(* Turn off all Auto Signals signals *)
			bAutoRaise := FALSE;
			bAutoLower := FALSE;
			bAutoTransferWatchdog:=FALSE;
			bCellRunoutRequest:= FALSE;
			bDispPressCycleStart:=FALSE;
			bLoadPartsConfirmed:= FALSE;
			bAutoTransferPartsToDrill:=FALSE;
			bAutoTransferDownAndLoad:=FALSE;
			nTransferAutoStep:=0;
			nTransferManualStep:=nTransferManualStep+1;

		1: (* This Step Checks Sensor Inputs to determine what Solenoids should be fired *)
			(* Only evaluate when no fault or Drill Return *)
			IF NOT bMachineFault AND bPB4ADrillReturn AND bPB4BDrillReturn THEN
				(*** TRANSFER RAISE/LOWER CYLINDER ***)
				(* Lower  if Prox is confirming position *)
				IF bProx517 THEN
					bManualLower := TRUE;
					bManualRaise := FALSE;
				(* Raise if Prox is confirming position  *)
				ELSIF bProx516 THEN
					bManualLower := FALSE;
					bManualRaise :=TRUE;
				(* No Sensor Confirmation - Unknown State - Turn Both Off *)
				ELSE
					bManualLower := FALSE;
					bManualRaise := FALSE;
				END_IF
			(* If Fault we want to turn off the Manual Raise & Lower Outputs to hold position *)
			ELSE	bManualLower := FALSE;
					bManualRaise := FALSE;
			END_IF
			nTransferManualStep:=nTransferManualStep+1;

		(* Always Return to this Step while in manual *)
		2: (* Evaluate What To Do Next *)

			(* If We have a fault do not allow manual functions *)
			IF bMachineFault THEN
				bTransferAxisMove := FALSE;
				bManualLower := FALSE;
				bManualRaise := FALSE;
			(* Leaving Manual Mode *)
			ELSIF bMachineMode THEN
				bManualLower := FALSE;
				bManualRaise := FALSE;
				nTransferManualStep:=0;
				nTransferState:=0;
			(* Push Buttons - Axis Must Not be Moving *)
			ELSIF bTransferDownPB AND NOT(fbTransferAxisMove.Busy) THEN
				bManualLower := TRUE;(* probar cambio a False que hace *)
				bManualRaise := FALSE;
			ELSIF bTransfer
PB AND NOT(fbTransferAxisMove.Busy) THEN
				bManualLower := FALSE;
				bManualRaise :=TRUE;(* probar cambio a False que hace *)
			(* W and U Axis Homed *)
			(* When the PB's are pressed then initiate the Move
				the PB's are pulsed from the panel side. *)
			ELSIF bMoveUtoLoadPB AND NOT(fbTransferAxisMove.Busy) THEN
				IF bWandUAxisHomed THEN
					bTransferAxisMove := TRUE;(* probar cambio a False que hace *)
					fTransferMovePosition := fUAxisLoadSidePosition;
				ELSE (* W and U axis NOT homed *)
					bTransferError := TRUE;
					nTransferErrorID := 7;
					nTransferState := 255;
				END_IF
			ELSIF bMoveUtoUnloadPB AND NOT(fbTransferAxisMove.Busy) THEN
				IF bWandUAxisHomed THEN
					bTransferAxisMove := TRUE;
					fTransferMovePosition := fUAxisUnloadSidePosition;
				ELSE (* W and U axis NOT homed *)
					bTransferError := TRUE;
					nTransferErrorID := 7;
					nTransferState := 255;
				END_IF
			ELSE
				bTransferAxisMove := FALSE;
			END_IF

		END_CASE	(* nTransferManualStep *)

	2: (*** AUTO MODE ***)
		nTransferManualStep:=0;

		(* If we leave Auto turn off any outputs that are causing motion.
		 When Manual is entered it will check the state and turn on the appropriate outputs based upon sensor states 
		 Also we want to issue a stop command to the transfer *)
		IF NOT(bMachineMode) THEN (* Manual Mode *)
			(* Turn off Rais and Lower signals *)
			bAutoRaise := FALSE;
			bAutoLower := FALSE;
			bAutoTransferWatchdog:=FALSE;
			bCellRunoutRequest:= FALSE;
			bLoadPartsConfirmed:= FALSE;
			bAutoTransferPartsToDrill:=FALSE;
			bAutoTransferDownAndLoad:=FALSE;
			nTransferAutoStep:=0;
			(* Stop the Axis *)
			IF bTransferAxisMove THEN
				bTransferAxisMove := FALSE;
				nTransferState:=254;
			ELSE
				nTransferState:=0;
			END_IF
		END_IF

		(* Safety interlock: while drilling/retracting keep transfer idle and stop active U-axis moves. *)
		IF nAutoCycleStep=AC_Drill
			OR nAutoCycleStep=AC_DrillReturn
			OR nAutoCycleStep=AC_Retract
		THEN
			bAutoTransferPartsToDrill:=FALSE;
			bAutoTransferDownAndLoad:=FALSE;
			bAutoRaise:=FALSE;
			bAutoLower:=FALSE;
			bAutoTransferWatchdog:=FALSE;
			nTransferAutoStep:=2;
			IF bTransferAxisMove THEN
				bTransferAxisMove:=FALSE;
				nTransferState:=254;
			END_IF
		END_IF

		CASE nTransferAutoStep OF
		0: (* Initial Step *)
			bAutoTransferWatchdog:=FALSE;
			nTransferAutoStep:=nTransferAutoStep+1;

		1: (* Check state of the transfer *)
			(* These conditions will Fault so we will Exit Auto *)

			(* We want to be Down and at the Load Position *)
			(* Fault - Both Up and Down proxes on at same time *)
			IF bProx516 AND bProx517 THEN
				bTransferError := TRUE;
				nTransferErrorID := 54;
				nTransferState := 255;
			(* Fault - Not Down *)
			ELSIF bProx516 OR NOT(bProx517) THEN
				bTransferError := TRUE;
				nTransferErrorID := 52;
				nTransferState := 255;
			(* Fault - Not Homed *)
			ELSIF NOT bWandUAxisHomed THEN
				bTransferError := TRUE;
				nTransferErrorID := 53;
				nTransferState := 255;
			(* Fault - Actual position not within +/- 0.5mm of Load Position *)
			ELSIF NOT bTransferAtLoadIndicator THEN
				bTransferError := TRUE;
				nTransferErrorID := 50;
				nTransferState := 255;
			(* Conditions are good for enteing Auto *)
			ELSE
				nTransferAutoStep:=nTransferAutoStep+1;
			END_IF

		2: (* Always Return to Here to wait for next command *)
			(* Leaving Auto is handled above *)
			(* Must be In Cycle to trigger these Automatic functions *)
			IF bInCycle THEN
				(* Cell Runout Activation *)
				IF fbCellRunoutTrig.Q THEN
					 (* Set number of transfer cycles required before turning off request *)
					IF bLoadPartsConfirmed THEN
						nCellRunoutCounter:=3;
					ELSE
						nCellRunoutCounter:=2;
					END_IF
					bCellRunoutRequest:= TRUE;
				END_IF

				(* Decide what Automatic Function to do *)
				(* Raise the Transfer - Parts Loaded *)
				IF bLoadPartsConfirmed AND bTransferAtLoadIndicator AND bProx517 THEN
					bLoadPartsConfirmed:= FALSE;
					nTransferAutoStep:=10;
				(* Move Transfer to Drill/Unload *)
				ELSIF fbProx516TON.Q AND  bAutoTransferPartsToDrill THEN
					nTransferAutoStep:=30;
				(* Raise the Transfer - Cell Runout *)
				ELSIF bCellRunoutRequest  AND bTransferAtLoadIndicator THEN
					nTransferAutoStep:=15;
				(* Lower Transfer and Move to Load Postion triggered *)
				ELSIF fbDownAndLoadRTrig.Q THEN
					nTransferAutoStep:=40;
				END_IF
			ELSE
				bCellRunoutRequest:= FALSE;
				nCellRunoutCounter:=0;
				bLoadPartsConfirmed:= FALSE;
				bAutoTransferPartsToDrill:=FALSE;
				bAutoTransferDownAndLoad:=FALSE;
			END_IF


		10:(* Check for Parts Load Side *)
			(* Load side set to A *)
			IF  sLoadSideSet = 'A' THEN
				(* When A side not enabled there should be no parts *)
				IF NOT(bSideAEnabled)  AND (bProx410 OR bProx411 OR bProx412) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 11;
					nTransferState := 255;
				(* When A side enabled all parts should be there *)
				ELSIF bSideAEnabled AND (NOT bProx410 OR NOT bProx411 OR NOT bProx412) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 12;
					nTransferState := 255;
				(* When Side B not enabled there should be no parts *)
				ELSIF NOT(bSideBEnabled) AND (bProx413 OR bProx414 OR bProx415) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 13;
					nTransferState := 255;
				(* When B side enabled all parts should be there *)
				ELSIF bSideBEnabled AND (NOT bProx413 OR NOT bProx414 OR NOT bProx415) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 14;
					nTransferState := 255;
				(* Passed checks so raise transfer *)
				ELSE
					IF bCellRunoutRequest THEN
						bLoadPartsConfirmed := FALSE;
						nTransferAutoStep:=15;
					ELSE
						bLoadPartsConfirmed := FALSE;
						nTransferAutoStep:=20;
					END_IF
				END_IF
			(* Load side set to B *)
			ELSIF sLoadSideSet ='B' THEN
				(* When A side not enabled there should be no parts *)
				IF NOT(bSideAEnabled) AND (bProx510 OR bProx511 OR bProx512) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 11;
					nTransferState := 255;
				(* When A side enabled all parts should be there *)
				ELSIF bSideAEnabled AND (NOT bProx510 OR NOT  bProx511 OR NOT bProx512) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 12;
					nTransferState := 255;
				(* When Side B not enabled there should be no parts *)
				ELSIF NOT(bSideBEnabled) AND (bProx513 OR bProx514 OR bProx515) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 13;
					nTransferState := 255;
				(* When B side enabled all parts should be there *)
				ELSIF bSideBEnabled AND (NOT bProx513 OR NOT bProx514 OR NOT bProx515) THEN
					bLoadPartsConfirmed := FALSE;
					bTransferError := TRUE;
					nTransferErrorID := 14;
					nTransferState := 255;
				(* Passed checks so raise transfer *)
				ELSE
					IF bCellRunoutRequest THEN
						bLoadPartsConfirmed := FALSE;
						nTransferAutoStep:=15;
					ELSE
						bLoadPartsConfirmed := FALSE;
						nTransferAutoStep:=20;
					END_IF
				END_IF
			END_IF

		15: (* Make Sure there are no parts on Load Side for Cell Runout *)
			IF  bLoadSideClearOfParts THEN
				nTransferAutoStep:=20;
			ELSE
				IF bTransferError THEN
					nTransferState := 255;
				END_IF
				bTransferError := TRUE;
				nTransferErrorID := 1;
			END_IF

		(* Raise Transfer *)
		20: (* Check Transfer Position and Down *)
			bAutoLower := FALSE;
			IF NOT bTransferAtLoadIndicator THEN
				bTransferError := TRUE;
				nTransferErrorID := 16;
				nTransferState := 255;
			ELSE
				bAutoRaise := TRUE;
				bAutoTransferWatchdog:=TRUE;
				tAutoTransferWatchdogTime := t#20s;
				nTransferAutoStep:=21;
			END_IF

		21: (* Wait for Transfer Raise *)
			(* Fault - Raise took to long *)
			IF fbAutoTransferWatchdog.Q THEN
				bAutoTransferWatchdog:=FALSE;
				bAutoRaise := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 2;
				nTransferState := 255;
			(* Fault - Both Up and Down Proxes on *)
			ELSIF bProx517 AND bProx516 THEN
				bAutoTransferWatchdog:=FALSE;
				bAutoRaise := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 3;
				nTransferState := 255;
			(* Done with Raise *)
			ELSIF fbProx516TON.Q AND bAutoRaise THEN
				bAutoTransferWatchdog:=FALSE;
				nTransferAutoStep:=22;
			END_IF

		22: (* Check Load Side Proxes are all  Off *)
			IF bLoadSideClearOfParts THEN
				nTransferAutoStep:=2;
			ELSE
				bTransferError := TRUE;
				nTransferErrorID := 8;
				nTransferState := 255;
			END_IF


		(* Transfer to Drill/Unload *)
		30: (* Check for Parts on Unload Side and Transfer UP *)
			bLoadPartsConfirmed := FALSE;
			IF NOT  bUnloadSideClearOfParts THEN
				bTransferError := TRUE;
				nTransferErrorID := 17;
				nTransferState := 255;
			(* Check Transfer Up *)
			ELSIF NOT(fbProx516TON.Q) AND bProx517 THEN
				bTransferError := TRUE;
				nTransferErrorID := 9;
				nTransferState := 255;
			(* Checks OK *)
			ELSE
				nTransferAutoStep:=31;
			END_IF

		31: (* Check W Axis Positions *)
			(* When A enabled WA must be back *)
			IF bSideAEnabled AND NOT( (fWAxisTransferPosition-0.2) <= stWAAxis.NcToPlc.ActPos ) THEN
				bAutoTransferPartsToDrill := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 18;
				nTransferState := 255;
			(* When B enabled WB must be back *)
			ELSIF bSideBEnabled AND NOT( (fWAxisTransferPosition-0.2) <= stWBAxis.NcToPlc.ActPos ) THEN
				bAutoTransferPartsToDrill := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 19;
				nTransferState := 255;
			(* W Axis checked Ok *)
			ELSE
				nTransferAutoStep:=32;
			END_IF

		32: (* Initiate U Axis Move *)
			bUnloadPartsConfirmed:=FALSE;
			bTransferAxisMove := TRUE;
			fTransferMovePosition := fUAxisUnloadSidePosition;
			bAutoTransferWatchdog:=TRUE;
			tAutoTransferWatchdogTime := t#60s;
			nTransferAutoStep:=33;
			IF nCellRunoutCounter>=1 THEN
				nCellRunoutCounter:= nCellRunoutCounter-1;
			END_IF

		33: (* Wait for Move Done *)
			(* Move did not complete in time *)
			IF fbAutoTransferWatchdog.Q THEN
				bAutoTransferWatchdog:=FALSE;
				bTransferAxisMove := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 4;
				nTransferState := 254; (* Issue a stop *)
			(* Fault - Move Error *)
			ELSIF fbTransferAxisMove.Error THEN
				bAutoTransferWatchdog:=FALSE;
				bTransferAxisMove := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 5;
				nTransferState := 254; (* Issue a stop *)
			(* Move Done*)
			ELSIF bTransferAxisMove AND fbTransferAxisMove.Done THEN
				bAutoTransferPartsToDrill := FALSE;
				bAutoTransferWatchdog:=FALSE;
				bTransferAxisMove := FALSE;
				IF bCellRunoutRequest AND nCellRunoutCounter=1 THEN
					nTransferAutoStep:=40;
				ELSE
					nTransferAutoStep:=2;
				END_IF
			END_IF

		(* Lower Transfer *)
		40: (* Check Position of the Transfer *)
			IF bProx517 AND bProx516 THEN
				bTransferError := TRUE;
				nTransferErrorID := 3;
				nTransferState := 255;
			(* May want to check Transfer Position at Unload *)
			(* Checks OK *)
			ELSE
				bAutoRaise:= FALSE;
				nTransferAutoStep:=41;
			END_IF

		41: (* Lower Transfer *)
			bAutoLower:= TRUE;
			bAutoTransferWatchdog:=TRUE;
			tAutoTransferWatchdogTime := t#30s;
			(* Fault - Lower did not complete in time *)
			IF fbAutoTransferWatchdog.Q THEN
				bAutoTransferWatchdog:=FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 6;
				nTransferState := 255;
			(* Down - Go to Move *)
			ELSIF fbProx517TON.Q  THEN
				bAutoTransferWatchdog:=FALSE;
				nTransferAutoStep:=nTransferAutoStep+1;
			END_IF

		42:(* Check that parts made it to Side A unload positions *)
			IF bSideADrilledParts THEN
				IF (sLoadSideSet = 'A') THEN
					(* Parts Missing on A side of Unload *)
					IF NOT(bProx510 AND bProx511 AND bProx512) THEN
						(* Fault - Parts missing on A side of Unload *)
						bTransferError := TRUE;
						nTransferErrorID := 10;
						nTransferState := 255;
						(* Clear both side tracking because we are asking for Operator Intervention *)
						bSideADrilledParts:=FALSE;
						bSideBDrilledParts:=FALSE;
					ELSE
						bSideADrilledParts:=FALSE;
						nTransferAutoStep:=nTransferAutoStep+1;
					END_IF
				ELSIF (sLoadSideSet = 'B') THEN
					(* Parts Missing on A side of Unload *)
					IF NOT(bProx410 AND bProx411 AND bProx412) THEN
						(* Fault - Parts missing on A side of Unload *)
						bTransferError := TRUE;
						nTransferErrorID := 10;
						nTransferState := 255;
						(* Clear both side tracking because we are asking for Operator Intervention *)
						bSideADrilledParts:=FALSE;
						bSideBDrilledParts:=FALSE;
					ELSE
						bSideADrilledParts:=FALSE;
						nTransferAutoStep:=nTransferAutoStep+1;
					END_IF
				END_IF
			(* Drilled Parts were not transfered for Side A, so check Side B *)
			ELSE
				nTransferAutoStep:=nTransferAutoStep+1;
			END_IF

		43:(* Check that parts made it to unload positions *)
			IF bSideBDrilledParts THEN
				IF (sLoadSideSet = 'A') THEN
					(* Parts Missing on B side of Unload *)
					IF NOT(bProx513 AND bProx514 AND bProx515) THEN
						(* Fault - Parts missing on B side of unload *)
						bTransferError := TRUE;
						nTransferErrorID := 15;
						nTransferState := 255;
						bSideBDrilledParts:=FALSE;
					ELSE
						bSideBDrilledParts:=FALSE;
						nTransferAutoStep:=50;
					END_IF
				ELSIF (sLoadSideSet = 'B') THEN
					(* Parts Missing on B side of Unload *)
					IF NOT(bProx413 AND bProx414 AND bProx415) THEN
						(* Fault - Parts missing on A side of Unload *)
						bTransferError := TRUE;
						nTransferErrorID := 15;
						nTransferState := 255;
						bSideBDrilledParts:=FALSE;
					ELSE
						bSideBDrilledParts:=FALSE;
						nTransferAutoStep:=50;
					END_IF
				END_IF
			(* Drilled Parts were not transfered for Side B, Move on *)
			ELSE
				nTransferAutoStep:=50;
			END_IF;

		(* Transfer to Load Position *)
		50: (* Trigger Move *)
			bTransferAxisMove := TRUE;
			fTransferMovePosition := fUAxisLoadSidePosition;
			bAutoTransferWatchdog:=TRUE;
			tAutoTransferWatchdogTime := t#60s;
			nTransferAutoStep:=51;

		51: (* Wait for Move Done *)
			(* Fault - Move did not complete in time *)
			IF fbAutoTransferWatchdog.Q THEN
				bAutoTransferWatchdog:=FALSE;
				bTransferAxisMove := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 4;
				nTransferState := 254; (* Issue a Stop *)
			(* Fault - Move Error *)
			ELSIF fbTransferAxisMove.Error THEN
				bAutoTransferWatchdog:=FALSE;
				bTransferAxisMove := FALSE;
				bTransferError := TRUE;
				nTransferErrorID := 5;
				nTransferState := 254; (* Issue a Stop *)
			(* Move Done*)
			ELSIF fbTransferAxisMove.Done THEN
				bAutoTransferWatchdog:=FALSE;
				bTransferAxisMove := FALSE;
				nTransferAutoStep:=2;
			END_IF

		END_CASE (* nTransferAutoStep *)


	254: (* Stop U Axis *)
		(* This step is necessary so we turn off the move command in a seperate scan of the program
		 than we turn on the stop command *)
		bUStop:=TRUE;
		bAutoTransferWatchdog:=TRUE;
		tAutoTransferWatchdogTime := t#1s;
		IF fbUAxisStop.Done OR fbAutoTransferWatchdog.Q THEN
			bUStop:=FALSE;
			bAutoTransferWatchdog:=FALSE;
			IF bTransferError THEN
				nTransferState:=255;
			ELSE
				nTransferState:=0;
			END_IF
		END_IF


	255: (* Fault State *)
		(* When in Auto Mode *)
		IF bMachineMode THEN
			(* Require that the fault be reset by the push button *)
			IF bFaultResetPB OR fbCommonFautlResetTON.Q THEN
				bTransferError := FALSE;
			END_IF
			(* When the error has been reset display "Press Cycle Start" *)
			IF  NOT bTransferError THEN
					bDispPressCycleStart:=TRUE;
				(* We want to wait for the Cycle Start to activate the transfer again. *)
				IF  MAIN.bCycleStartControlEnable THEN
					bDispPressCycleStart:=FALSE;
					(* When the transfer auto step is > 40 we want to go back to that step *)
					IF nTransferAutoStep < 40 THEN
						(* Otherwise we want to return step 2 to see what to do next *)
						nTransferAutoStep:=2;
					END_IF
					nTransferState := 2;
				END_IF
			END_IF
		(* In Manual we just jump back *)
		ELSE
			bTransferError := FALSE;
			nTransferState := 0;
			nTransferManualStep:=0;
		END_IF


	END_CASE	(* nTransferState *)

ELSE (* Reset all State Counters *)
	bAutoRaise := FALSE;
	bAutoLower := FALSE;
	nTransferState:=0;
	nTransferManualStep:=0;
	nTransferAutoStep:=0;
	bCellRunoutRequest:= FALSE;

END_IF

fbMoveToUnloadRTrig(CLK:=bAutoTransferPartsToDrill);
fbDownAndLoadRTrig(CLK:=bAutoTransferDownAndLoad AND NOT bFaultResetPB AND NOT fbCommonFautlResetTON.Q);
fbAutoTransferWatchdog(IN:=bAutoTransferWatchdog, PT:= tAutoTransferWatchdogTime);
fbUAxisStopTrig(CLK:= NOT(bMachineMode AND bInCycle) );
fbCellRunoutTrig(CLK:=bCellRunoutPB);

(* The bError bit will be on for one cycle when triggered and then will be reset the next scan in step 255 of the FB
So we want to translate into a text string from the error code *)
IF bTransferError THEN
	CASE nTransferErrorID OF
	01: sTransferErrorText := '01 - Load Side Must be Clear of Parts';
	02: sTransferErrorText := '02 - Transfer Did Not Raise In Time';
	03: sTransferErrorText := '03 - Transfer Raise-Lower Proxes All On';
	04: sTransferErrorText := '04 - Transfer Move Took To Long';
	05: sTransferErrorText := '05 - Transfer Move Command Failure';
	06: sTransferErrorText := '06 - Transfer Did Not Lower In Time';
	07: sTransferErrorText := '07 - W and X Axis Must be Homed';
	08: sTransferErrorText := '08 - Load Proxs Still Indicate Parts';
	09: sTransferErrorText := '09 - Transfer Must be Up to Move to Drill';
	10: sTransferErrorText := '10 - Parts Missing at Side A of Unload';
	11: sTransferErrorText := '11 - Side A Disabled, Remove Parts';
	12: sTransferErrorText := '12 - Side A Parts Missing on the Load Side';
	13: sTransferErrorText := '13 - Side B Disabled, Remove Parts';
	14: sTransferErrorText := '14 - Side B Parts Missing on the Load Side';
	15: sTransferErrorText := '15 - Parts Missing at Side B of Unload';
	16: sTransferErrorText := '16 - Transfer Must be at Load Position';
	17: sTransferErrorText := '17 - Unload Side Must be Clear of Parts';
	18: sTransferErrorText := '18 - WA Axis to far Forward to Transfer';
	19: sTransferErrorText := '19 - WB Axis to far Forward to Transfer';

	(* Errors > 50 are handled as Faults by the Program and Kick out of Auto *)
	50: sTransferErrorText := '00 - Transfer Must be at Load Position to go into Auto';
	51: sTransferErrorText := '01 -  X Axis Must be Homed to go into Auto';
	52: sTransferErrorText := '02 - Transfer Must be Down to go into Auto';
	53: sTransferErrorText := '03 - W and X Axis Must be Homed to go into Auto';
	54: sTransferErrorText := '04 - Transfer Raise and Lower Proxes On At Same Time';
	END_CASE
END_IF


END_ACTION



(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE AutoCycleStates :
(
	AC_Init:=0,
	AC_TransferParts,
	AC_Clamp,
	AC_ReturnTransfer,
	AC_CoolantOn,
	AC_SpindleOn,
	AC_Drill,
	AC_Retract,
	AC_SpindleOff,
	AC_CoolantOff,
	AC_Unclamp,
	AC_Finish,
	AC_CellRunoutFinish,
	AC_DrillReturn
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE AutoModeStates :
(
	AM_NotInCycle:=0,
	AM_RetractZAxis,
	AM_InCycle,
	AM_GotoManualMode
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE Ke_Energy :
STRUCT
	fEnergy:LREAL:=0.0;
	sUnits:STRING(3):='kWh';
END_STRUCT
END_TYPE


(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE Ke_ErrorCodev2 :
(
	Er_NoError:=0,
	Er_MotorStarterFailed,
	Er_ServoWarning,
	Er_ServoFault,
	Er_InvalidParameters,
	Er_DrillReturn,
	Er_InvalidToolDiameter,
	Er_InvalidIPM,
	Er_InvalidIPR,
	Er_InvalidRPM,
	Er_InvalidSFM,
	Er_InvalidRatio,
	Er_InvalidOverride,
	Er_InvalidIPAddress,
	Er_UpToSpeedTimeout,
	Er_DriveNotReady,
	Er_DriveFaulted,
	Er_DriveWarning,
	Er_DriveComm,
	Er_NoJogRate,
	Er_NoRapidRate
);
END_TYPE

(* Would like to eleminate this Data Type *)
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE Ke_OperationTime :
STRUCT
	nYears:UINT:=0;
	nDays:UINT:=0;
	nHours:UINT:=0;
	nMinutes:UINT:=0;
	nSeconds:UINT:=0;
END_STRUCT
END_TYPE


(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE Ke_VFDInfo :
STRUCT
	bDataValid:BOOL;
	nStatusWord:WORD;
	nControlWord:WORD;
	nReferenceSpeed:UINT;
	nActualSpeed:UINT;
	fFrequencyReference:LREAL;
	fFrequencyOut:LREAL;
	fFrequencyMin:LREAL;
	fFrequencyMax:LREAL;
	nFrequencyScale:USINT;
	nMotorSpeed:INT;
	nMotorNominalSpeed:INT;
	fMotorNominalFrequency:LREAL;
	fMotorVoltage:LREAL;
	fMotorNominalVoltage:LREAL;
	fMotorCurrent:LREAL;
	fMotorNominalCurrent:LREAL;
	nCurrentScale:UINT;
	fMotorCurrentLimit:LREAL;
	fMotorTorque:LREAL;
	fMotorPower:LREAL;
	fAccelerationTime:LREAL;
	fDecelerationTime:LREAL;
	fRampTimeScale:LREAL;
	nPolePairNumber:UINT;
	nDCLinkVoltage:UINT;
	nActiveFault:USINT;
	stDayCounter:Ke_OperationTime;
	stDayCounterResettable:Ke_OperationTime;
	stEnergyCounter:Ke_Energy;
	stEnergyCounterResettable:Ke_Energy;
	arrFaultHistory:ARRAY[1..16] OF WORD;
END_STRUCT
END_TYPE


(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE Ke_VFDState :
(
	VFD_NotReady:=0,
	VFD_Ready,
	VFD_Run,
	VFD_Fault,
	VFD_OpDayReset,
	VFD_EnergyReset,
	VFD_Run_Setup,
	VFD_Run_Request,
	VFD_Run_AtSpeed,
	VFD_Run_Override,
	VFD_Run_Stop
);
END_TYPE


(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ManualModeStates :
(
	MM_Nothing:=0,
	MM_JogForward:=1,
	MM_JogReverse,
	MM_IncrForward,
	MM_IncrReverse,
	MM_SetZAZero,
	MM_SetZBZero,
	MM_MoveZAToZero,
	MM_MoveZBToZero,
	MM_CounterRotationJog,
	MM_Setup,
	MM_SetupModeAWSpindle,
	MM_SetupModeBWSpindle,
	MM_GotoAutomaticMode,
	MM_CoolantOn,
	MM_CoolantOff,
	MM_Calculate,
	MM_MakeOverrideCurrent,
	MM_MakeCalculatedCurrent,
	MM_ClampPart,
	MM_UnclampPart,
	MM_MPGToggle,
	MM_HydraulicUnitStart,
	MM_HydraulicUnitStop,
	MM_HomeZAxis,
	MM_HomeAutomation,
	MM_XMPG,
	MM_YMPG,
	MM_ZMPG,
	MM_WMPG
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ModeErrors :
(
	Er_NoModeError:=0,
	Er_CoolantOff:=1,
	Er_CleanTankLow,
	Er_CoolantOverflow,
	Er_HPPumpOff,
	Er_AMClampTimeout,
	Er_AMCoolantTimeout,
	Er_VFDUpToSpeedTimeout,
	Er_MMCoolantStartTimeout,
	Er_MMCoolantValveStopTimeout,
	Er_AMUnclampTimeout,
	Er_MPG_A_Active,
	Er_MPG_B_Active,
	Er_HydraulicPSOff,
	Er_XAxisNotHomed,
	Er_TransferNotAtLoad,
	Er_ZAAxisNotHomed,
	Er_WAAxisNotHomed,
	Er_WANotRetracted,
	Er_ACulletNotUnclamped,
	Er_AEjectorsNotRetracted,
	Er_ZBAxisNotHomed,
	Er_WBAxisNotHomed,
	Er_WBNotRetracted,
	Er_BCulletNotUnclamped,
	Er_BEjectorsNotRetracted,
	Er_EMNoAuto,
	Er_SetupError,
	Er_PartNotUnclamped,
	Er_PartUnclamped,
	Er_LoadPartMissing,
	Er_UnloadPartPresent,
	Er_ZAHomeError,
	Er_ZBHomeError,
	Er_ZAMoveError,
	Er_ZBMoveError,
	Er_HomeTimeout,
	Er_TryingToLeaveAutoInCycle,
	Er_TransferSolError,
	Er_SideAColletSolError,
	Er_SideBColletSolError,
	Er_SideAEjectorsSolError,
	Er_SideBEjectorsSolError,
	Er_MaxCyclesReached
);
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CX_Publish1 :
	(******* Replace Auto Display, Fault String, and panel Receive Structures ****************)
STRUCT
	(* The structure of Arrays are Published by the CX program.  We must use this definition to decrypt  them in the translate PRG
		The arrays should be at least 25%  greater than what is used, So we do not have to re-define the structure and 
		re-establish the communication connections *)
	arrUDINTIGER: ARRAY[1..50] OF UDINT := 0;
	arrLREAL: ARRAY[1..50] OF LREAL := 0.0;
	arrSTRING50 : ARRAY[1..12] OF STRING (52) := 12('');
	arrBOOL: ARRAY[1..96] OF BOOL:= FALSE;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_Demo_Indicators :
STRUCT
	LT1A:BOOL;
	LT2A:BOOL;
	LT1B:BOOL;
	LT2B:BOOL;
	LTCom:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_Demo_PBs :
STRUCT
	bPB1:BOOL;
	bPB2:BOOL;
	bPB3:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PANEL_SEND :
STRUCT
	(* The structure of  Arrays sent to the CX program are encripted in the Translate PRG.  The CX must use this definition to decript them it's program
	    The arrays should be at least 25%  greater than what is used, So we do not have to re-define the structure and re-establish the communication connections *)
	arrUDINTIGER: ARRAY[1..20] OF UDINT := 0;
	arrLREAL: ARRAY[1..32] OF LREAL := 0.0;
	arrBOOL: ARRAY[1..96] OF BOOL:= FALSE;
	arrTEXTSTRING: ARRAY[1..8] OF STRING (28) := 8('');

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PARTPROGRAM :
	(* The structure of Arrays are defined in the CX program.  We must use this definition to decript them in the translate PRG
		The arrays should be at least 25%  greater than what is used, So we do not have to re-define the structure and 
		re-establish the communication connections *)
STRUCT
	(*  This structure are variables of the Part Program to be displayed when on the Part Program Screen *)
	arrLREAL : ARRAY[1..18] OF LREAL := 0.0;
	arrSTRING : ARRAY[1..4] OF STRING(30) := 3('');
	arrBOOL: ARRAY[1..32] OF BOOL:= FALSE;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @PATH := '' *)

VISUALISATION MONITORING _VISU_TYPES : 1,1
_BG_BMP : ''
_TEXT : 192
_PAINTZOOM : 100

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 440,453,800,469,620,461
_COLORS : 16777215,0,8421631,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nFaultArrayIndex>1','',''
_DSP : 'arrFaultMessage[1]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,3,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 440,469,800,485,620,477
_COLORS : 16777215,0,8421631,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nFaultArrayIndex>2','',''
_DSP : 'arrFaultMessage[2]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,5,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 440,485,800,501,620,493
_COLORS : 16777215,0,8421631,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nFaultArrayIndex>3','',''
_DSP : 'arrFaultMessage[3]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,6,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 10,482,436,498,223,490
_COLORS : 16777215,0,8454143,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nWarningArrayIndex>1','',''
_DSP : 'arrFaultMessage[6]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,7,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 10,498,436,514,223,506
_COLORS : 16777215,0,8454143,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nWarningArrayIndex>2','',''
_DSP : 'arrFaultMessage[7]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,9,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 10,514,436,530,223,522
_COLORS : 16777215,0,8454143,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nWarningArrayIndex>3','',''
_DSP : 'arrFaultMessage[8]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,10,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 440,501,800,517,620,509
_COLORS : 16777215,0,8421631,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nFaultArrayIndex>4','',''
_DSP : 'arrFaultMessage[4]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,11,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 440,517,800,533,620,525
_COLORS : 16777215,0,8421631,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','nFaultArrayIndex>5','',''
_DSP : 'arrFaultMessage[5]',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967285,400,0,12,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 170,18,296,40,233,29
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'stZAAxis.NcToPlc.ActPos',' %.3f  mm',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,14,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 170,52,297,74,233,63
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'stZBAxis.NcToPlc.ActPos',' %.3f  mm',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,16,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 0,84,30,114,14,98
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','stWAAxis.NcToPlc.StateDWord.1','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,21,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 0,152,30,182,15,167
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','stUAxis.NcToPlc.StateDWord.1','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,23,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 39,87,199,112,119,99
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','WA Axis Home Flag',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,24,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 39,155,203,180,121,167
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','X Axis Home Flag',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,25,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 3
_NOCOLORS : 0,0
_POS : 140,154,297,183,218,168
_COLORS : 16777215,16777215,16777215,65280,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'stUAxis.NcToPlc.ActPos',' %.3f  mm',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,26,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 0,118,30,148,15,133
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','stWBAxis.NcToPlc.StateDWord.1','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,27,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 39,121,206,146,122,133
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','WB Axis Home Flag',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,28,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 3
_NOCOLORS : 0,0
_POS : 140,120,297,149,218,134
_COLORS : 16777215,16777215,16777215,65280,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'stWBAxis.NcToPlc.ActPos',' %.3f  mm',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,30,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 3
_NOCOLORS : 0,0
_POS : 140,86,297,115,218,100
_COLORS : 16777215,16777215,16777215,65280,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'stWAAxis.NcToPlc.ActPos',' %.3f  mm',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,31,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 0,14,30,44,15,29
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','stZAAxis.NcToPlc.StateDWord.1','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,32,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 39,17,199,42,119,29
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','ZA Axis Home Flag',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,33,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 0,48,30,78,15,63
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','stZBAxis.NcToPlc.StateDWord.1','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,34,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 39,51,206,76,122,63
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','ZB Axis Home Flag',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,35,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 420,0,626,38,523,19
_COLORS : 12632256,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleRPM1A','Spindle A1 %i  RPM',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,36,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 420,20,626,58,523,39
_COLORS : 12632256,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleRPM2A','Spindle A2 %i  RPM',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,37,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 420,40,626,78,523,59
_COLORS : 12632256,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleRPM3A','Spindle A3 %i  RPM',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,38,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 420,74,626,112,523,93
_COLORS : 12632256,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleRPM1B','Spindle B1 %i  RPM',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,39,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 420,94,626,132,523,113
_COLORS : 12632256,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleRPM2B','Spindle B2 %i  RPM',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,40,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 420,114,626,152,523,133
_COLORS : 12632256,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleRPM3B','Spindle B3 %i  RPM',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,41,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 4,211,25,232,14,221
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bHydraulicSystemPressure','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,45,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 31,208,213,233,122,220
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Hydraulic System PS4',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,46,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 4,258,25,279,14,268
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bTransferPumpMotorRunning','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,51,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 32,258,213,283,122,270
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Transfer Pump MS2',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,52,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 4,281,25,302,14,291
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bHighPressureMotorRunning','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,53,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 31,278,232,303,131,290
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','High Pressure Pump MS1',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,54,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 4,303,25,324,14,313
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bChipConveyorMotorRunning','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,55,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 31,300,239,325,135,312
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Chip Conveyor Run',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,56,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 6,327,24,344,15,335
_COLORS : 12632256,0,65535,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bACoolantSolenoid','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,58,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 30,322,239,350,134,336
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','SOL 4 Side A Coolant On',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,59,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 6,347,24,364,15,355
_COLORS : 12632256,0,65535,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bBCoolantSolenoid','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,60,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 30,342,239,370,134,356
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','SOL 5 Side B Coolant On',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,61,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 4,235,25,256,14,245
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bPneumaticSystemPressure','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,67,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 31,232,239,257,135,244
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Main Air Pressure PS5 ',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,68,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 2
_NOCOLORS : 1,1
_POS : 4,187,25,208,14,197
_COLORS : 255,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bLubePressure','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,400,0,69,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 31,184,239,209,135,196
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Lube Pressure PS3',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,70,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 287,203,532,228,409,215
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #1 Advanced  PROX 613',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,80,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 287,242,532,267,409,254
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #2 Advanced  PROX 614',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,81,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 287,289,531,314,409,301
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #3 Advanced PROX 615',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,82,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 267,266,533,291,400,278
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #3 Retracted PROX 612',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,83,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 267,225,530,250,398,237
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #2 Retracted PROX 611',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,84,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 268,184,530,209,399,196
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #1 Retracted  PROX 610',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,85,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 238,186,261,209,249,197
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,86,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 240,186,261,207,250,196
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx610','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,87,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 258,204,281,227,269,215
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,88,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 260,204,281,225,270,214
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx613','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,89,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 238,225,261,248,249,236
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,90,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 240,225,261,246,250,235
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx611','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,91,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 258,243,281,266,269,254
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,92,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 260,243,281,264,270,253
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx614','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,93,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 238,266,261,289,249,277
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,94,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 240,266,261,287,250,276
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx612','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,95,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 258,289,281,312,269,300
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,96,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 260,289,281,310,270,299
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx615','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,97,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 264,90,395,114,329,102
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nWAAxisThrust/10.0',' %.1f %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,98,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 1
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 8,380,83,418,45,399
_COLORS : 12632256,0,16776960,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bPS617','',''
_DSP : '','Clamp$R$NPS 617',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,99,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 1
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 8,422,83,460,45,441
_COLORS : 12632256,0,16776960,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bPS616','',''
_DSP : '','Unclamp$R$NPS 616',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,100,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 266,124,397,148,331,136
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nWBAxisThrust/10.0',' %.1f %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,103,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 1
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 114,380,189,420,151,400
_COLORS : 12632256,0,16776960,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bPS727','',''
_DSP : '','Clamp$R$NPS 727',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,104,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 1
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 114,422,189,460,151,441
_COLORS : 12632256,0,16776960,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bPS726','',''
_DSP : '','Unclamp$R$NPS 726',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,105,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 285,340,530,365,407,352
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #1 Advanced  PROX 723',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,109,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 285,378,530,403,407,390
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #2 Advanced  PROX 724',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,110,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 286,414,530,439,408,426
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #3 Advanced PROX 725',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,111,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 265,395,531,420,398,407
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #3 Retracted PROX 722',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,112,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 265,359,528,384,396,371
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #2 Retracted PROX 721',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,113,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 265,322,527,347,396,334
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Ejector #1 Retracted  PROX 720',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,400,0,114,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 236,323,259,346,247,334
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,115,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 238,323,259,344,248,333
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx720','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,116,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 256,341,279,364,267,352
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,117,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 258,341,279,362,268,351
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx723','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,118,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 236,360,259,383,247,371
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,119,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 238,360,259,381,248,370
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx721','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,120,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 256,379,279,402,267,390
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,121,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 258,379,279,400,268,389
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx724','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,122,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 236,396,259,419,247,407
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,123,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 238,396,259,417,248,406
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx722','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,124,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 257,415,280,438,268,426
_COLORS : 0,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,125,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 259,415,280,436,269,425
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx725','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,126,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 560,276,705,304,632,290
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 410',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,127,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 528,278,551,301,543,293
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,128,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 530,278,551,299,544,292
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx410','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,129,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 560,300,705,328,632,314
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 411',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,130,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 528,302,551,325,543,317
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,131,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 530,302,551,323,544,316
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx411','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,132,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 560,324,705,352,632,338
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 412',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,133,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 528,326,551,349,543,341
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,134,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 530,326,551,347,544,340
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx412','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,135,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 694,276,839,304,766,290
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 413',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,136,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 662,278,685,301,677,293
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,137,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 664,278,685,299,678,292
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx413','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,138,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 694,300,839,328,766,314
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 414',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,139,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 662,302,685,325,677,317
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,140,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 664,302,685,323,678,316
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx414','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,141,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 694,324,839,352,766,338
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 415',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,142,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 662,326,685,349,677,341
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,143,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 664,326,685,347,678,340
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx415','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,144,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 562,360,707,388,634,374
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 510',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,145,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 530,362,553,385,545,377
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,146,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 532,362,553,383,546,376
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx510','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,147,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 562,384,707,412,634,398
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 511',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,148,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 530,386,553,409,545,401
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,149,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 532,386,553,407,546,400
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx511','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,150,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 562,408,707,436,634,422
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 512',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,151,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 530,410,553,433,545,425
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,152,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 532,410,553,431,546,424
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx512','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,153,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 693,360,838,388,765,374
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 513',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,154,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 661,362,684,385,676,377
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,155,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 663,362,684,383,677,376
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx513','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,156,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 693,384,838,412,765,398
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 514',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,157,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 661,386,684,409,676,401
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,158,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 663,386,684,407,677,400
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx514','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,159,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 693,408,838,436,765,422
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 515',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,160,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 661,410,684,433,676,425
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,161,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 663,410,684,431,677,424
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx515','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,162,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 312,16,403,44,357,30
_COLORS : 10994885,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nServoAThrustDisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,165,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 312,50,403,78,357,64
_COLORS : 10994885,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nServoBThrustDisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,166,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 628,26,719,54,674,40
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleLoad2ADisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,167,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 628,46,719,74,674,60
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleLoad3ADisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,168,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 626,6,717,34,672,20
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleLoad1ADisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,169,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 628,102,719,130,674,116
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleLoad2BDisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,170,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 628,122,719,150,674,136
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleLoad3BDisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,171,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 628,80,719,108,674,94
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nSpindleLoad1BDisplay','%i %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967280,700,0,172,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 266,158,397,182,331,170
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'nUAxisThrust/10.0',' %.1f %%',''
_ZOOM : ''
_INPUT : 0
_TEXT : 6,4294967280,700,0,176,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 579,180,739,205,659,192
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','AutoCycle State',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,177,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 560,246,743,262,651,254
_COLORS : 16777215,0,8421631,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'INT_TO_STRING(nAutoCycleStep)',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967285,400,0,178,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 620,150,680,175,650,162
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : 'NOT(bMachineMode)','','',''
_DSP : '','Auto',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,181,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 620,150,680,175,650,162
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : 'bMachineMode','','',''
_DSP : '','Man',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,182,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 212,447,427,472,319,459
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : 'NOT(bCellRunOutRequest)','','',''
_DSP : '','Cell Runout Requested',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,183,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 579,220,739,245,659,232
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','Automode State',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967280,700,0,184,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 560,206,743,222,651,214
_COLORS : 16777215,0,8421631,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : 'INT_TO_STRING(nAutoModeState)',' %s',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967285,400,0,185,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 782,30,971,58,876,44
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 516 - XFR Up',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,186,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 750,32,773,55,765,47
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,187,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 752,32,773,53,770,50
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx516','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,188,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 0
_LINEWIDTH : 0
_NOCOLORS : 0,0
_POS : 782,54,971,82,876,68
_COLORS : 16777215,0,16777215,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','PROX 517 XFR Dn',''
_ZOOM : ''
_INPUT : 0
_TEXT : 4,4294967277,400,0,189,0,0,0
_FONT : 'Arial'
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 750,56,773,79,765,71
_COLORS : 0,0,0,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,190,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)

_SIMPLE : 2
_LINEWIDTH : 0
_NOCOLORS : 1,1
_POS : 752,56,773,77,770,70
_COLORS : 12632256,0,65280,0,0
_VARIABLES : '','','','','','','',''
_THRESH : '','bProx517','',''
_DSP : '','',''
_ZOOM : ''
_INPUT : 0
_TEXT : 5,4294967284,400,0,191,0,0,0
_FONT : ''
_EXEC : ''
_TEXTVARIABLES : '','','','',''
_COLORVARIABLES : '','','','','',''
_ACCESSLEVELS : 2,2,2,2,2,2,2,2
_OBJECT : 0,0
_THRESH2 : '','','',''
_INPUTTYPE : '','',''
_HIDDENINPUT : 0
_END_ELEM
(* @TEXTSCALINGVARS := '_TEXTSCALINGVARS: $'$',$'$'' *)
(* @EXTENDEDSIMPLESHAPE := '_SIMPLE: 0' *)
(* @INPUTTAPFALSE := '_INPUTTAPFALSE: 0' *)
_KEYINFOLIST : 0
END_VISUALISATION

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Global_Variables' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL
	sCurrentProgram : STRING(20) := 'None';			(* Current Program Loaded or Saved *)

	(* ***** SECURITY ***** *)
	sUsername: STRING := '';
	sPassword : STRING := '';
	sSavePassword : STRING := '';					(* Password Variable for the Save Screen *)
	OldUserLevel : INT := 0;						(* Previous User Level before logging in *)
	CurrentUserLevel : INT :=0;						(* Current User Level*)
	bWrongPassword :BOOL:=FALSE;				(*The password is not correct*)
	bWrongSavePassword :BOOL:=FALSE;				(*The password is not correct*)
	bUserNameHandshake: BOOL := FALSE;			(* Handshake bit to tell panels the User Name Input was received *)
	bPasswordHandshake: BOOL := FALSE;			(* Handshake bit to tell panels the Password Input was received *)
	bSavePasswordHandshake: BOOL := FALSE;		(* Handshake bit to tell panels the Password Input was received *)
	(* SECURITY LEVELS *)
	(* Level 7 - Kays is no longer needed *)
	sUsernameKays : STRING := 'Kays';					(* Username for Kays Engineering *)
	sUsernameKaysLC : STRING := 'kaysengineering';		(* Username for Kays Engineering - Lower Case*)
	sUsernameKaysEngineering : STRING := 'KaysEngineering';		(* Username for Kays Engineering *)
	sPasswordKays : STRING := 'Dehoff';					(* Password for Kays Engineering - Ed's Birthday *)
	(* Level 6 - Maintenance *)
	sUsernameMaint : STRING := 'Maint';					(* Username for Maint *)
	sUsernameMaintLC : STRING := 'maint';				(* Username for maint *)
	sUsernameMaintenance : STRING := 'Maintenance';	(* Username for Maintenance *)
	sUsernameMaintenanceLC : STRING := 'maintenance';	(* Username for maintenance - Lower Case *)
	sPasswordMaint : STRING := 'lazarini';					(* Password for Maintenance - Toggling on the keyboard with the numbers*)
	sPasswordMaintenance : STRING := 'LAZARINI';		(* Password for Maintenance - Toggling on the keyboard with the numbers*)
	(* Level 5 - Supervisor *)
	sUsernameSuper : STRING := 'Super';				(* Username for Super *)
	sUsernameSuperLC : STRING := 'super';				(* Username for super *)
	sUsernameSupervisor : STRING := 'Supervisor';		(* Username for Supervisor *)
	sUsernameSupervisorLC : STRING := 'supervisor';		(* Username for Supervisor  - Lower Case*)
	sPasswordSupervisorUC : STRING := 'ROYALS';		(* Password for Supervisor - Start at 1 and go down then start at 2 and go down keyboard *)
	sPasswordSupervisor : STRING := 'royals';			(* Password for Supervisor - Start at 1 and go down then start at 2 and go down keyboard  - Lower Case*)
	sPasswordSuperUC : STRING := 'ROYALS';		(* Password for Supervisor - Start at 1 and go down then start at 2 and go down keyboard *)
	sPasswordSuper : STRING := 'royals';			(* Password for Supervisor - Start at 1 and go down then start at 2 and go down keyboard  - Lower Case*)

	(* Faulting Variables *)
	bMachineFault: BOOL := FALSE; 					(* Machine Fault Indicator *)
	bMachineWarning: BOOL := FALSE; 				(* Machine Warning Indicator *)
	nFaultArrayIndex : UDINT := 1;
	nWarningArrayIndex : UDINT := 1;
	nModeError : ModeErrors := Er_NoModeError;		(* Errors for different functions *)
	bCoolantTempWarning : BOOL := FALSE;
	bCoolantTempFault : BOOL := FALSE;
	fbCommonFautlResetTON: TON;				(* Trigger of Common Button to Reset Faults *)
	bAFaultResetInternal : BOOL := FALSE;			(* Side A Internal Fault Reset. Triggered by VFD's Ready *)
	bBFaultResetInternal : BOOL := FALSE;			(* Side B Internal Fault Reset. Triggered by VFD's Ready *)
	nActiveFaults: ARRAY[1..4] OF DWORD := 4(0);
	nActiveWarnings: ARRAY[1..4] OF DWORD := 4(0);
	nFaultState: UDINT := 0;
	arrFaultHistory : ARRAY[1..80] OF STRING (52) := 80(''); (* Fault History array *)
	(* Helper Bits *)
	nSetupErrorID: INT :=0;							(* Setup Mode Error Occurred *)
	bLoadSideNotSelected : BOOL := FALSE;
	bTransferError: BOOL := FALSE;					(* An Error Occurred with the Transfer Cycle *)
	nTransferErrorID: INT := 0;						(* Transfer Error ID *)
	sTransferErrorText : STRING := '';				(* Transfer Error Text *)
	(* Parts Tracking *)
	bSideADrilledParts: BOOL := FALSE;				(* Tracking Bit - Side A Completed Drilled parts *)
	bSideBDrilledParts: BOOL := FALSE;				(* Tracking Bit - Side B Completed Drilled parts *)
	fbCoolantLevelDelayTOF: TOF;					(* Delay of the Lowe level switch *)

	(* Status Variables *)
	bMachineMode: BOOL := FALSE;				(* FALSE-->Manual, TRUE-->Automatic *)
	bSetup: BOOL := FALSE;						(* At least one Side in Setup Mode *)
	bSetupA: BOOL := FALSE;						(* In Setup Mode Side A *)
	bSetupB: BOOL := FALSE;						(* In Setup Mode Side B*)
	bInCycle: BOOL := FALSE;						(* In Cycle Flag *)

	(* Cycle Variables *)
	nCycleTimeMinutes : UDINT := 0;
	nCycleTimeSeconds : UDINT := 0;
	nAutoModeState: AutoModeStates := AM_NotInCycle;	(* Counter for Auto Mode State *)
	nAutoCycleStep : AutoCycleStates := AC_Init;		(* Counter for Auto Cycle State *)
	nAC_UnclampStep: INT := 0;					(* Counter for the AC Unclamp Step*)
	bUnloadSideClearOfParts: BOOL :=FALSE;		(* All Unload Side Proxes are off *)
	nCellRunoutCounter: UINT:=0;					(* Counter to keep track of transfer cycles durring Cell Runout *)

	bAutoClampAStart: BOOL := FALSE;				(* Automatic cycle Side A Clamp Parts Tailstock Input *)
	bAutoClampADone: BOOL := FALSE;				(* Automatic cycle Side A Clamp Parts Tailstock Done Output *)
	bAutoClampBStart: BOOL := FALSE;				(* Automatic cycle Side B Clamp PartsTailstock Input *)
	bAutoClampBDone: BOOL := FALSE;				(* Automatic cycle Side B Clamp Parts Tailstock Done Output *)
	bAutoUnclampAStart: BOOL := FALSE;			(* Automatic Side A Unclamp Parts Tailstock Input *)
	bAutoUnclampADone: BOOL := FALSE;			(* Automatic cycle Side A Unclamp Parts Tailstock Done Output *)
	bAutoUnclampBStart: BOOL := FALSE;			(* Automatic Side B Unclamp Parts Tailstock Input *)
	bAutoUnclampBDone: BOOL := FALSE;			(* Automatic cycle Side B Unclamp Parts Tailstock Done Output *)
	bLoadPartsConfirmed: BOOL := FALSE;			(* Operator Confirmed Load Parts In Cycle *)
	bUnloadPartsConfirmed: BOOL := FALSE;			(* Operator Confirmed Unload Parts In Cycle *)
	bAutoTransferPartsToDrill: BOOL := FALSE;		(*Auto Trigger the Transfer to Raise and move parts to Drill Postion*)
	bAutoTransferDownAndLoad : BOOL := FALSE;	(*Auto Trigger the Transfer to lower and move Load Postion*)
	fbProx516TON: TON;							(* Delay of the Transfer Carriage Up Prox *)
	fbProx517TON: TON;							(* Delay of the Transfer Carriage Down Prox *)
	bAutoUpDelayWhileUnclamp: BOOL := FALSE;	(* Auto Helper bit to turn off the up Solenoid when the Unclamp is firing*)

	(*	SERVO VARIABLES *)
	bMCResetRequest: BOOL := FALSE;				(* Request a reset of the NC Axis *)
	bZWADriveResetRequest : BOOL := FALSE;		(* A Side ZW Drive Reset Request *)
	bZBDriveResetRequest : BOOL := FALSE;			(* B Side ZW Drive Reset Request *)
	bZWBDriveResetRequest : BOOL := FALSE;		(* B Side ZW Drive Reset Request *)
	bUDriveResetRequest : BOOL := FALSE;			(* U Axis Drive Reset Request *)
	DriveZAWAdinputs AT %I*: INT;

(* ZA AXIS *)
	stZAAxis: AXIS_REF;
	nZAAxisDiagNumber AT %I*: UDINT := 0;
	nServoZAThrust AT %I* : INT :=0;
	fbZAAxisStop: MC_Stop;
	bZAStop: BOOL := FALSE;
	bZAMCResetRequest: BOOL := FALSE;			(* Request a reset of the NC Axis *)
	fbZAAxisMCReset: MC_Reset;
	fbZAAxisDriveReset : FB_SoEReset;

	bZAAxisEnable: BOOL;
	fbZAAxisPower: MC_Power;
	fbZAAxisMove: MC_MoveAbsolute;
	fbZAAxisSetZero: MC_Home;
	bZAAxisPower: BOOL := FALSE;
	bZAAxisHome: BOOL := FALSE;
	bZAAxisMove: BOOL := FALSE;
	bZAAxisSetZero: BOOL := FALSE;
	fZAMoveVelocity : LREAL := 25.0;
	fZAMovePosition : LREAL := 0.0;
	bZADeCtrlEnable: BOOL := FALSE;				(* Enable for the FB to move off of the Overtravel *)

(* WA AXIS*)
	stWAAxis: AXIS_REF;							(* A Side Tailstock Axis cyclic Interface *)
	nWAAxisDiagNumber AT %I*: UDINT := 0;
	nWAAxisThrust AT %I* : INT :=0;
	fbWAAxisStop: MC_Stop;
	bWAStop: BOOL := FALSE;
	bWAMCResetRequest: BOOL := FALSE;			(* Request a reset of the WA NC Axis *)
	fbWAAxisMCReset: MC_Reset;
	fbWAAxisDriveReset : FB_SoEReset;
	nWATorqeLimitValue AT %Q* : INT := 1000;
	fbWAAxisHome: MC_Home;
	bWAAxisHome: BOOL := FALSE;					(*Trigger the home of WA while homing Automation*)

	DriveZBWBdinputs AT %I*: INT;
(* ZB AXIS *)
	stZBAxis: AXIS_REF;
	nZBAxisDiagNumber AT %I*: UDINT := 0;
	nServoZBThrust AT %I* : INT :=0;
	fbZBAxisStop: MC_Stop;
	bZBStop: BOOL := FALSE;
	bZBMCResetRequest: BOOL := FALSE;			(* Request a reset of the ZA NC Axis *)
	fbZBAxisMCReset: MC_Reset;
	fbZBAxisDriveReset : FB_SoEReset;

	bZBAxisEnable: BOOL;
	fbZBAxisPower: MC_Power;
	fbZBAxisMove: MC_MoveAbsolute;
	fbZBAxisSetZero: MC_Home;
	bZBAxisPower: BOOL := FALSE;
	bZBAxisMove: BOOL := FALSE;
	bZBAxisSetZero: BOOL := FALSE;
	fZBMoveVelocity : LREAL := 25.0;
	fZBMovePosition : LREAL := 0.0;
	bZBDeCtrlEnable: BOOL := FALSE;				(* Enable for the FB to move off of the Overtravel *)

(* WB AXIS *)
	stWBAxis: AXIS_REF;							(* Transfer Axis cyclic Interface *)
	nWBAxisDiagNumber AT %I*: UDINT := 0;
	nWBAxisThrust AT %I* : INT :=0;
	fbWBAxisStop: MC_Stop;
	bWBStop: BOOL := FALSE;
	bWBMCResetRequest: BOOL := FALSE;			(* Request a reset of theWB  NC Axis *)
	fbWBAxisMCReset : MC_Reset;
	fbWBAxisDriveReset : FB_SoEReset;
	nWBTorqeLimitValue AT %Q* : INT  := 1000;
	fbHomeWB: MC_Home;
	bWBAxisHome: BOOL := FALSE;					(*Trigger the home of WB while homing Automation*)

	DriveUdinputs AT %I*: INT;
(* U AXIS 		Also Called X Axis on Screens *)
	stUAxis: AXIS_REF;							(* Transfer Axis cyclic Interface *)
	nUAxisDiagNumber AT %I*: UDINT := 0;
	nUAxisThrust AT %I* : INT :=0;
	fbUAxisStop: MC_Stop;
	bUStop: BOOL := FALSE;
	bUMCResetRequest: BOOL := FALSE;			(* Request a reset of the U NC Axis *)
	fbUAxisMCReset : MC_Reset;
	fbUAxisDriveReset : FB_SoEReset;
	fbTransferAxisHome: MC_Home;
	bUAxisHome: BOOL := FALSE;					(*Trigger the home of U Axis while homing Automation*)
	fTransferMoveVelo : LREAL := 0.0;				(* Velocity to pass to the U Axis Move FB *)

(* MPG Axis Definitions *)
	stAxisMPG_A : Axis_REF;						(* Side A MPG Axis Cyclic Interface *)
	fbMPGAAxisMCReset: MC_Reset;
	stAxisMPG_B : Axis_REF;						(* Side A MPG Axis Cyclic Interface *)
	fbMPGBAxisMCReset: MC_Reset;
	bMPGA_MCResetRequest: BOOL := FALSE;		(* Axis Reset of the MPGA Axis *)
	bMPGB_MCResetRequest: BOOL := FALSE;		(* Axis Reset of the MPGB Axis *)
	bMPGAOn: BOOL := FALSE;						(* MPG A has an axis selected *)
	bMPGBOn: BOOL := FALSE;						(* MPG B has an axis selected *)

(* VFD Control Variables - EtherCAT Emerson *)
	fbGetAMS: FB_GetAxisAmsAddr;
	fbVFD_A1: FB_EtherCAT_Emerson;
	bVFD_A1DataValid AT %I*: BOOL;				(* Must Asign to VFD WcStateIn in System Manager*)
	fbVFD_A2: FB_EtherCAT_Emerson;
	bVFD_A2DataValid AT %I*: BOOL;				(* Must Asign to VFD WcStateIn in System Manager*)
	fbVFD_A3: FB_EtherCAT_Emerson;
	bVFD_A3DataValid AT %I*: BOOL;				(* Must Asign to VFD WcStateIn in System Manager*)
	fbVFD_B1: FB_EtherCAT_Emerson;
	bVFD_B1DataValid AT %I*: BOOL;				(* Must Asign to VFD WcStateIn in System Manager*)
	fbVFD_B2: FB_EtherCAT_Emerson;
	bVFD_B2DataValid AT %I*: BOOL;				(* Must Asign to VFD WcStateIn in System Manager*)
	fbVFD_B3: FB_EtherCAT_Emerson;
	bVFD_B3DataValid AT %I*: BOOL;				(* Must Asign to VFD WcStateIn in System Manager*)
	bVFD_ARun: BOOL := FALSE;
	bVFD_BRun: BOOL := FALSE;
	bVFDControlDirection: BOOL := FALSE;
	fVFDControlRatio: LREAL := 1.0;
	bVFD_A1UpToSpeed: BOOL := FALSE;
	bVFD_A1Error: BOOL := FALSE;
	nVFD_A1ErrorID: UDINT := 0;
	stVFD_A1DriveInfo: Ke_VFDInfo;
	bVFD_A2UpToSpeed: BOOL := FALSE;
	bVFD_A2Error: BOOL := FALSE;
	nVFD_A2ErrorID: UDINT := 0;
	stVFD_A2DriveInfo: Ke_VFDInfo;
	bVFD_A3UpToSpeed: BOOL := FALSE;
	bVFD_A3Error: BOOL := FALSE;
	nVFD_A3ErrorID: UDINT := 0;
	stVFD_A3DriveInfo: Ke_VFDInfo;
	bVFD_B1UpToSpeed: BOOL := FALSE;
	bVFD_B1Error: BOOL := FALSE;
	nVFD_B1ErrorID: UDINT := 0;
	stVFD_B1DriveInfo: Ke_VFDInfo;
	bVFD_B2UpToSpeed: BOOL := FALSE;
	bVFD_B2Error: BOOL := FALSE;
	nVFD_B2ErrorID: UDINT := 0;
	stVFD_B2DriveInfo: Ke_VFDInfo;
	bVFD_B3UpToSpeed: BOOL := FALSE;
	bVFD_B3Error: BOOL := FALSE;
	nVFD_B3ErrorID: UDINT := 0;
	stVFD_B3DriveInfo: Ke_VFDInfo;
	nVFD_A1Addr AT %I*: UINT := 0;						(*Spindle#A1 VFD Slave Addres Input Variable*)
	nVFD_A2Addr AT %I*: UINT := 0;						(*Spindle#A1 VFD Slave Addres Input Variable*)
	nVFD_A3Addr AT %I*: UINT := 0;						(*Spindle#A1 VFD Slave Addres Input Variable*)
	nVFD_B1Addr AT %I*: UINT := 0;						(*Spindle#A1 VFD Slave Addres Input Variable*)
	nVFD_B2Addr AT %I*: UINT := 0;						(*Spindle#A1 VFD Slave Addres Input Variable*)
	nVFD_B3Addr AT %I*: UINT := 0;						(*Spindle#A1 VFD Slave Addres Input Variable*)


(* Solenoid Auto Control Variables *)
	bAutoLower: BOOL := FALSE;						(* Auto Lower Transfer Carrier Cylinder*)
	bAutoRaise: BOOL := FALSE;						(* Auto Raise Transfer Carrier Cylinder*)
	bAAutoOpenCollet: BOOL := FALSE;					(* Auto Control to Open the Collets on Side A*)
	bAAutoCloseCollet: BOOL := FALSE;					(* Auto Control to Close the Collets on Side A*)
	bBAutoOpenCollet: BOOL := FALSE;					(* Auto Control to Open the Collets on Side B*)
	bBAutoCloseCollet: BOOL := FALSE;					(* Auto Control to Close the Collets on Side B*)
	bAAutoEjectorsAdvance: BOOL := FALSE;				(* Auto Control to Advance the Ejectors on Side A *)
	bAAutoEjectorsRetract: BOOL := FALSE;				(* Auto Control to Retract the Ejectors on Side A *)
	bBAutoEjectorsAdvance: BOOL := FALSE;				(* Auto Control to Advance the Ejectors on Side A *)
	bBAutoEjectorsRetract: BOOL := FALSE;				(* Auto Control to Retract the Ejectors on Side A *)

	bWandUAxisHomed: BOOL := FALSE;				(* The W and U Axis are Homed*)

	nAEjectorAdvancedState: USINT := 0;
	nAEjectorRetractedState: USINT := 0;
	nBEjectorAdvancedState: USINT := 0;
	nBEjectorRetractedState: USINT := 0;

(* Tailstock Variables *)
	Side_A_Fixture: FB_FixtureControl;					(*Side A Tailstock Control FB*)
	Side_B_Fixture: FB_FixtureControl;					(*Side B Tailstock Control FB*)
	fWAxisFastVelocity: LREAL := 0.0;					(*WA and WB Axis Velocity to Feed to Tailstock FB*)
	fWAxisClampVelocity: LREAL := 0.0;					(*WA and WB Axis Clamp Velocity to Feed to Tailstock FB*)

END_VAR

VAR_GLOBAL PERSISTENT

	sSerialNumber : STRING(20) := 'DH-2062';				(* This holds the serial number of the machine *)
	sKaysJobNumber  : STRING(20) := '6216';				(* This holds the Kayse Engineering Job number of the machine *)
	sModelNumber : STRING(20) := '6-Spindle Special';		(* This variable holds the model of the machine *)
	sCustomerName : STRING(20) := 'ARBOMEX';			(* This variable holds the customers name *)
	nMachineNumber : UDINT := 7;						(* The Machine Number designates what number the machines were delivered in for this series of special machines *)
	sProductionDate : STRING(10) := '01/2016';			(* This variable holds the date of production and should match that of the machine tags *)

	sLoadSideSet : STRING(30) :='None';					(* Holds the side that is currently set as Infeed *)
	bSideAEnabled : BOOL := TRUE;					(* Enable of Machine Side A *)
	bSideBEnabled : BOOL := TRUE;					(* Enable of Machine Side B *)
	fFlowMonitorMax : LREAL := 0;						(* Max set in program *)

	nMaxCycles : UDINT := 0;							(* Max Cycles set in program *)
	nCyclesComplete : UDINT := 0;						(* Completed # of Cycles since Reset *)

	sLastLoadedPartProgramName : STRING(25) := 'None';	(* Stores the Name of the Last Part Program Loaded *)
	nMotorNominalRPM : UDINT := 3460;

	(* Tailstock Variables *)
	nWAAxisThrustMax: UDINT := 40;					(* Tailstock WA Axis Max Thrust *)
	nWBAxisThrustMax: UDINT := 40;					(* Tailstock WB Axis Max Thrust *)
	fWAAxisHomeOffset : LREAL := 0.0;					(* A Tailstock WA Axis Offset Durring Homing *)
	fWBAxisHomeOffset : LREAL := 0.0;					(* B Tailstock WB Axis Offset Durring Homing *)
	fWAxisMoveOffBushing : LREAL := 0.0;				(* Amount to Back W Axis' off of Bushing After Drill *)
	nTailstockClampingTorqueLimit : INT := 15;			(* % Torque Limit for W Axis During Clamp for Drilling *)
	fTailstockVelocity : LREAL := 60.0;					(* Velocity of the W Axis for normal moves*)
	fTailstockClampVelocity : LREAL := 30.0;				(* Velocity of the W Axis for the move to Clamp position *)
	(* Transfer Position and Speeds - U Axis *)
	fUAxisLoadSidePosition: LREAL := 0.0;				(* Transfer Axis Servo Load Position *)
	fUAxisUnloadSidePosition: LREAL := 0.0;				(* Transfer Axis Servo Unload Position *)
	fUAxisVelocity: LREAL := 0.0;						(* Transfer Axis Servo Move Speed *)
	nUAxisThrustMax : UDINT :=100;						(* Max Thrust Set in secret screen *)

END_VAR
(* @OBJECT_END := 'Global_Variables' *)
(* @CONNECTIONS := Global_Variables
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Inputs' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL
(* Rack 1 Slot 1 -EL1809 *)
	bPB1AConfirm AT %I* : BOOL := FALSE;				(* A -Load/Unload Confirm *)
	bPB2ACycleStart AT %I* : BOOL := FALSE;			(* A -Cycle Start PB *)
	bPB3ACycleCommon AT %I* : BOOL := FALSE;		(* A -Cycle Common/Reset PB *)
	bPB4ADrillReturn AT %I* : BOOL := FALSE;			(* A -Drill Return PB *)
	bPB1BConfirm AT %I* : BOOL := FALSE;				(* B -Load/Unload Confirm *)
	bPB2BCycleStart AT %I* : BOOL := FALSE;			(* B -Cycle Start PB *)
	bPB3BCycleCommon AT %I* : BOOL := FALSE;		(* B -Cycle Common/Reset PB *)
	bPB4BDrillReturn AT %I* : BOOL := FALSE;			(* B -Drill Return PB *)
	bChipConveyorVFDFault AT %I* : BOOL := FALSE;		(*  Chip Conveyor VFD Fault feedback *)
	(*Spare*)
	bCleanTankLevel AT %I* : BOOL := FALSE;			(* FS1 *)
	bCoolantTankOverflow AT %I* : BOOL := FALSE;		(* FS2 *)
	bFilter1Dirty AT %I* : BOOL := FALSE;					(* DPS1 *)
	bFilter2Dirty AT %I* : BOOL := FALSE;					(* DPS2 *)
	bFilter3Dirty AT %I* : BOOL := FALSE;					(* DPS3 *)
	bFilter4Dirty AT %I* : BOOL := FALSE;					(* DPS4 *)

(* Rack 1 Slot 2 - EL1809 *)
	bACoolantPressure AT %I* : BOOL := FALSE;			(* PS1 *)
	bBCoolantPressure AT %I* : BOOL := FALSE;			(* PS2 *)
	bLubeLevel AT %I* : BOOL := FALSE;					(* FS3 *)
	bLubePressure AT %I* : BOOL := FALSE;				(* PS3 *)
	bHydraulicSystemLevel AT %I* : BOOL := FALSE;		(* FS4 *)
	bHydraulicSystemPressure AT %I* : BOOL := FALSE;	(* PS4 *)
	bHydraulicTemperature AT %I* : BOOL := FALSE;		(* TS1 *)
	(*Spare*)
	bPneumaticSystemPressure AT %I* : BOOL := FALSE;	(* PS5 *)
	(*Spare*)
	bMCC_SConfirm AT %I* : BOOL := FALSE;			 	(* Servo Master Control Relay Active	*)
	(*Spare*)
	(*Spare*)
	(*Spare*)
	(*Spare*)
	bMCR AT %I* : BOOL := FALSE; 						(* Master Control Relay Active	*)

(* Rack 1 Slot 3 - EL1809 *)
	(* All Spares *)

(* Rack 1 Slot 3 - EL3311 *)
	nCoolantTemp AT %I* : INT := 0;

(* Rack 1 Slot 7 - EL3152  *)
	nSpindleTachA1 AT %I* : INT := 0;
	nCoolantFlowA1 AT %I* : INT :=0;

(* Rack 1 Slot 8 - EL3152 *)
	nSpindleTachA2 AT %I* : INT := 0;
	nCoolantFlowA2 AT %I* : INT :=0;

(* Rack 1 Slot 9 - EL3152 *)
	nSpindleTachA3 AT %I* : INT := 0;
	nCoolantFlowA3 AT %I* : INT :=0;

(* Rack 1 Slot 11 - EL3152  *)
	nSpindleTachB1 AT %I* : INT := 0;
	nCoolantFlowB1 AT %I* : INT :=0;

(* Rack 1 Slot 12 - EL3152 *)
	nSpindleTachB2 AT %I* : INT := 0;
	nCoolantFlowB2 AT %I* : INT :=0;

(* Rack 1 Slot 13 - EL3152 *)
	nSpindleTachB3 AT %I* : INT := 0;
	nCoolantFlowB3 AT %I* : INT :=0;

(* Rack 1 Slot 15 - EL1008 *)
	bZAAxisSelected AT %I* : BOOL := FALSE;		(* MPG Side A Z Selected *)
	bARate1X AT %I* : BOOL := FALSE;
	bARate10X AT %I* : BOOL := FALSE;
	bARate100X AT %I* : BOOL := FALSE;
	bWAAxisSelected AT %I* : BOOL := FALSE;
	bXAAxisSelected AT %I* : BOOL := FALSE;
	bYAAxisSelected AT %I* : BOOL := FALSE;
	(*SPARE*)

(* Rack 2 Slot 3 - EL1008 *)
	bZBAxisSelected AT %I* : BOOL := FALSE;		(* MPG Side A Z Selected *)
	bBRate1X AT %I* : BOOL := FALSE;
	bBRate10X AT %I* : BOOL := FALSE;
	bBRate100X AT %I* : BOOL := FALSE;
	bWBAxisSelected AT %I* : BOOL := FALSE;
	bXBAxisSelected AT %I* : BOOL := FALSE;
	bYBAxisSelected AT %I* : BOOL := FALSE;
	(*SPARE*)

(* Rack 2 Slot 4 - EL1008 *)
	bHighPressureMotorRunning AT %I* : BOOL := FALSE;
	bTransferPumpMotorRunning AT %I* : BOOL := FALSE;
	bChipConveyorMotorRunning AT %I* : BOOL := FALSE;
	bHydraulicPowerUnitRunning AT %I* : BOOL := FALSE;
	bMCC_V AT %I* : BOOL := FALSE;					(* Spindle Drives Power Enabled Feedback *)
	(*SPARE*)
	(*SPARE*)
	(*SPARE*)

(* Rack 2 Slot 5 - EL1008 *)
	(* All Spares *)

(* Rack 3 - EP1008 *)
	bProx310 AT %I* : BOOL := FALSE;			(* A Side - Sliding Door Closed *)
	bProx311 AT %I* : BOOL := FALSE;			(* B Side - Sliding Door Closed *)
	bProx312 AT %I* : BOOL := FALSE;			(* A Side - Fixture Door Closed *)
	bProx313 AT %I* : BOOL := FALSE;			(* B Side - Fixture Door Closed *)
	(*SPARE*)
	(*SPARE*)
	(*SPARE*)
	(*SPARE*)
	bRack3Comm AT %I* : BOOL := FALSE;		(* Ethercat Comm Status to Rack 3 *)

(* Rack 4 - EP1008 *)
	(* A Side Conveyor PROX Indicators *)
	bProx410 AT %I* : BOOL := FALSE;			(* A -Spindle 1 *)
	bProx411 AT %I* : BOOL := FALSE;			(* A -Spindle 2 *)
	bProx412 AT %I* : BOOL := FALSE;			(* A -Spindle 3 *)
	bProx413 AT %I* : BOOL := FALSE;			(* B -Spindle 1 *)
	bProx414 AT %I* : BOOL := FALSE;			(* B -Spindle 2 *)
	bProx415 AT %I* : BOOL := FALSE;			(* B -Spindle 3 *)
	(*SPARE*)
	(*SPARE*)
	bRack4Comm AT %I* : BOOL := FALSE;		(* Ethercat Comm Status to Rack 4 *)

(* Rack 5 - EP1008 *)
	(* B Side Conveyor PROX Indicators *)
	bProx510 AT %I* : BOOL := FALSE;			(* A -Spindle 1 *)
	bProx511 AT %I* : BOOL := FALSE;			(* A -Spindle 2 *)
	bProx512 AT %I* : BOOL := FALSE;			(* A -Spindle 3 *)
	bProx513 AT %I* : BOOL := FALSE;			(* B -Spindle 1 *)
	bProx514 AT %I* : BOOL := FALSE;			(* B -Spindle 2 *)
	bProx515 AT %I* : BOOL := FALSE;			(* B -Spindle 3 *)
	bProx516 AT %I* : BOOL := FALSE;			(* Carrier Up *)
	bProx517 AT %I* : BOOL := FALSE;			(* Carrier Down *)
	bRack5Comm AT %I* : BOOL := FALSE;		(* Ethercat Comm Status to Rack 5 *)

(* Rack 6 - EP1008 *)
	(* A Side Ejector PROX Indicators *)
	bProx610 AT %I* : BOOL := FALSE;			(* A Part Ejector #1 Retracted *)
	bProx611 AT %I* : BOOL := FALSE;			(* A Part Ejector #2 Retracted *)
	bProx612 AT %I* : BOOL := FALSE;			(* A Part Ejector #3 Retracted *)
	bProx613 AT %I* : BOOL := FALSE;			(* A Part Ejector #1 Advanced *)
	bProx614 AT %I* : BOOL := FALSE;			(* A Part Ejector #2 Advanced *)
	bProx615 AT %I* : BOOL := FALSE;			(* A Part Ejector #3 Advanced *)
	bPS616 AT %I* : BOOL := FALSE;			(* A Collets Unclamp Pressure Switch *)
	bPS617 AT %I* : BOOL := FALSE;			(* A Collets Clamp Pressure Switch *)
	bRack6Comm AT %I* : BOOL := FALSE;		(* Ethercat Comm Status to Rack 6 *)

(* Rack 7 - EP1008 *)
	(* B Side Ejector PROX Indicators *)
	bProx720 AT %I* : BOOL := FALSE;			(* B Part Ejector #1 Retracted *)
	bProx721 AT %I* : BOOL := FALSE;			(* B Part Ejector #2 Retracted *)
	bProx722 AT %I* : BOOL := FALSE;			(* B Part Ejector #3 Retracted *)
	bProx723 AT %I* : BOOL := FALSE;			(* B Part Ejector #1 Advanced *)
	bProx724 AT %I* : BOOL := FALSE;			(* B Part Ejector #2 Advanced *)
	bProx725 AT %I* : BOOL := FALSE;			(* B Part Ejector #3 Advanced *)
	bPS726 AT %I* : BOOL := FALSE;			(* B Collets Unclamp Pressure Switch *)
	bPS727 AT %I* : BOOL := FALSE;			(* B Collets Clamp Pressure Switch *)
	bRack7Comm AT %I* : BOOL := FALSE;		(* Ethercat Comm Status to Rack 7 *)

END_VAR

(* @OBJECT_END := 'Inputs' *)
(* @CONNECTIONS := Inputs
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Network_Variables' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL
(* Subscribe to Panel A *)
	stReceivePanelA AT %I* : ST_PANEL_SEND;		(* Structure of Push Buttonas and Inputs from Panel A *)
	nReceivePanelAQuality AT %I* : UINT :=0;			(* Good Quality is 0 when receiving data from Panel A *)
	nReceivePanelACycleIndex AT %I* : UINT :=0;		(* Cycle Index Continures to change while receiving data from Panel A *)
	(* Requests by Panel A for the CX to place network variables on the network *)
	nRequestPA AT %I* : WORD := 0;

(* Subscribe to Panel B *)
	stReceivePanelB AT %I* : ST_PANEL_SEND;		(* Structure of Push Buttonas and Inputs from Panel B *)
	nReceivePanelBQuality AT %I* : UINT :=0;			(* Good Quality is 0 when receiving data from Panel B *)
	nReceivePanelBCycleIndex AT %I* : UINT :=0;		(* Cycle Index Continures to change while receiving data from Panel B *)
	(* Requests by Panel A for the CX to place network variables on the network *)
	nRequestPB AT %I* : WORD := 0;

(* Publish Variables *)
	(* Structure for the CX Publish Variable 1 *)
	stCXPublish1 AT %Q* : ST_CX_Publish1;
	(* Array of String Variables for Machine Information -  Only required at power up of CP2612's *)
	arrMachineInfo AT %Q* : ARRAY[1..20] OF STRING(30) := 20('');
	(* Structure to display of the Part Program - only sent when on the Part Program screen *)
	stPartProgramSend AT %Q* : ST_PARTPROGRAM;
	(* Structure of the VFD Information *)

(* Variable Controol  - A value of 1 disables publishing, 0 enables *)
	nPubFrameState AT %I* : UINT :=0;				(* Frame State of the Published Network Variable - 1=not sent, 2=oversized Error *)
	nVarCtrlMachineInfo AT %Q* : UINT := 1;			(*Variable Control for the Text Array for Main Screen*)
	nVarCtrlAutoDisplays AT %Q* : UINT :=1;			(* Variable Control for the Auto Display Net Variables *)
	nVarCtrlFaultMessages AT %Q* : UINT := 1;		(* Variable Control for the Fault Messages Net Variables *)
	nVarCtrlPanelReceive AT %Q* : UINT := 0;			(* Variable Control for Panel Information - Always 0 *)
	nVarCtrlPartProgramSend AT %Q* : UINT :=0;		(* Variable Control for Part Program Send *)
	nVarCtrlDemo AT %Q* : UINT := 1;				(* Variable Control for the Demo Net Variables *)

(*Demo Variables*)
	stPB AT %I* : ST_Demo_PBs;					(* Define a structure of the push buttons to be recieved from the panel A *)
	stPBB AT %I* : ST_Demo_PBs;					(* Define a structure of the push buttons to be recieved from the panel B*)
	stLT AT %Q* : ST_Demo_Indicators;				(* Define a structure of the Lights to be sent to the panel *)

END_VAR

(* @OBJECT_END := 'Network_Variables' *)
(* @CONNECTIONS := Network_Variables
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Outputs' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL

(* Rack 1 Slot 5 EL2809 *)
	bAServoEnable AT %Q* : BOOL := FALSE;			(* A side Servo Hard Enable Relay *)
	bBServoEnable AT %Q* : BOOL := FALSE;			(* B side Servo Hard Enable Relay *)
	bUServoEnable AT %Q* : BOOL := FALSE;			(* Transfer Servo Hard Enable Relay *)
	bMCC_S AT %Q* : BOOL := FALSE;					(* Servo Power Delayed Contactor *)
	bWayLubePump AT %Q* : BOOL := FALSE;			(* Way Lube Pump Power *)
	bACoolantSolenoid AT %Q* : BOOL := FALSE;			(* A Side Coolant Solenoid On SOL1 *)
	bBCoolantSolenoid AT %Q* : BOOL := FALSE;			(* B Side Coolant Solenoid On SOL2 *)
	bConveyorFWDReq AT %Q* : BOOL := FALSE;		(* Chip Conveyor Forward Request *)
	bHPCoolantStart_A AT %Q* : BOOL := FALSE;			(* A Side High Pressure Coolant Soft Start SOL 4 *)
	bHPCoolantStart_B AT %Q* : BOOL := FALSE;			(* B Side High Pressure Coolant Soft Start SOL 5 *)
	bTransferDown AT %Q* : BOOL := FALSE;				(* Lower Transfer Solenoid *)
	bTransferUp AT %Q* : BOOL := FALSE;				(* Raise Transfer Solenoid *)
	bATailstockColletUnclamp AT %Q* : BOOL := FALSE;	(* Unclamp Collet Solenoid Side A *)
	bATailstockColletClamp AT %Q* : BOOL := FALSE;		(* Clamp Collet Solenoid Side A *)
	bBTailstockColletUnclamp AT %Q* : BOOL := FALSE;	(* Unclamp Collet Solenoid Side B *)
	bBTailstockColletClamp AT %Q* : BOOL := FALSE;		(* Clamp Collet Solenoid Side B *)

(* Rack 1 Slot 6 EL2809 *)
	bAEjectorsRetract AT %Q* : BOOL := FALSE;			(* Side A Ejectors/Pushers Retract *)
	bAEjectorsAdvance AT %Q* : BOOL := FALSE;			(* Side A Ejectors/Pushers Advance *)
	bBEjectorsRetract AT %Q* : BOOL := FALSE;			(* Side B Ejectors/Pushers Retract *)
	bBEjectorsAdvance AT %Q* : BOOL := FALSE;			(* Side B Ejectors/Pushers Advance *)
	(* SPARE*)
	(* SPARE*)
	(* SPARE*)
	(* SPARE*)
	bChipConveyorFWD AT %Q* : BOOL := FALSE;
	(* SPARE*)
	bLT2 AT %Q* : BOOL := FALSE;						(* Light Tower - Fault *)
	bLT3 AT %Q* : BOOL := FALSE;						(* Light Tower - Idle *)
	bLT4 AT %Q* : BOOL := FALSE;						(* Light Tower -  In Cycle *)
	bLT5 AT %Q* : BOOL := FALSE;						(* Fault Light - Side A *)
	(* SPARE*)
	(* SPARE*)

(* Rack 2 Slot 6 EL2008 *)
	bLT6 AT %Q* : BOOL := FALSE;					(* Fault Light - Side B *)
	bHighPressureMotorOn AT %Q* : BOOL := FALSE;
	bTransferPumpOn AT %Q* : BOOL := FALSE;
	bHydraulicUnitOn AT %Q* : BOOL := FALSE;
	bChipConveyorOn AT %Q* : BOOL := FALSE;
	(* SPARE*)
	(* SPARE*)
	(* SPARE*)

(* Rack 2 Slot 7 EL2008 *)
	bVFD_A_Enable AT %Q* : BOOL := FALSE;
	bVFD_B_Enable AT %Q* : BOOL := FALSE;
	(* SPARE*)
	(* SPARE*)
	(* SPARE*)
	(* SPARE*)
	(* SPARE*)
	(* SPARE*)

END_VAR

(* @OBJECT_END := 'Outputs' *)
(* @CONNECTIONS := Outputs
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'SCREEN_DISPLAYS' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL
(* MASTER Layout *)
	nEtherCATMasterState: INT := 0;
	sScreenTitle : STRING(45) := '';
	sCurrentCXProgram : STRING(25) := 'None';		(* Current Program in the CX Processor *)
	bDispPressCycleStart: BOOL := FALSE;			(* Trigger when Cycle Start is necessary to resume operation *)

(* MANUAL Screen *)
	(* Push Buttons *)
	bStartHydraulicPB : BOOL := FALSE;				(* Start the Hydraulic Unit *)
	bStopHydraulicPB : BOOL := FALSE;				(* Start the Hydraulic Unit *)
	bCoolantStartPB : BOOL := FALSE;				(* Start the Coolant System *)
	bCoolantStopPB : BOOL := FALSE;				(* Stop the Coolant System *)
	bEnterSetupPB_A : BOOL := FALSE;				(* Side A Enter Setup Mode *)
	bEnterSetupPB_B : BOOL := FALSE;				(* Side B Enter Setup Mode *)
	bSetZeroPositionPB_A : BOOL := FALSE;			(* Set ZA Azis Position to Zero *)
	bSetZeroPositionPB_B : BOOL := FALSE;			(* Set ZB Azis Position to Zero *)
	bMoveToZeroPositionPB_A : BOOL := FALSE;		(* Move ZA Axis to Zero Positon *)
	bMoveToZeroPositionPB_B : BOOL := FALSE;		(* Move ZB Axis to Zero Positon *)
	bHomeAutomationPB : BOOL := FALSE;			(* Home WA, WB, and X Axis *)

(* AUTO Screen *)
	(* SPINDLE VARIABLES *)
	nSpindleRPM1A: UDINT := 0;
	nSpindleRPM2A: UDINT := 0;
	nSpindleRPM3A: UDINT := 0;
	nSpindleRPM1B: UDINT := 0;
	nSpindleRPM2B: UDINT := 0;
	nSpindleRPM3B: UDINT := 0;
	nSpindleLoad1ADisplay : UDINT := 0;
	nSpindleLoad2ADisplay : UDINT := 0;
	nSpindleLoad3ADisplay : UDINT := 0;
	nSpindleLoad1BDisplay : UDINT := 0;
	nSpindleLoad2BDisplay : UDINT := 0;
	nSpindleLoad3BDisplay : UDINT := 0;
	nSpindleLoadMax : UDINT := 100;
	(* Coolant *)
	fCoolantFlow1ADisplay : LREAL := 0;
	fCoolantFlow1AGraph: LREAL := 0;
	fCoolantFlow2ADisplay : LREAL := 0;
	fCoolantFlow2AGraph: LREAL := 0;
	fCoolantFlow3ADisplay : LREAL := 0;
	fCoolantFlow3AGraph: LREAL := 0;
	fCoolantFlow1BDisplay : LREAL := 0;
	fCoolantFlow1BGraph: LREAL := 0;
	fCoolantFlow2BDisplay : LREAL := 0;
	fCoolantFlow2BGraph: LREAL := 0;
	fCoolantFlow3BDisplay : LREAL := 0;
	fCoolantFlow3BGraph: LREAL := 0;
	fCoolantTempDisplay: LREAL := 0.0;
	fCoolantFlowMinGraph: LREAL := 0.0;
	fCoolantFlowMaxGraph: LREAL := 0.0;

	(* Servo Variables *)
	fZAAxisVelosity : LREAL := 0.0;						(* ZA Axis Velocity/Feedrate *)
	fZBAxisVelosity : LREAL := 0.0;						(* ZB Axis Velocity/Feedrate *)
	nServoAThrustDisplay : UDINT := 0;
	nServoBThrustDisplay : UDINT := 0;
	nServoThrustMax : UDINT := 100;

	(* Cycle Variables *)
	nPartsCompleteTotal : UDINT := 0;
	nPartsCompleteA1 : UDINT := 0;
	nPartsCompleteA2 : UDINT := 0;
	nPartsCompleteA3 : UDINT := 0;
	nPartsCompleteB1 : UDINT := 0;
	nPartsCompleteB2 : UDINT := 0;
	nPartsCompleteB3 : UDINT := 0;

	bCellRunOutRequest : BOOL := FALSE;				(* Cell Runout has been requested *)
	bCellRunOutPB: BOOL := FALSE;

	(* Push Buttons *)
	bEnterManualModePB: BOOL := FALSE;
	bEnterAutoModePB: BOOL := FALSE;
	bResetCycleCounterPB: BOOL := FALSE;
	bFaultResetPB: BOOL := FALSE;
	bResetTotalCountPB: BOOL := FALSE;
	bResetA1CountPB: BOOL := FALSE;
	bResetA2CountPB: BOOL := FALSE;
	bResetA3CountPB: BOOL := FALSE;
	bResetB1CountPB: BOOL := FALSE;
	bResetB2CountPB: BOOL := FALSE;
	bResetB3CountPB: BOOL := FALSE;

	sCurrentPartProgram : STRING(25) := 'None';		(* Current Part Program Loaded*)

(* The Fault Messages is transfered and used as is *)
	arrFaultMessage : ARRAY[1..10] OF STRING (50) := 10('');

(* PART PROGRAM STORAGE VARIABLES *)
	sPartProgramName : STRING(25) := 'None';
	bPartProgramSavePB : BOOL := FALSE;
	bPartProgramLoadPB : BOOL := FALSE;

	fStartFeed : LREAL := 0.0;
	fFinishFeed : LREAL := 0.0;
	fStartDepth : LREAL := 0.0;
	fFinishDepth : LREAL := 0.0;
	fDwellTime : LREAL := 0.0;
	fRetractRate : LREAL := 0.0;
	fDrillTipOffset : LREAL := 0.0;
	fRPMRequest : LREAL := 0.0;
	fToolDiameter : LREAL := 0.0;
	fCoolantPressure : LREAL := 0.0;
	fCoolantFlowMax : LREAL := 0.0;
	fCoolantFlowMin : LREAL := 0.0;

	bSpindleRetractMode : BOOL := FALSE;
	bFaultHistoryFileError : BOOL := FALSE;

	sFileOpError : STRING(30) := '';

	bStartFeedChanged: BOOL := FALSE;			(*Indicates Start Feed changed since program was loaded*)
	bFinishFeedChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bStartDepthChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bFinishDepthChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bDwellTimeChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bRetractRateChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bDrillTipOffsetChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bRPMRequestChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bSpindleRetractChanged: BOOL := FALSE;		(*Indicates changed since program was loaded*)
	bToolDiameterChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)
	bSpindleLoadMaxChanged: BOOL := FALSE;		(*Indicates changed since program was loaded*)
	bServoThrustMaxChanged: BOOL := FALSE;		(*Indicates changed since program was loaded*)
	bCoolantFlowMaxChanged: BOOL := FALSE;		(*Indicates changed since program was loaded*)
	bCoolantFlowMinChanged: BOOL := FALSE;		(*Indicates changed since program was loaded*)
	bMaxCyclesChanged: BOOL := FALSE;			(*Indicates changed since program was loaded*)

(* TRANSFER Variables *)
	(* Displays *)
	bTransferUpPX : BOOL := FALSE;				(* Transfer Up Indicator *)
	bTransferDownPX : BOOL := FALSE;				(* Transfer Down Indicator *)
	bTransferUpSOL: BOOL :=FALSE;				(* Transfer Up Solenoid *)
	bTransferDownSOL : BOOL := FALSE;			(* Transfer Down Solenoid *)

	(* Operators*)
	bTransferUpPB : BOOL := FALSE;				(* Transfer Up Push Button *)
	bTransferDownPB : BOOL := FALSE;				(* Transfer Down Push Button *)
	bHomeUAxisPB : BOOL := FALSE;				(* Home U Axis Push Button *)
	bMoveUtoLoadPB : BOOL := FALSE;				(* Move U Axis to Load Position Push Button *)
	bMoveUtoUnloadPB : BOOL := FALSE;			(* Move U Axis to Unload Position Push Button *)
	bTransferAtLoadIndicator : BOOL := FALSE;		(* Indicator that Transfer At the Load Position *)
	bTransferAtUnloadIndicator : BOOL := FALSE;		(* Indicator that Transfer At the Unload Position *)

(* FIXTURE/TAILSTOCK Variables *)
	fWAxisTransferPosition : LREAL := 0.0;			(* Tailstock W Axis Position During Transfer *)
	fWAxisDrillPosition : LREAL := 0.0;				(* Tailstock W Axis Position During Drill *)

	(* A Side *)
	bAEjectorOvertravelError : BOOL := FALSE;		(* One of the Ejectors has overtraveled *)
	(* Push Buttons - Operators *)
	bWAAxisHomePB : BOOL := FALSE;				(* Tailstock WA Axis Home *)
	bWAAxisAdvancePB : BOOL := FALSE;			(* Tailstock WA Axis Advance Postion *)
	bWAAxisRetractPB : BOOL := FALSE;				(* Tailstock WA Axis Retract Postion *)
	bAColletClosePB : BOOL := FALSE;				(* Tailstock A Close Collets *)
	bAColletOpenPB : BOOL := FALSE;				(* Tailstock A Open Collets *)
	bAEjectorsAdvancePB : BOOL := FALSE;			(* Tailstock A Advance Ejectors *)
	bAEjectorsRetractPB : BOOL := FALSE;			(* Tailstock A Retract Ejectors *)

	(* B Side *)
	bBEjectorOvertravelError : BOOL := FALSE;		(* One of the Ejectors has overtraveled *)
	(* Push Buttons - Operators *)
	bWBAxisHomePB : BOOL := FALSE;				(* Tailstock WB Axis Home *)
	bWBAxisAdvancePB : BOOL := FALSE;			(* Tailstock WB Axis Advance Postion *)
	bWBAxisRetractPB : BOOL := FALSE;				(* Tailstock WB Axis Retract Postion *)
	bBColletClosePB : BOOL := FALSE;				(* Tailstock B Close Collets *)
	bBColletOpenPB : BOOL := FALSE;				(* Tailstock B Open Collets *)
	bBEjectorsAdvancePB : BOOL := FALSE;			(* Tailstock B Advance Ejectors *)
	bBEjectorsRetractPB : BOOL := FALSE;			(* Tailstock B Retract Ejectors *)

(* Screen Control *)
	bTriggerInitializeVisu: BOOL := FALSE;			(*If the Panel ID is not set then we need to go to the Initialization Screen and set it*)
	fbInitializeVisuRTRIG : R_TRIG;
	(* Screen Title Control *)
	bDisplayUnloadConf: BOOL := FALSE;				(*Display Confirm Unload*)

(* SECRET Screen*)
	bLoginPB : BOOL := FALSE;
	bLogoutPB : BOOL := FALSE;
	bASideIsLoadPB : BOOL:=FALSE;				(* Set A Side as Infeed Side Push Button *)
	bBSideIsLoadPB : BOOL:=FALSE;				(* Set B Side as Infeed Side Push Button *)

(* Test Speed Varialbes *)
	bTestSpeedOn : BOOL := FALSE;				(* Test Speed is Active *)
	nTestSpeedOverRide : UDINT := 100;			(* Current Test Speed Over-ride Value - from CX*)

END_VAR

(* @OBJECT_END := 'SCREEN_DISPLAYS' *)
(* @CONNECTIONS := SCREEN_DISPLAYS
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'TwinCAT_Configuration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
(* Generated automatically by TwinCAT - (read only) *)
VAR_CONFIG
	.DriveZAWAdinputs AT %IB0 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^Axis ZA/WA (AX5206-0000-0011)^AT 2^Digital inputs, state} *)
	.stZAAxis.PlcToNc AT %QB2277 : PLCTONC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^ZA Axis^Inputs^ZA Axis_FromPlc} *)
	.stZAAxis.NcToPlc AT %IB1434 : NCTOPLC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^ZA Axis^Outputs^ZA Axis_ToPlc} *)
	.nZAAxisDiagNumber AT %IB2 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^Axis ZA/WA (AX5206-0000-0011)^AT 1^Diagnostic number} *)
	.nServoZAThrust AT %IB6 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^Axis ZA/WA (AX5206-0000-0011)^AT 1^Torque feedback value} *)
	.stWAAxis.PlcToNc AT %QB2405 : PLCTONC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^WA Axis^Inputs^WA Axis_FromPlc} *)
	.stWAAxis.NcToPlc AT %IB1562 : NCTOPLC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^WA Axis^Outputs^WA Axis_ToPlc} *)
	.nWAAxisDiagNumber AT %IB8 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^Axis ZA/WA (AX5206-0000-0011)^AT 2^Diagnostic number} *)
	.nWAAxisThrust AT %IB12 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^Axis ZA/WA (AX5206-0000-0011)^AT 2^Torque feedback value} *)
	.nWATorqeLimitValue AT %QB0 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^Axis ZA/WA (AX5206-0000-0011)^MDT 2^Bipolar torque limit value} *)
	.DriveZBWBdinputs AT %IB14 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^ Axis ZB/WB (AX5206-0000-0011)^AT 2^Digital inputs, state} *)
	.stZBAxis.PlcToNc AT %QB2533 : PLCTONC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^ZB Axis^Inputs^ZB Axis_FromPlc} *)
	.stZBAxis.NcToPlc AT %IB1690 : NCTOPLC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^ZB Axis^Outputs^ZB Axis_ToPlc} *)
	.nZBAxisDiagNumber AT %IB16 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^ Axis ZB/WB (AX5206-0000-0011)^AT 1^Diagnostic number} *)
	.nServoZBThrust AT %IB20 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^ Axis ZB/WB (AX5206-0000-0011)^AT 1^Torque feedback value} *)
	.stWBAxis.PlcToNc AT %QB2661 : PLCTONC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^WB Axis^Inputs^WB Axis_FromPlc} *)
	.stWBAxis.NcToPlc AT %IB1818 : NCTOPLC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^WB Axis^Outputs^WB Axis_ToPlc} *)
	.nWBAxisDiagNumber AT %IB22 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^ Axis ZB/WB (AX5206-0000-0011)^AT 2^Diagnostic number} *)
	.nWBAxisThrust AT %IB26 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^ Axis ZB/WB (AX5206-0000-0011)^AT 2^Torque feedback value} *)
	.nWBTorqeLimitValue AT %QB2 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 16 (EK1122)^ Axis ZB/WB (AX5206-0000-0011)^MDT 2^Bipolar torque limit value} *)
	.DriveUdinputs AT %IB28 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Axis U (AX5106-0000-0011)^AT^Digital inputs, state} *)
	.stUAxis.PlcToNc AT %QB2789 : PLCTONC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^U Axis^Inputs^U Axis_FromPlc} *)
	.stUAxis.NcToPlc AT %IB1946 : NCTOPLC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^U Axis^Outputs^U Axis_ToPlc} *)
	.nUAxisDiagNumber AT %IB30 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Axis U (AX5106-0000-0011)^AT^Diagnostic number} *)
	.nUAxisThrust AT %IB34 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Axis U (AX5106-0000-0011)^AT^Torque feedback value} *)
	.stAxisMPG_A.PlcToNc AT %QB2917 : PLCTONC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^MPGA Axis^Inputs^MPGA Axis_FromPlc} *)
	.stAxisMPG_A.NcToPlc AT %IB2074 : NCTOPLC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^MPGA Axis^Outputs^MPGA Axis_ToPlc} *)
	.stAxisMPG_B.PlcToNc AT %QB3045 : PLCTONC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^MPGB Axis^Inputs^MPGB Axis_FromPlc} *)
	.stAxisMPG_B.NcToPlc AT %IB2202 : NCTOPLC_AXIS_REF;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Axes^MPGB Axis^Outputs^MPGB Axis_ToPlc} *)
	.fbVFD_A1.nMotorSpeed AT %IB2330 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Speed} *)
	.fbVFD_A1.nMotorVoltage AT %IB2332 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Voltage} *)
	.fbVFD_A1.nMotorCurrent AT %IB2334 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Current} *)
	.fbVFD_A1.nMotorTorque AT %IB2338 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Torque} *)
	.fbVFD_A1.nMotorPower AT %IB2340 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Power} *)
	.fbVFD_A1.nDriveStatus AT %IB2342 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 2^Drive Status} *)
	.fbVFD_A1.nDCLinkVoltage AT %IB2344 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 2^DC Link Voltage} *)
	.fbVFD_A1.nOpDayCounter1 AT %IB2346 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #1} *)
	.fbVFD_A1.nOpDayCounter2 AT %IB2348 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #2} *)
	.fbVFD_A1.nEnergyCounter AT %IB2350 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Transmit PDO mapping 2^Energy Counter kWh} *)
	.fbVFD_A1.bRunStop AT %QX3173.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Receive PDO mapping 22^Run/Stop^Run/Stop[0]} *)
	.fbVFD_A1.bDirection AT %QX3173.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Receive PDO mapping 22^Direction^Direction[0]} *)
	.fbVFD_A1.nSpeed AT %QB3174 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Receive PDO mapping 22^Speed Request} *)
	.fbVFD_A1.bDriveReset AT %QX3176.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^Receive PDO mapping 22^Drive Reset^Drive Reset[0]} *)
	.bVFD_A1DataValid AT %IX1422.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^WcState^WcStateOut} *)
	.fbVFD_A2.nMotorSpeed AT %IB2352 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Speed} *)
	.fbVFD_A2.nMotorVoltage AT %IB2354 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Voltage} *)
	.fbVFD_A2.nMotorCurrent AT %IB2356 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Current} *)
	.fbVFD_A2.nMotorTorque AT %IB2360 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Torque} *)
	.fbVFD_A2.nMotorPower AT %IB2362 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Power} *)
	.fbVFD_A2.nDriveStatus AT %IB2364 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 2^Drive Status} *)
	.fbVFD_A2.nDCLinkVoltage AT %IB2366 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 2^DC Link Voltage} *)
	.fbVFD_A2.nOpDayCounter1 AT %IB2368 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #1} *)
	.fbVFD_A2.nOpDayCounter2 AT %IB2370 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #2} *)
	.fbVFD_A2.nEnergyCounter AT %IB2372 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Transmit PDO mapping 2^Energy Counter kWh} *)
	.fbVFD_A2.bRunStop AT %QX3176.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Receive PDO mapping 22^Run/Stop^Run/Stop[0]} *)
	.fbVFD_A2.bDirection AT %QX3176.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Receive PDO mapping 22^Direction^Direction[0]} *)
	.fbVFD_A2.nSpeed AT %QB3177 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Receive PDO mapping 22^Speed Request} *)
	.fbVFD_A2.bDriveReset AT %QX3179.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^Receive PDO mapping 22^Drive Reset^Drive Reset[0]} *)
	.bVFD_A2DataValid AT %IX1422.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^WcState^WcStateOut} *)
	.fbVFD_A3.nMotorSpeed AT %IB2374 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Speed} *)
	.fbVFD_A3.nMotorVoltage AT %IB2376 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Voltage} *)
	.fbVFD_A3.nMotorCurrent AT %IB2378 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Current} *)
	.fbVFD_A3.nMotorTorque AT %IB2382 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Torque} *)
	.fbVFD_A3.nMotorPower AT %IB2384 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Power} *)
	.fbVFD_A3.nDriveStatus AT %IB2386 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 2^Drive Status} *)
	.fbVFD_A3.nDCLinkVoltage AT %IB2388 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 2^DC Link Voltage} *)
	.fbVFD_A3.nOpDayCounter1 AT %IB2390 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #1} *)
	.fbVFD_A3.nOpDayCounter2 AT %IB2392 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #2} *)
	.fbVFD_A3.nEnergyCounter AT %IB2394 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Transmit PDO mapping 2^Energy Counter kWh} *)
	.fbVFD_A3.bRunStop AT %QX3179.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Receive PDO mapping 22^Run/Stop^Run/Stop[0]} *)
	.fbVFD_A3.bDirection AT %QX3179.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Receive PDO mapping 22^Direction^Direction[0]} *)
	.fbVFD_A3.nSpeed AT %QB3180 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Receive PDO mapping 22^Speed Request} *)
	.fbVFD_A3.bDriveReset AT %QX3182.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^Receive PDO mapping 22^Drive Reset^Drive Reset[0]} *)
	.bVFD_A3DataValid AT %IX1422.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^WcState^WcStateOut} *)
	.fbVFD_B1.nMotorSpeed AT %IB2396 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Speed} *)
	.fbVFD_B1.nMotorVoltage AT %IB2398 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Voltage} *)
	.fbVFD_B1.nMotorCurrent AT %IB2400 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Current} *)
	.fbVFD_B1.nMotorTorque AT %IB2404 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Torque} *)
	.fbVFD_B1.nMotorPower AT %IB2406 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Power} *)
	.fbVFD_B1.nDriveStatus AT %IB2408 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 2^Drive Status} *)
	.fbVFD_B1.nDCLinkVoltage AT %IB2410 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 2^DC Link Voltage} *)
	.fbVFD_B1.nOpDayCounter1 AT %IB2412 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #1} *)
	.fbVFD_B1.nOpDayCounter2 AT %IB2414 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #2} *)
	.fbVFD_B1.nEnergyCounter AT %IB2416 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Transmit PDO mapping 2^Energy Counter kWh} *)
	.fbVFD_B1.bRunStop AT %QX3182.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Receive PDO mapping 22^Run/Stop^Run/Stop[0]} *)
	.fbVFD_B1.bDirection AT %QX3182.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Receive PDO mapping 22^Direction^Direction[0]} *)
	.fbVFD_B1.nSpeed AT %QB3183 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Receive PDO mapping 22^Speed Request} *)
	.fbVFD_B1.bDriveReset AT %QX3185.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^Receive PDO mapping 22^Drive Reset^Drive Reset[0]} *)
	.bVFD_B1DataValid AT %IX1422.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^WcState^WcStateOut} *)
	.fbVFD_B2.nMotorSpeed AT %IB2418 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Speed} *)
	.fbVFD_B2.nMotorVoltage AT %IB2420 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Voltage} *)
	.fbVFD_B2.nMotorCurrent AT %IB2422 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Current} *)
	.fbVFD_B2.nMotorTorque AT %IB2426 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Torque} *)
	.fbVFD_B2.nMotorPower AT %IB2428 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Power} *)
	.fbVFD_B2.nDriveStatus AT %IB2430 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 2^Drive Status} *)
	.fbVFD_B2.nDCLinkVoltage AT %IB2432 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 2^DC Link Voltage} *)
	.fbVFD_B2.nOpDayCounter1 AT %IB2434 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #1} *)
	.fbVFD_B2.nOpDayCounter2 AT %IB2436 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #2} *)
	.fbVFD_B2.nEnergyCounter AT %IB2438 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Transmit PDO mapping 2^Energy Counter kWh} *)
	.fbVFD_B2.bRunStop AT %QX3185.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Receive PDO mapping 22^Run/Stop^Run/Stop[0]} *)
	.fbVFD_B2.bDirection AT %QX3185.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Receive PDO mapping 22^Direction^Direction[0]} *)
	.fbVFD_B2.nSpeed AT %QB3186 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Receive PDO mapping 22^Speed Request} *)
	.fbVFD_B2.bDriveReset AT %QX3188.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^Receive PDO mapping 22^Drive Reset^Drive Reset[0]} *)
	.bVFD_B2DataValid AT %IX1422.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^WcState^WcStateOut} *)
	.fbVFD_B3.nMotorSpeed AT %IB2440 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Speed} *)
	.fbVFD_B3.nMotorVoltage AT %IB2442 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Voltage} *)
	.fbVFD_B3.nMotorCurrent AT %IB2444 : UDINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Current} *)
	.fbVFD_B3.nMotorTorque AT %IB2448 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Torque} *)
	.fbVFD_B3.nMotorPower AT %IB2450 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 1^Motor Power} *)
	.fbVFD_B3.nDriveStatus AT %IB2452 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 2^Drive Status} *)
	.fbVFD_B3.nDCLinkVoltage AT %IB2454 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 2^DC Link Voltage} *)
	.fbVFD_B3.nOpDayCounter1 AT %IB2456 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #1} *)
	.fbVFD_B3.nOpDayCounter2 AT %IB2458 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 2^OP Day Counter #2} *)
	.fbVFD_B3.nEnergyCounter AT %IB2460 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Transmit PDO mapping 2^Energy Counter kWh} *)
	.fbVFD_B3.bRunStop AT %QX3188.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Receive PDO mapping 22^Run/Stop^Run/Stop[0]} *)
	.fbVFD_B3.bDirection AT %QX3188.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Receive PDO mapping 22^Direction^Direction[0]} *)
	.fbVFD_B3.nSpeed AT %QB3189 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Receive PDO mapping 22^Speed Request} *)
	.fbVFD_B3.bDriveReset AT %QX3191.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^Receive PDO mapping 22^Drive Reset^Drive Reset[0]} *)
	.bVFD_B3DataValid AT %IX1422.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^WcState^WcStateOut} *)
	.nVFD_A1Addr AT %IB36 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A1 (SM-EtherCAT)^InfoData^AdsAddr^port} *)
	.nVFD_A2Addr AT %IB38 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A2 (SM-EtherCAT)^InfoData^AdsAddr^port} *)
	.nVFD_A3Addr AT %IB40 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle A3 (SM-EtherCAT)^InfoData^AdsAddr^port} *)
	.nVFD_B1Addr AT %IB42 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B1 (SM-EtherCAT)^InfoData^AdsAddr^port} *)
	.nVFD_B2Addr AT %IB44 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B2 (SM-EtherCAT)^InfoData^AdsAddr^port} *)
	.nVFD_B3Addr AT %IB46 : UINT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 8 (EK1122)^Spindle B3 (SM-EtherCAT)^InfoData^AdsAddr^port} *)
	.bPB1AConfirm AT %IX1422.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 1^Input} *)
	.bPB2ACycleStart AT %IX1422.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 2^Input} *)
	.bPB3ACycleCommon AT %IX1423.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 3^Input} *)
	.bPB4ADrillReturn AT %IX1423.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 4^Input} *)
	.bPB1BConfirm AT %IX1423.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 5^Input} *)
	.bPB2BCycleStart AT %IX1423.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 6^Input} *)
	.bPB3BCycleCommon AT %IX1423.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 7^Input} *)
	.bPB4BDrillReturn AT %IX1423.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 8^Input} *)
	.bChipConveyorVFDFault AT %IX1423.6 : BOOL;
	.bCleanTankLevel AT %IX1423.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 11^Input} *)
	.bCoolantTankOverflow AT %IX1424.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 12^Input} *)
	.bFilter1Dirty AT %IX1424.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 13^Input} *)
	.bFilter2Dirty AT %IX1424.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 14^Input} *)
	.bFilter3Dirty AT %IX1424.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 15^Input} *)
	.bFilter4Dirty AT %IX1424.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 1 (EL1809)^Channel 16^Input} *)
	.bACoolantPressure AT %IX1424.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 1^Input} *)
	.bBCoolantPressure AT %IX1424.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 2^Input} *)
	.bLubeLevel AT %IX1424.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 3^Input} *)
	.bLubePressure AT %IX1425.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 4^Input} *)
	.bHydraulicSystemLevel AT %IX1425.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 5^Input} *)
	.bHydraulicSystemPressure AT %IX1425.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 6^Input} *)
	.bHydraulicTemperature AT %IX1425.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 7^Input} *)
	.bPneumaticSystemPressure AT %IX1425.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 9^Input} *)
	.bMCC_SConfirm AT %IX1425.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 11^Input} *)
	.bMCR AT %IX1425.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 2 (EL1809)^Channel 16^Input} *)
	.nCoolantTemp AT %IB48 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 4 (EL3311)^TC Inputs^Value} *)
	.nSpindleTachA1 AT %IB50 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 7 (EL3152)^Channel 1^Value} *)
	.nCoolantFlowA1 AT %IB52 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 7 (EL3152)^Channel 2^Value} *)
	.nSpindleTachA2 AT %IB54 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 8(EL3152)^Channel 1^Value} *)
	.nCoolantFlowA2 AT %IB56 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 8(EL3152)^Channel 2^Value} *)
	.nSpindleTachA3 AT %IB58 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 9 (EL3152)^Channel 1^Value} *)
	.nCoolantFlowA3 AT %IB60 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 9 (EL3152)^Channel 2^Value} *)
	.nSpindleTachB1 AT %IB62 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 11 (EL3152)^Channel 1^Value} *)
	.nCoolantFlowB1 AT %IB64 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 11 (EL3152)^Channel 2^Value} *)
	.nSpindleTachB2 AT %IB66 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 12 (EL3152)^Channel 1^Value} *)
	.nCoolantFlowB2 AT %IB68 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 12 (EL3152)^Channel 2^Value} *)
	.nSpindleTachB3 AT %IB70 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 13 (EL3152)^Channel 1^Value} *)
	.nCoolantFlowB3 AT %IB72 : INT;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 13 (EL3152)^Channel 2^Value} *)
	.bZAAxisSelected AT %IX1425.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 15 (EL1008)^Channel 1^Input} *)
	.bARate1X AT %IX1426.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 15 (EL1008)^Channel 2^Input} *)
	.bARate10X AT %IX1426.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 15 (EL1008)^Channel 3^Input} *)
	.bARate100X AT %IX1426.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 15 (EL1008)^Channel 4^Input} *)
	.bWAAxisSelected AT %IX1426.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 15 (EL1008)^Channel 5^Input} *)
	.bXAAxisSelected AT %IX1426.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 15 (EL1008)^Channel 6^Input} *)
	.bYAAxisSelected AT %IX1426.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 15 (EL1008)^Channel 7^Input} *)
	.bZBAxisSelected AT %IX1426.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 3 (EL1008)^Channel 1^Input} *)
	.bBRate1X AT %IX1426.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 3 (EL1008)^Channel 2^Input} *)
	.bBRate10X AT %IX1427.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 3 (EL1008)^Channel 3^Input} *)
	.bBRate100X AT %IX1427.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 3 (EL1008)^Channel 4^Input} *)
	.bWBAxisSelected AT %IX1427.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 3 (EL1008)^Channel 5^Input} *)
	.bXBAxisSelected AT %IX1427.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 3 (EL1008)^Channel 6^Input} *)
	.bYBAxisSelected AT %IX1427.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 3 (EL1008)^Channel 7^Input} *)
	.bHighPressureMotorRunning AT %IX1427.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 4 (EL1008)^Channel 1^Input} *)
	.bTransferPumpMotorRunning AT %IX1427.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 4 (EL1008)^Channel 2^Input} *)
	.bChipConveyorMotorRunning AT %IX1427.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 4 (EL1008)^Channel 3^Input} *)
	.bHydraulicPowerUnitRunning AT %IX1428.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 4 (EL1008)^Channel 4^Input} *)
	.bMCC_V AT %IX1428.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 4 (EL1008)^Channel 5^Input} *)
	.bProx310 AT %IX1428.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 3 (EP1008-0001)^Channel 1^Input} *)
	.bProx311 AT %IX1428.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 3 (EP1008-0001)^Channel 2^Input} *)
	.bProx312 AT %IX1428.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 3 (EP1008-0001)^Channel 3^Input} *)
	.bProx313 AT %IX1428.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 3 (EP1008-0001)^Channel 4^Input} *)
	.bRack3Comm AT %IX1428.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 3 (EP1008-0001)^WcState^WcState} *)
	.bProx410 AT %IX1428.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 4 (EP1008-0001)^Channel 1^Input} *)
	.bProx411 AT %IX1429.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 4 (EP1008-0001)^Channel 2^Input} *)
	.bProx412 AT %IX1429.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 4 (EP1008-0001)^Channel 3^Input} *)
	.bProx413 AT %IX1429.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 4 (EP1008-0001)^Channel 4^Input} *)
	.bProx414 AT %IX1429.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 4 (EP1008-0001)^Channel 5^Input} *)
	.bProx415 AT %IX1429.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 4 (EP1008-0001)^Channel 6^Input} *)
	.bRack4Comm AT %IX1429.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 30 (CU1128-B)^Rack 4 (EP1008-0001)^WcState^WcState} *)
	.bProx510 AT %IX1429.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 1^Input} *)
	.bProx511 AT %IX1429.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 2^Input} *)
	.bProx512 AT %IX1430.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 3^Input} *)
	.bProx513 AT %IX1430.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 4^Input} *)
	.bProx514 AT %IX1430.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 5^Input} *)
	.bProx515 AT %IX1430.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 6^Input} *)
	.bProx516 AT %IX1430.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 7^Input} *)
	.bProx517 AT %IX1430.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^Channel 8^Input} *)
	.bRack5Comm AT %IX1430.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 5 (EP1008-0001)^WcState^WcState} *)
	.bProx610 AT %IX1430.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 1^Input} *)
	.bProx611 AT %IX1431.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 2^Input} *)
	.bProx612 AT %IX1431.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 3^Input} *)
	.bProx613 AT %IX1431.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 4^Input} *)
	.bProx614 AT %IX1431.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 5^Input} *)
	.bProx615 AT %IX1431.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 6^Input} *)
	.bPS616 AT %IX1431.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 7^Input} *)
	.bPS617 AT %IX1431.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^Channel 8^Input} *)
	.bRack6Comm AT %IX1431.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Term 33 (CU1128-C)^Rack 6 (EP1008-0001)^WcState^WcState} *)
	.bProx720 AT %IX1432.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 1^Input} *)
	.bProx721 AT %IX1432.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 2^Input} *)
	.bProx722 AT %IX1432.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 3^Input} *)
	.bProx723 AT %IX1432.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 4^Input} *)
	.bProx724 AT %IX1432.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 5^Input} *)
	.bProx725 AT %IX1432.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 6^Input} *)
	.bPS726 AT %IX1432.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 7^Input} *)
	.bPS727 AT %IX1432.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^Channel 8^Input} *)
	.bRack7Comm AT %IX1433.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 7 (EP1008-0001)^WcState^WcState} *)
	.stReceivePanelA AT %IB74 : ST_PANEL_SEND;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Panel A (Subscriber)^Panel_A_Send^Inputs^VarData} *)
	.nReceivePanelAQuality AT %IB738 : UINT;
	.nReceivePanelACycleIndex AT %IB740 : UINT;
	.nRequestPA AT %IB742 : WORD;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Panel A (Subscriber)^Sub-Var 11^Inputs^VarData} *)
	.stReceivePanelB AT %IB744 : ST_PANEL_SEND;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Panel B (Subscriber)^Panel_B_Send^Inputs^VarData} *)
	.nReceivePanelBQuality AT %IB1408 : UINT;
	.nReceivePanelBCycleIndex AT %IB1410 : UINT;
	.nRequestPB AT %IB1412 : WORD;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Panel B (Subscriber)^Sub-Var 21^Inputs^VarData} *)
	.stCXPublish1 AT %QB4 : ST_CX_Publish1;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^CX_Publish 1 (Publisher)^Pub-Var 1^Outputs^VarData} *)
	.arrMachineInfo AT %QB1336 : ARRAY [1..20] OF STRING(30);	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Box 4 (Publisher)^Pub-Var Machine Info^Outputs^VarData} *)
	.stPartProgramSend AT %QB1956 : ST_PARTPROGRAM;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Box 4 (Publisher)^Pub-Var Part program^Outputs^VarData} *)
	.nPubFrameState AT %IB1414 : UINT;
	.nVarCtrlMachineInfo AT %QB2256 : UINT;
	.nVarCtrlAutoDisplays AT %QB2258 : UINT;
	.nVarCtrlFaultMessages AT %QB2260 : UINT;
	.nVarCtrlPanelReceive AT %QB2262 : UINT;
	.nVarCtrlPartProgramSend AT %QB2264 : UINT;
	.nVarCtrlDemo AT %QB2266 : UINT;
	.stPB AT %IB1416 : ST_Demo_PBs;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Panel A (Subscriber)^Sub-Var Demo^Inputs^VarData} *)
	.stPBB AT %IB1419 : ST_Demo_PBs;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Panel B (Subscriber)^Sub-Var Demo^Inputs^VarData} *)
	.stLT AT %QB2268 : ST_Demo_Indicators;	(*  ~ {LinkedWith:TIID^Device 2 (EtherCAT Automation Protocol)^Box 4 (Publisher)^Pub-Var Demo^Outputs^VarData} *)
	.bAServoEnable AT %QX2273.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 1^Output} *)
	.bBServoEnable AT %QX2273.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 2^Output} *)
	.bUServoEnable AT %QX2273.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 3^Output} *)
	.bMCC_S AT %QX2273.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 4^Output} *)
	.bWayLubePump AT %QX2273.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 5^Output} *)
	.bACoolantSolenoid AT %QX2273.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 6^Output} *)
	.bBCoolantSolenoid AT %QX2273.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 7^Output} *)
	.bConveyorFWDReq AT %QX2273.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 8^Output} *)
	.bHPCoolantStart_A AT %QX2274.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 9^Output} *)
	.bHPCoolantStart_B AT %QX2274.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 10^Output} *)
	.bTransferDown AT %QX2274.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 11^Output} *)
	.bTransferUp AT %QX2274.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 12^Output} *)
	.bATailstockColletUnclamp AT %QX2274.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 13^Output} *)
	.bATailstockColletClamp AT %QX2274.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 14^Output} *)
	.bBTailstockColletUnclamp AT %QX2274.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 15^Output} *)
	.bBTailstockColletClamp AT %QX2274.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 5 (EL2809)^Channel 16^Output} *)
	.bAEjectorsRetract AT %QX2275.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 1^Output} *)
	.bAEjectorsAdvance AT %QX2275.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 2^Output} *)
	.bBEjectorsRetract AT %QX2275.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 3^Output} *)
	.bBEjectorsAdvance AT %QX2275.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 4^Output} *)
	.bChipConveyorFWD AT %QX2275.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 9^Output} *)
	.bLT2 AT %QX2275.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 11^Output} *)
	.bLT3 AT %QX2275.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 12^Output} *)
	.bLT4 AT %QX2275.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 13^Output} *)
	.bLT5 AT %QX2276.0 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Rack 1 Slot 0 (EK1200)^Rack 1 Slot 6 (EL2809)^Channel 14^Output} *)
	.bLT6 AT %QX2276.1 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 6 (EL2008)^Channel 1^Output} *)
	.bHighPressureMotorOn AT %QX2276.2 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 6 (EL2008)^Channel 2^Output} *)
	.bTransferPumpOn AT %QX2276.3 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 6 (EL2008)^Channel 3^Output} *)
	.bHydraulicUnitOn AT %QX2276.4 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 6 (EL2008)^Channel 5^Output} *)
	.bChipConveyorOn AT %QX2276.5 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 6 (EL2008)^Channel 4^Output} *)
	.bVFD_A_Enable AT %QX2276.6 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 7 (EL2008)^Channel 1^Output} *)
	.bVFD_B_Enable AT %QX2276.7 : BOOL;	(*  ~ {LinkedWith:TIID^Device 1 (EtherCAT)^Box 20 (CU1128)^Rack 2 Slot 1 (EK1100)^Rack 2 Slot 7 (EL2008)^Channel 2^Output} *)
END_VAR
(* @OBJECT_END := 'TwinCAT_Configuration' *)
(* @CONNECTIONS := TwinCAT_Configuration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Variable_Configuration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_CONFIG
END_VAR

(* @OBJECT_END := 'Variable_Configuration' *)
(* @CONNECTIONS := Variable_Configuration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)


_ALARMCONFIG
_ALARMCONFIGNEXTTEXTID : 10002
_ALARMCONFIGFORMATS : 'HH$':$'mm$':$'ss','dd$'-$'MM$'-$'yyyy'
_ALARMCLASSLIST : 1
_ALARMCLASSID : 0
_ALARMCLASSACKTYPE : 0
_ALARMCLASSNAME : 'DEFAULT'
_ALARMCLASSDESCRIPTION : ''
_ALARMCLASSBGCOLORS : 16777215,16777215,16777215
_ALARMCLASSTEXTCOLORS : 3394560,255,16711680
_ALARMCLASSBITMAPS : '','',''
_ALARMACTIONLIST : 0
(* @ALARMCLASSRESETCOLORS := '_ALARMCLASSRESETCOLORS: 33023,16777215' *)
(* @ALARMCLASSRESETBITMAP := '_ALARMCLASSRESETBITMAP: $'$'' *)
_ALARMGROUPLISTNAME : 'System'
_ALARMGROUPPATH : 'System'
_ALARMGROUPLIST : 0
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0

(* @ALARMCONFIGFLAGS := '_ALARMCONFIGFLAGS: 4' *)
(* @ALARMCONFIGGLOBALDB_STR := '_ALARMCONFIGGLOBALDB_STRINGS: $'$',$'$',$'$',$'$'' *)
(* @ALARMCONFIGGLOBALDB_NUM := '_ALARMCONFIGGLOBALDB_NUMBERS: 0,0' *)
_END_ALARMCONFIG


LIBRARY
STANDARD.LIB 5.6.98 11:03:02
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 20
CONCAT: 0
CTD: 0
CTU: 0
CTUD: 0
DELETE: 0
F_TRIG: 0
FIND: 0
INSERT: 0
LEFT: 0
LEN: 0
MID: 0
R_TRIG: 0
REPLACE: 0
RIGHT: 0
RS: 0
SEMA: 0
SR: 0
TOF: 0
TON: 0
TP: 0
NumOfGVLs: 1
'Global Variables 0': 0
END_LIBRARY

LIBRARY
TcBase.lib 14.5.09 11:14:08
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 30
FW_AdsClearEvents: 0
FW_AdsLogDINT: 0
FW_AdsLogEvent: 0
FW_AdsLogLREAL: 0
FW_AdsLogSTR: 0
FW_AdsRdWrt: 0
FW_AdsRdWrtInd: 0
FW_AdsRdWrtRes: 0
FW_AdsRead: 0
FW_AdsReadDeviceInfo: 0
FW_AdsReadInd: 0
FW_AdsReadRes: 0
FW_AdsReadState: 0
FW_AdsWrite: 0
FW_AdsWriteControl: 0
FW_AdsWriteInd: 0
FW_AdsWriteRes: 0
FW_DRand: 0
FW_GetCpuAccount: 0
FW_GetCpuCounter: 0
FW_GetCurTaskIndex: 0
FW_GetSystemTime: 0
FW_GetVersionTcBase: 0
FW_LptSignal: 0
FW_MemCmp: 0
FW_MemCpy: 0
FW_MemMove: 0
FW_MemSet: 0
FW_PortRead: 2048
FW_PortWrite: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcBaseMath.lib 27.7.04 11:07:56
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 4
FW_Floor: 2048
FW_LrealFrac: 2048
FW_LrealModP: 2048
FW_LrealTrunc: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcDrive.lib 25.1.17 09:42:28
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 21
F_ConvWordToSTAX5000C1D: 2048
F_ConvWordToSTAX5000DriveStatus: 2048
F_ConvWordToSTIndraDriveCsC1D: 2048
F_ConvWordToSTIndraDriveCsDriveStatus: 2048
F_GetVersionTcDrive: 2048
FB_SoEAX5000FirmwareUpdate_ByDriveRef: 2048
FB_SoEAX5000ReadActMainVoltage_ByDriveRef: 2048
FB_SoEAX5000SetMotorCtrlWord_ByDriveRef: 2048
FB_SoEExecuteCommand_ByDriveRef: 2048
FB_SoEReadAmplifierTemperature_ByDriveRef: 2048
FB_SoEReadClassXDiag_ByDriveRef: 2048
FB_SoEReadCommandState_ByDriveRef: 2048
FB_SoEReadDcBusCurrent_ByDriveRef: 2048
FB_SoEReadDcBusVoltage_ByDriveRef: 2048
FB_SoEReadDiagMessage_ByDriveRef: 2048
FB_SoEReadDiagNumber_ByDriveRef: 2048
FB_SoEReadDiagNumberList_ByDriveRef: 2048
FB_SoEReadMotorTemperature_ByDriveRef: 2048
FB_SoEReset_ByDriveRef: 2048
FB_SoEWriteCommandControl_ByDriveRef: 2048
FB_SoEWritePassword_ByDriveRef: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
TcEtherCAT.lib 30.11.16 19:52:18
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 82
ConvertDcTimeToPathPos: 2048
ConvertDcTimeToPos: 2048
ConvertPathPosToDcTime: 2048
ConvertPosToDcTime: 2048
DCTIME_TO_DCTIMESTRUCT: 2048
DCTIME_TO_FILETIME: 2048
DCTIME_TO_STRING: 2048
DCTIME_TO_SYSTEMTIME: 2048
DCTIMESTRUCT_TO_DCTIME: 2048
F_CheckVendorId: 2048
F_ConvBK1120CouplerStateToString: 2048
F_ConvExtTimeToDcTime: 2048
F_ConvMasterDevStateToString: 2048
F_ConvProductCodeToString: 2048
F_ConvSlaveStateToBits: 2048
F_ConvSlaveStateToString: 2048
F_ConvStateToString: 2048
F_ConvTcTimeToDcTime: 2048
F_ConvTcTimeToExtTime: 2048
F_GetActualDcTime: 2048
F_GetCurDcTaskTime: 2048
F_GetCurDcTickTime: 2048
F_GetCurExtTime: 2048
F_GetVersionTcEtherCAT: 2048
FB_EcCoESdoRead: 2048
FB_EcCoESdoReadEx: 2048
FB_EcCoESdoWrite: 2048
FB_EcCoESdoWriteEx: 2048
FB_EcDcTickTimeBaseCalc: 2048
FB_EcDcTimeCtrl: 2048
FB_EcDcTimeCtrl.A_GetDay: 2048
FB_EcDcTimeCtrl.A_GetDayOfWeek: 2048
FB_EcDcTimeCtrl.A_GetHour: 2048
FB_EcDcTimeCtrl.A_GetMicro: 2048
FB_EcDcTimeCtrl.A_GetMilli: 2048
FB_EcDcTimeCtrl.A_GetMinute: 2048
FB_EcDcTimeCtrl.A_GetMonth: 2048
FB_EcDcTimeCtrl.A_GetNano: 2048
FB_EcDcTimeCtrl.A_GetSecond: 2048
FB_EcDcTimeCtrl.A_GetYear: 2048
FB_EcExtSyncCalcTimeDiff: 2048
FB_EcExtSyncCheck: 2048
FB_EcFoeAccess: 2048
FB_EcFoeClose: 2048
FB_EcFoeLoad: 2048
FB_EcFoeOpen: 2048
FB_EcGetAllSlaveAbnormalStateChanges: 2048
FB_EcGetAllSlaveAddr: 2048
FB_EcGetAllSlaveCrcErrors: 2048
FB_EcGetAllSlavePresentStateChanges: 2048
FB_EcGetAllSlaveStates: 2048
FB_EcGetConfSlaves: 2048
FB_EcGetLastProtErrInfo: 2048
FB_EcGetMasterDevState: 2048
FB_EcGetMasterState: 2048
FB_EcGetScannedSlaves: 2048
FB_EcGetSlaveCount: 2048
FB_EcGetSlaveCrcError: 2048
FB_EcGetSlaveCrcErrorEx: 2048
FB_EcGetSlaveIdentity: 2048
FB_EcGetSlaveState: 2048
FB_EcGetSlaveTopologyInfo: 2048
FB_EcLogicalReadCmd: 2048
FB_EcLogicalWriteCmd: 2048
FB_EcMasterFrameCount: 2048
FB_EcMasterFrameStatistic: 2048
FB_EcMasterFrameStatisticClearCRC: 2048
FB_EcMasterFrameStatisticClearFrames: 2048
FB_EcMasterFrameStatisticClearTxRxErr: 2048
FB_EcPhysicalReadCmd: 2048
FB_EcPhysicalWriteCmd: 2048
FB_EcReqMasterState: 2048
FB_EcReqSlaveState: 2048
FB_EcSetMasterState: 2048
FB_EcSetSlaveState: 2048
FB_EcSoERead: 2048
FB_EcSoEWrite: 2048
FB_SoERead_ByDriveRef: 2048
FB_SoEWrite_ByDriveRef: 2048
FILETIME_TO_DCTIME: 2048
STRING_TO_DCTIME: 2048
SYSTEMTIME_TO_DCTIME: 2048
NumOfGVLs: 1
Globale_Variablen: 2048
END_LIBRARY

LIBRARY
TcMath.lib 23.9.04 15:15:30
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 7
F_GetVersionTcMath: 0
FLOOR: 2048
FRAC: 2048
LMOD: 2048
LTRUNC: 2048
MODABS: 2048
MODTURNS: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcMC2.lib 13.9.17 10:18:38
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 127
_F_AxisState: 2048
_F_GetIndexGroup: 2048
_F_NcCycleCounterUpdated: 2048
_F_NcNoOfCycleCounterUpdated: 2048
_F_ReadStatus: 2048
_F_TcMC_DWORD_TO_HEXSTR: 2048
_F_TcMC_Round: 2048
_F_UpdateNcCycleCounter: 2048
_FB_MoveUniversalGeneric: 2048
_FB_MoveUniversalGeneric.ActCalcDiffCmdNo: 2048
_FB_MoveUniversalGeneric.ActErrorMessage: 2048
_FB_MoveUniversalGeneric.ActMonitorContinousMotion: 2048
_FB_MoveUniversalGeneric.ActMonitorDiscreteMotion: 2048
_FB_MoveUniversalGeneric.ActMonitorStop: 2048
_FB_MoveUniversalGeneric.ActNcCycleCounter: 2048
_FB_PhasingGeneric: 2048
_FB_PositionCorrectionTableLookup: 2048
_FB_PositionCorrectionTableLookup.ActIsCompensationDirection: 2048
_FB_ReadWriteParameter: 2048
_FBAXIS_REF: 2048
_FBAXIS_REF.ReadStatus: 2048
_MC_HaltPhasing: 2048
_MC_PhasingAbsolute: 2048
_MC_PhasingRelative: 2048
_TcMC_ADSRDWRT: 2048
_TcMC_ADSREAD: 2048
_TcMC_ADSWRITE: 2048
_TCMCGLOBAL: 2048
_TCMCGLOBAL.ReadDeviceInfo: 2048
F_AxisCamDataQueued: 2048
F_AxisCamScalingPending: 2048
F_AxisCamTableQueued: 2048
F_AxisControlLoopClosed: 2048
F_AxisExternalLatchValid: 2048
F_AxisGotNewTargetPosition: 2048
F_AxisHasBeenStopped: 2048
F_AxisHasExtSetPointGen: 2048
F_AxisHasJob: 2048
F_AxisInErrorState: 2048
F_AxisInPositionWindow: 2048
F_AxisInProtectedMode: 2048
F_AxisInPTPmode: 2048
F_AxisIoDataIsInvalid: 2048
F_AxisIsAtTargetPosition: 2048
F_AxisIsCalibrated: 2048
F_AxisIsCalibrating: 2048
F_AxisIsCompensating: 2048
F_AxisIsCoupled: 2048
F_AxisIsMoving: 2048
F_AxisIsMovingBackwards: 2048
F_AxisIsMovingEndless: 2048
F_AxisIsMovingForward: 2048
F_AxisIsNotMoving: 2048
F_AxisIsReady: 2048
F_AxisJobPending: 2048
F_AxisMotionCommandsLocked: 2048
F_AxisPhasingActive: 2048
F_AxisReachedConstantVelocity: 2048
F_GetVersion_TcMC2: 2048
MC_AbortSuperposition: 2048
MC_AbortTrigger: 2048
MC_AbortTrigger_V2_00: 2048
MC_BacklashCompensation: 2048
MC_ExtSetPointGenDisable: 2048
MC_ExtSetPointGenEnable: 2048
MC_ExtSetPointGenFeed: 2048
MC_GearIn: 2048
MC_GearIn.ActGearInDyn: 2048
MC_GearIn.WriteGearRatio: 2048
MC_GearInDyn: 2048
MC_GearInMultiMaster: 2048
MC_GearInMultiMaster.ActGearInMultiMasterV1: 2048
MC_GearInMultiMaster.ActGearInMultiMasterV2: 2048
MC_GearOut: 2048
MC_Halt: 2048
MC_Home: 2048
MC_Jog: 2048
MC_Jog.ActCheckJogEnd: 2048
MC_Jog.ActJogMove: 2048
MC_MoveAbsolute: 2048
MC_MoveAdditive: 2048
MC_MoveContinuousAbsolute: 2048
MC_MoveContinuousRelative: 2048
MC_MoveModulo: 2048
MC_MoveModulo.MC_MoveModuloCall: 2048
MC_MoveRelative: 2048
MC_MoveSuperImposed: 2048
MC_MoveVelocity: 2048
MC_OverrideFilter: 2048
MC_PositionCorrectionLimiter: 2048
MC_Power: 2048
MC_PowerStepper: 2048
MC_ReadActualPosition: 2048
MC_ReadActualVelocity: 2048
MC_ReadApplicationRequest: 2048
MC_ReadAxisComponents: 2048
MC_ReadAxisError: 2048
MC_ReadBoolParameter: 2048
MC_ReadDriveAddress: 2048
MC_ReadParameter: 2048
MC_ReadParameterSet: 2048
MC_ReadParameterSet.ActGetSizeOfParameterSet: 2048
MC_ReadStatus: 2048
MC_ReadStopInfo: 2048
MC_Reset: 2048
MC_SetAcceptBlockedDriveSignal: 2048
MC_SetEncoderScalingFactor: 2048
MC_SetOverride: 2048
MC_SetPosition: 2048
MC_Stop: 2048
MC_Stop.ActStop: 2048
MC_TableBasedPositionCompensation: 2048
MC_TouchProbe: 2048
MC_TouchProbe.ActTouchProbeActivate: 2048
MC_TouchProbe.ActTouchProbeMonitorActivity: 2048
MC_TouchProbe.ActTouchProbeMonitorLatchValid: 2048
MC_TouchProbe.ActTouchProbeMonitorPlcEvent: 2048
MC_TouchProbe.ActTouchProbeStartupInit: 2048
MC_TouchProbe_V2_00: 2048
MC_TouchProbe_V2_00.ActTouchProbeActivate: 2048
MC_TouchProbe_V2_00.ActTouchProbeMonitorActivity: 2048
MC_TouchProbe_V2_00.ActTouchProbeMonitoring: 2048
MC_TouchProbe_V2_00.ActTouchProbeMonitorLatchValid: 2048
MC_TouchProbe_V2_00.ActTouchProbeMonitorPlcEvent: 2048
MC_TouchProbe_V2_00.ActTouchProbeStartupInit: 2048
MC_WriteBoolParameter: 2048
MC_WriteParameter: 2048
NumOfGVLs: 1
TcMC_GlobalConstants: 2048
END_LIBRARY

LIBRARY
TcMc2Drive.lib 9.10.17 15:27:28
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 21
F_GetVersionTcMc2Drive: 2048
FB_SoEAX5000DeletePositionOffset: 2048
FB_SoEAX5000FirmwareUpdate: 2048
FB_SoEAX5000ReadActMainVoltage: 2048
FB_SoEAX5000SetMotorCtrlWord: 2048
FB_SoEAX5000SetPositionOffset: 2048
FB_SoEExecuteCommand: 2048
FB_SoERead: 2048
FB_SoEReadAmplifierTemperature: 2048
FB_SoEReadClassXDiag: 2048
FB_SoEReadCommandState: 2048
FB_SoEReadDcBusCurrent: 2048
FB_SoEReadDcBusVoltage: 2048
FB_SoEReadDiagMessage: 2048
FB_SoEReadDiagNumber: 2048
FB_SoEReadDiagNumberList: 2048
FB_SoEReadMotorTemperature: 2048
FB_SoEReset: 2048
FB_SoEWrite: 2048
FB_SoEWriteCommandControl: 2048
FB_SoEWritePassword: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
TcNC.lib 10.10.08 17:55:34
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 61
AXACT: 0
AXACTEX: 0
AXCPL: 0
AXCPLMULTITAB: 0
AXCPLTAB: 0
AXFNC: 0
AxisCamDataQueued: 2048
AxisCamScalingPending: 2048
AxisCamTableQueued: 2048
AxisControlLoopClosed: 2048
AxisDriveDeviceError: 2048
AxisExternalLatchValid: 0
AxisGetOverridePercent: 0
AxisGotNewTargetPosition: 0
AxisHasBeenStopped: 0
AxisHasExtSetPointGen: 0
AxisHasJob: 0
AxisInErrorState: 0
AxisInPositionWindow: 0
AxisInProtectedMode: 0
AxisInPTPMode: 2048
AxisIoDataIsInvalid: 2048
AxisIsAtTargetPosition: 0
AxisIsCalibrated: 0
AxisIsCalibrating: 0
AxisIsCompensating: 0
AxisIsCoupled: 0
AxisIsMoving: 0
AxisIsMovingBackwards: 0
AxisIsMovingEndless: 2048
AxisIsMovingForward: 0
AxisIsNotInTargetPosition: 0
AxisIsNotMoving: 0
AxisIsReady: 0
AxisJobPending: 2048
AxisReachedConstantVelocity: 0
AxisSetAcceptBlockedDriveSignal: 2048
AxisSetControllerEnable: 0
AxisSetFeedEnableMinus: 0
AxisSetFeedEnablePlus: 0
AxisSetOverridePercent: 0
AxisSetReferencingCamSignal: 0
AxisSoftLimitMaxExceeded: 2048
AxisSoftLimitMinExceeded: 2048
AXSCOM: 0
F_GetCompensationElementAt: 2048
F_GetLeftIndex: 2048
F_GetVersionTcNC: 0
F_IsCompensationDirection: 2048
F_LinearInterpolationCompensation: 2048
FB_AxisNewTargPosAndVelo: 0
FB_GetAxisAmsAddr: 2048
FB_PositionCompensation: 2048
FB_RegisterComKL25xx: 2048
FB_RegisterComKL25xx.ActCheckTerminalType: 2048
FB_RegisterComKL25xx.ActNcTerminalMappingIn: 2048
FB_RegisterComKL25xx.ActNcTerminalMappingOut: 2048
FB_RegisterComKL25xx.ActReadNcTerminalProcessImage: 2048
FB_RegisterComKL25xx.ActWriteNcTerminalProcessImage: 2048
FB_WritePositionCorrection: 2048
Get_TcNcUtilities_Version: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

LIBRARY
TcSystem.lib 7.6.16 11:01:22
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 84
ADSCLEAREVENTS: 0
ADSLOGDINT: 0
ADSLOGEVENT: 0
ADSLOGLREAL: 0
ADSLOGSTR: 0
ADSRDDEVINFO: 0
ADSRDSTATE: 0
ADSRDWRT: 0
ADSRDWRTEX: 0
ADSRDWRTIND: 0
ADSRDWRTRES: 0
ADSREAD: 0
ADSREADEX: 0
ADSREADIND: 0
ADSREADRES: 0
ADSWRITE: 0
ADSWRITEIND: 0
ADSWRITERES: 0
ADSWRTCTL: 0
AnalyzeExpression: 2048
AnalyzeExpressionCombined: 2048
AnalyzeExpressionTable: 2048
AppendErrorString: 2048
BAVERSION_TO_DWORD: 2048
CLEARBIT32: 0
CSETBIT32: 0
DRAND: 0
F_CompareFwVersion: 2048
F_CreateAmsNetId: 0
F_CreateIPv4Addr: 2048
F_GetStructMemberAlignment: 2048
F_GetVersionTcSystem: 0
F_IOPortRead: 2048
F_IOPortWrite: 2048
F_ScanAmsNetIds: 2048
F_ScanIPv4AddrIds: 2048
F_SplitPathName: 2048
F_ToASC: 2048
F_ToCHR: 2048
FB_AdsReadWriteList: 2048
FB_BaDeviceIoControl: 2048
FB_BaGenGetVersion: 2048
FB_CreateDir: 2048
FB_EOF: 0
FB_FileClose: 0
FB_FileDelete: 0
FB_FileGets: 0
FB_FileOpen: 0
FB_FilePuts: 0
FB_FileRead: 0
FB_FileRename: 0
FB_FileSeek: 0
FB_FileTell: 0
FB_FileWrite: 0
FB_PcWatchdog: 2048
FB_PcWatchdog_BAPI: 2048
FB_RemoveDir: 2048
FB_SetLedColor_BAPI: 2048
FB_SimpleAdsLogEvent: 2048
FILECLOSE: 0
FILEOPEN: 0
FILEREAD: 0
FILESEEK: 0
FILEWRITE: 0
FW_CallGenericFb: 2048
FW_CallGenericFbEx: 2048
FW_CallGenericFun: 2048
GETBIT32: 0
GETCPUACCOUNT: 0
GETCPUCOUNTER: 0
GETCURTASKINDEX: 0
GETSYSTEMTIME: 0
GETTASKTIME: 2048
LPTSIGNAL: 0
MEMCMP: 0
MEMCPY: 0
MEMMOVE: 0
MEMSET: 0
ROL32: 0
ROR32: 0
SETBIT32: 0
SFCActionControl: 0
SHL32: 0
SHR32: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

LIBRARY
TcTestAndSet.lib 23.2.09 11:50:08
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 1
TestAndSet: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
TcUtilities.lib 3.2.16 16:08:58
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 330
ARG_TO_CSVFIELD: 2048
BCD_TO_DEC: 0
BE128_TO_HOST: 2048
BE16_TO_HOST: 2048
BE32_TO_HOST: 2048
BE64_TO_HOST: 2048
BYTE_TO_BINSTR: 2048
BYTE_TO_DECSTR: 2048
BYTE_TO_HEXSTR: 2048
BYTE_TO_LREALEX: 2048
BYTE_TO_OCTSTR: 2048
BYTEARR_TO_MAXSTRING: 2048
CSVFIELD_TO_ARG: 2048
CSVFIELD_TO_STRING: 2048
DATA_TO_HEXSTR: 2048
DCF77_TIME: 2048
DCF77_TIME_EX: 2048
DEC_TO_BCD: 0
DEG_TO_RAD: 0
DINT_TO_DECSTR: 2048
DT_TO_FILETIME: 2048
DT_TO_SYSTEMTIME: 0
DWORD_TO_BINSTR: 2048
DWORD_TO_DECSTR: 2048
DWORD_TO_HEXSTR: 2048
DWORD_TO_LREALEX: 2048
DWORD_TO_OCTSTR: 2048
F_ARGCMP: 2048
F_ARGCPY: 2048
F_ARGIsZero: 2048
F_BIGTYPE: 2048
F_BOOL: 2048
F_BYTE: 0
F_BYTE_TO_CRC16_CCITT: 2048
F_CheckSum16: 0
F_CRC16_CCITT: 0
F_CreateHashTableHnd: 2048
F_CreateLinkedListHnd: 2048
F_DATA_TO_CRC16_CCITT: 2048
F_DINT: 0
F_DWORD: 0
F_FormatArgToStr: 2048
F_GetDayOfMonthEx: 2048
F_GetDayOfWeek: 2048
F_GetDOYOfYearMonthDay: 2048
F_GetFloatRec: 2048
F_GetMaxMonthDays: 2048
F_GetMonthOfDOY: 2048
F_GetVersionTcUtilities: 0
F_GetWeekOfTheYear: 2048
F_HUGE: 2048
F_INT: 0
F_LARGE: 2048
F_LREAL: 0
F_LTrim: 2048
F_PVOID: 2048
F_REAL: 0
F_RTrim: 2048
F_SINT: 0
F_STRING: 0
F_SwapReal: 0
F_SwapRealEx: 2048
F_ToLCase: 2048
F_ToUCase: 2048
F_TranslateFileTimeBias: 2048
F_UDINT: 0
F_UHUGE: 2048
F_UINT: 0
F_ULARGE: 2048
F_USINT: 0
F_WORD: 0
F_YearIsLeapYear: 2048
FB_AddRouteEntry: 2048
FB_AmsLogger: 2048
FB_BasicPID: 0
FB_BufferedTextFileWriter: 2048
FB_BufferedTextFileWriter.A_Reset: 2048
FB_ConnectScopeServer: 2048
FB_CSVMemBufferReader: 2048
FB_CSVMemBufferWriter: 2048
FB_DbgOutputCtrl: 2048
FB_DbgOutputCtrl.A_Log: 2048
FB_DbgOutputCtrl.A_LogHex: 2048
FB_DbgOutputCtrl.A_Reset: 2048
FB_DisconnectScopeServer: 2048
FB_EnumFindFileEntry: 2048
FB_EnumFindFileList: 2048
FB_EnumRouteEntry: 2048
FB_EnumStringNumbers: 2048
FB_FileRingBuffer: 2048
FB_FileRingBuffer.A_AddTail: 2048
FB_FileRingBuffer.A_Close: 2048
FB_FileRingBuffer.A_Create: 2048
FB_FileRingBuffer.A_GetHead: 2048
FB_FileRingBuffer.A_Open: 2048
FB_FileRingBuffer.A_RemoveHead: 2048
FB_FileRingBuffer.A_Reset: 2048
FB_FileTimeToTzSpecificLocalTime: 2048
FB_FileTimeToTzSpecificLocalTime.A_Reset: 2048
FB_FormatString: 0
FB_GetAdaptersInfo: 2048
FB_GetDeviceIdentification: 2048
FB_GetDeviceIdentificationEx: 2048
FB_GetHostAddrByName: 2048
FB_GetHostName: 2048
FB_GetLocalAmsNetId: 2048
FB_GetRouterStatusInfo: 2048
FB_GetTimeZoneInformation: 2048
FB_HashTableCtrl: 2048
FB_HashTableCtrl.A_Add: 2048
FB_HashTableCtrl.A_GetFirst: 2048
FB_HashTableCtrl.A_GetIndexAtPosPtr: 2048
FB_HashTableCtrl.A_GetNext: 2048
FB_HashTableCtrl.A_Lookup: 2048
FB_HashTableCtrl.A_Remove: 2048
FB_HashTableCtrl.A_RemoveAll: 2048
FB_HashTableCtrl.A_RemoveFirst: 2048
FB_HashTableCtrl.A_Reset: 2048
FB_LinkedListCtrl: 2048
FB_LinkedListCtrl.A_AddHeadValue: 2048
FB_LinkedListCtrl.A_AddTailValue: 2048
FB_LinkedListCtrl.A_FindNext: 2048
FB_LinkedListCtrl.A_FindPrev: 2048
FB_LinkedListCtrl.A_GetHead: 2048
FB_LinkedListCtrl.A_GetIndexAtPosPtr: 2048
FB_LinkedListCtrl.A_GetNext: 2048
FB_LinkedListCtrl.A_GetPrev: 2048
FB_LinkedListCtrl.A_GetTail: 2048
FB_LinkedListCtrl.A_RemoveHeadValue: 2048
FB_LinkedListCtrl.A_RemoveTailValue: 2048
FB_LinkedListCtrl.A_RemoveValueAtPosPtr: 2048
FB_LinkedListCtrl.A_Reset: 2048
FB_LinkedListCtrl.A_SetValueAtPosPtr: 2048
FB_LocalSystemTime: 2048
FB_MemBufferMerge: 2048
FB_MemBufferSplit: 2048
FB_MemRingBuffer: 2048
FB_MemRingBuffer.A_AddTail: 2048
FB_MemRingBuffer.A_GetHead: 2048
FB_MemRingBuffer.A_RemoveHead: 2048
FB_MemRingBuffer.A_Reset: 2048
FB_MemRingBufferEx: 2048
FB_MemRingBufferEx.A_AddTail: 2048
FB_MemRingBufferEx.A_FreeHead: 2048
FB_MemRingBufferEx.A_GetFreeSize: 2048
FB_MemRingBufferEx.A_GetHead: 2048
FB_MemRingBufferEx.A_Reset: 2048
FB_MemStackBuffer: 2048
FB_MemStackBuffer.A_Pop: 2048
FB_MemStackBuffer.A_Push: 2048
FB_MemStackBuffer.A_Reset: 2048
FB_MemStackBuffer.A_Top: 2048
FB_RegQueryValue: 0
FB_RegSetValue: 0
FB_RemoveRouteEntry: 2048
FB_ResetScopeServerControl: 2048
FB_SaveScopeServerData: 2048
FB_ScopeServerControl: 2048
FB_SetTimeZoneInformation: 2048
FB_StartScopeServer: 2048
FB_StopScopeServer: 2048
FB_StringRingBuffer: 2048
FB_StringRingBuffer.A_AddTail: 2048
FB_StringRingBuffer.A_GetHead: 2048
FB_StringRingBuffer.A_RemoveHead: 2048
FB_StringRingBuffer.A_Reset: 2048
FB_SystemTimeToTzSpecificLocalTime: 2048
FB_SystemTimeToTzSpecificLocalTime.A_Reset: 2048
FB_TextFileRingBuffer: 2048
FB_TextFileRingBuffer.A_AddTail: 2048
FB_TextFileRingBuffer.A_Close: 2048
FB_TextFileRingBuffer.A_Open: 2048
FB_TextFileRingBuffer.A_Reset: 2048
FB_TranslateLocalTimeToUtcByZoneID: 2048
FB_TranslateLocalTimeToUtcByZoneID.A_Reset: 2048
FB_TranslateUtcToLocalTimeByZoneID: 2048
FB_TranslateUtcToLocalTimeByZoneID.A_Reset: 2048
FB_TzSpecificLocalTimeToFileTime: 2048
FB_TzSpecificLocalTimeToFileTime.A_Reset: 2048
FB_TzSpecificLocalTimeToSystemTime: 2048
FB_TzSpecificLocalTimeToSystemTime.A_Reset: 2048
FB_WritePersistentData: 2048
FILETIME_TO_DT: 2048
FILETIME_TO_SYSTEMTIME: 2048
FIX16_TO_LREAL: 2048
FIX16_TO_WORD: 2048
FIX16Add: 2048
FIX16Align: 2048
FIX16Div: 2048
FIX16Mul: 2048
FIX16Sub: 2048
GetRemotePCInfo: 0
GUID_TO_REGSTRING: 2048
GUID_TO_STRING: 2048
GuidsEqualByVal: 2048
HEXASCNIBBLE_TO_BYTE: 2048
HEXCHRNIBBLE_TO_BYTE: 2048
HEXSTR_TO_DATA: 2048
HOST_TO_BE128: 2048
HOST_TO_BE16: 2048
HOST_TO_BE32: 2048
HOST_TO_BE64: 2048
INT64_TO_LREAL: 2048
Int64Add64: 2048
Int64Add64Ex: 2048
Int64Cmp64: 2048
Int64Div64Ex: 2048
Int64IsZero: 2048
Int64Negate: 2048
Int64Not: 2048
Int64Sub64: 2048
IsFinite: 2048
LARGE_INTEGER: 2048
LARGE_TO_ULARGE: 2048
LREAL_TO_FIX16: 2048
LREAL_TO_FMTSTR: 2048
LREAL_TO_INT64: 2048
LREAL_TO_UINT64: 2048
MAXSTRING_TO_BYTEARR: 2048
NT_AbortShutdown: 0
NT_GetTime: 0
NT_Reboot: 0
NT_SetLocalTime: 2048
NT_SetTimeToRTCTime: 0
NT_Shutdown: 0
NT_StartProcess: 0
OTSTRUCT_TO_TIME: 0
PBOOL_TO_BOOL: 2048
PBYTE_TO_BYTE: 2048
PDATE_TO_DATE: 2048
PDINT_TO_DINT: 2048
PDT_TO_DT: 2048
PDWORD_TO_DWORD: 2048
PHUGE_TO_HUGE: 2048
PINT_TO_INT: 2048
PLARGE_TO_LARGE: 2048
PLC_ReadSymInfo: 0
PLC_ReadSymInfoByName: 0
PLC_ReadSymInfoByNameEx: 0
PLC_Reset: 0
PLC_Start: 0
PLC_Stop: 0
PLREAL_TO_LREAL: 2048
PMAXSTRING_TO_MAXSTRING: 2048
PREAL_TO_REAL: 2048
Profiler: 0
PSINT_TO_SINT: 2048
PSTRING_TO_STRING: 2048
PTIME_TO_TIME: 2048
PTOD_TO_TOD: 2048
PUDINT_TO_UDINT: 2048
PUHUGE_TO_UHUGE: 2048
PUINT64_TO_UINT64: 2048
PUINT_TO_UINT: 2048
PULARGE_TO_ULARGE: 2048
PUSINT_TO_USINT: 2048
PVOID_TO_BINSTR: 2048
PVOID_TO_DECSTR: 2048
PVOID_TO_HEXSTR: 2048
PVOID_TO_OCTSTR: 2048
PVOID_TO_STRING: 2048
PWORD_TO_WORD: 2048
RAD_TO_DEG: 0
REGSTRING_TO_GUID: 2048
ROUTETRANSPORT_TO_STRING: 2048
RTC: 2048
RTC_EX: 2048
RTC_EX2: 2048
ScopeASCIIExport: 0
ScopeExit: 2048
ScopeGetRecordLen: 0
ScopeGetState: 0
ScopeLoadFile: 0
ScopeManualTrigger: 0
ScopeSaveAs: 2048
ScopeSetOffline: 0
ScopeSetOnline: 0
ScopeSetRecordLen: 0
ScopeViewExport: 0
STRING_TO_CSVFIELD: 2048
STRING_TO_GUID: 2048
STRING_TO_PVOID: 2048
STRING_TO_SYSTEMTIME: 2048
STRING_TO_UINT64: 2048
SYSTEMTIME_TO_DT: 0
SYSTEMTIME_TO_FILETIME: 2048
SYSTEMTIME_TO_STRING: 2048
TC_Config: 2048
TC_CpuUsage: 0
TC_Restart: 0
TC_Stop: 0
TC_SysLatency: 0
TIME_TO_OTSTRUCT: 0
UDINT_TO_LREALEX: 2048
UInt32x32To64: 2048
UINT64_TO_LREAL: 2048
UINT64_TO_STRING: 2048
UInt64Add64: 2048
UInt64Add64Ex: 2048
UInt64And: 2048
UInt64Cmp64: 2048
UInt64Div16Ex: 2048
UInt64Div64: 2048
UInt64Div64Ex: 2048
UInt64isZero: 2048
UInt64Limit: 2048
UInt64Max: 2048
UInt64Min: 2048
UInt64Mod64: 2048
UInt64Mul64: 2048
UInt64Mul64Ex: 2048
UInt64Not: 2048
UInt64Or: 2048
UInt64Rol: 2048
UInt64Ror: 2048
UInt64Shl: 2048
UInt64Shr: 2048
UInt64Sub64: 2048
UInt64Xor: 2048
UINT_TO_LREALEX: 2048
ULARGE_INTEGER: 2048
ULARGE_TO_LARGE: 2048
USINT_TO_LREALEX: 2048
WORD_TO_BINSTR: 2048
WORD_TO_DECSTR: 2048
WORD_TO_FIX16: 2048
WORD_TO_HEXSTR: 2048
WORD_TO_LREALEX: 2048
WORD_TO_OCTSTR: 2048
WritePersistentData: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

PLC_CONFIGURATION
_ELEMENT 15700
_ELEMENT_END
PLC_END


RESOURCE

TASK Standard (PRIORITY := 0, INTERVAL := T#10ms);
MAIN
{Additional_info : 1,0,0,0,1,4294967295}
END_TASK

END_RESOURCE


_WORKSPACE
_GLOBALVISUALSETTINGS
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0
_VISUALBITMAPLISTCOUNT : 0
_END_GLOBALVISUALSETTINGS
_END_WORKSPACE